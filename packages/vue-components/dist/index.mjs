var ti = Object.defineProperty;
var ni = (e, t, n) => t in e ? ti(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var k = (e, t, n) => ni(e, typeof t != "symbol" ? t + "" : t, n);
import { markRaw as kn, createElementBlock as ne, openBlock as Q, createElementVNode as ue, defineComponent as At, ref as ve, computed as tn, renderSlot as Nu, toDisplayString as nn, createVNode as de, createBlock as zn, Fragment as Mt, withCtx as ui, renderList as $n, normalizeClass as un, withDirectives as ri, vShow as ii, toRefs as ai, watch as oi, onBeforeMount as si, inject as li, resolveComponent as ci, h as di, provide as fi, unref as hi } from "vue";
const pi = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
}, mi = /[&<>'"]/g, we = (e) => e.replace(
  mi,
  (t) => pi[t]
), Iu = (e, { shouldAllowHtml: t, shouldEscapeText: n }) => {
  const u = e.children ?? [], r = ["text", "emoji", "code_inline"];
  return t && r.push("html_inline"), u.filter(
    (a) => {
      var o;
      return r.includes(a.type) && // filter permalink symbol that generated by markdown-it-anchor
      !((o = a.meta) != null && o.isPermalinkSymbol);
    }
  ).reduce((a, o) => n && (o.type === "code_inline" || o.type === "text") ? `${a}${we(o.content)}` : `${a}${o.content}`, "").trim();
}, Mu = (e, {
  level: t,
  shouldAllowHtml: n,
  shouldAllowNested: u,
  shouldEscapeText: r,
  slugify: i,
  format: a
}) => {
  const o = [], s = [], l = (c) => {
    for (; s.length !== 0 && c.level <= s[0].level; )
      s.shift();
    s.length === 0 ? (o.push(c), s.push(c)) : (s[0].children.push(c), s.unshift(c));
  };
  for (let c = 0; c < e.length; c += 1) {
    const d = e[c];
    if (d.type !== "heading_open" || d.level !== 0 && !u)
      continue;
    const f = Number.parseInt(d.tag.slice(1), 10);
    if (!t.includes(f))
      continue;
    const p = e[c + 1];
    /* istanbul ignore if -- @preserve */
    if (!p)
      continue;
    const h = Iu(p, {
      shouldAllowHtml: n,
      shouldEscapeText: r
    }), g = d.attrGet("id") ?? i(h);
    l({
      level: f,
      title: (a == null ? void 0 : a(h)) ?? h,
      slug: g,
      link: `#${g}`,
      children: []
    });
  }
  return o;
}, gi = /[\u0000-\u001f]/g, _i = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'“”‘’<>,.?/]+/g, bi = /[\u0300-\u036F]/g, lt = (e) => e.normalize("NFKD").replace(bi, "").replace(gi, "").replace(_i, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/^(\d)/, "_$1").toLowerCase(), yi = (e, {
  level: t = [2, 3],
  shouldAllowNested: n = !1,
  slugify: u = lt,
  format: r
} = {}) => {
  const i = e.renderer.render.bind(e.renderer);
  e.renderer.render = (a, o, s) => (s.headers = Mu(a, {
    level: t,
    shouldAllowHtml: !1,
    shouldAllowNested: n,
    shouldEscapeText: !1,
    slugify: u,
    format: r
  }), i(a, o, s));
}, ki = (e) => {
  const t = e.renderer.render.bind(e.renderer);
  e.renderer.render = (n, u, r) => {
    const i = n.findIndex((a) => a.tag === "h1");
    return r.title = i > -1 ? Iu(n[i + 1], {
      shouldAllowHtml: !1,
      shouldEscapeText: !1
    }) : "", t(n, u, r);
  };
}, xi = ({
  listTag: e,
  listClass: t,
  itemClass: n,
  linkTag: u,
  linkClass: r
}) => {
  const i = we(e), a = t ? ` class="${we(t)}"` : "", o = "li", s = n ? ` class="${we(n)}"` : "", l = we(u), c = r ? ` class="${we(r)}"` : "", d = (p) => u === "router-link" ? ` to="${p}"` : ` href="${p}"`, f = (p) => `<${i}${a}>${p.map(
    (h) => `<${o}${s}><${l}${c}${d(h.link)}>${h.title}</${l}>${h.children.length > 0 ? f(h.children) : ""}</${o}>`
  ).join("")}</${i}>`;
  return f;
}, wi = ({
  pattern: e,
  containerTag: t,
  containerClass: n
}) => (u, r, i, a) => {
  if (u.sCount[r] - u.blkIndent >= 4)
    return !1;
  const o = u.bMarks[r] + u.tShift[r], s = u.eMarks[r], l = u.src.slice(o, s).split(" ")[0];
  if (!e.test(l))
    return !1;
  if (a)
    return !0;
  u.line = r + 1;
  const c = u.push("toc_open", t, 1);
  c.markup = "", c.map = [r, u.line], n && c.attrSet("class", n);
  const d = u.push("toc_body", "", 0);
  d.markup = l, d.map = [r, u.line], d.hidden = !0;
  const f = u.push("toc_close", t, -1);
  return f.markup = "", d.map = [r, u.line], !0;
}, Ci = (e, {
  pattern: t = /^\[\[toc\]\]$/i,
  slugify: n = lt,
  format: u,
  level: r = [2, 3],
  shouldAllowNested: i = !1,
  containerTag: a = "nav",
  containerClass: o = "table-of-contents",
  listTag: s = "ul",
  listClass: l = "",
  itemClass: c = "",
  linkTag: d = "a",
  linkClass: f = ""
} = {}) => {
  e.block.ruler.before(
    "heading",
    "toc",
    wi({
      pattern: t,
      containerTag: a,
      containerClass: o
    }),
    {
      alt: ["paragraph", "reference", "blockquote"]
    }
  );
  const p = xi({
    listTag: s,
    listClass: l,
    itemClass: c,
    linkTag: d,
    linkClass: f
  });
  e.renderer.rules.toc_body = (h) => p(
    Mu(h, {
      level: r,
      shouldAllowHtml: !0,
      shouldAllowNested: i,
      shouldEscapeText: !0,
      slugify: n,
      format: u
    })
  );
}, qn = {};
function vi(e) {
  let t = qn[e];
  if (t)
    return t;
  t = qn[e] = [];
  for (let n = 0; n < 128; n++) {
    const u = String.fromCharCode(n);
    t.push(u);
  }
  for (let n = 0; n < e.length; n++) {
    const u = e.charCodeAt(n);
    t[u] = "%" + ("0" + u.toString(16).toUpperCase()).slice(-2);
  }
  return t;
}
function De(e, t) {
  typeof t != "string" && (t = De.defaultChars);
  const n = vi(t);
  return e.replace(/(%[a-f0-9]{2})+/gi, function(u) {
    let r = "";
    for (let i = 0, a = u.length; i < a; i += 3) {
      const o = parseInt(u.slice(i + 1, i + 3), 16);
      if (o < 128) {
        r += n[o];
        continue;
      }
      if ((o & 224) === 192 && i + 3 < a) {
        const s = parseInt(u.slice(i + 4, i + 6), 16);
        if ((s & 192) === 128) {
          const l = o << 6 & 1984 | s & 63;
          l < 128 ? r += "��" : r += String.fromCharCode(l), i += 3;
          continue;
        }
      }
      if ((o & 240) === 224 && i + 6 < a) {
        const s = parseInt(u.slice(i + 4, i + 6), 16), l = parseInt(u.slice(i + 7, i + 9), 16);
        if ((s & 192) === 128 && (l & 192) === 128) {
          const c = o << 12 & 61440 | s << 6 & 4032 | l & 63;
          c < 2048 || c >= 55296 && c <= 57343 ? r += "���" : r += String.fromCharCode(c), i += 6;
          continue;
        }
      }
      if ((o & 248) === 240 && i + 9 < a) {
        const s = parseInt(u.slice(i + 4, i + 6), 16), l = parseInt(u.slice(i + 7, i + 9), 16), c = parseInt(u.slice(i + 10, i + 12), 16);
        if ((s & 192) === 128 && (l & 192) === 128 && (c & 192) === 128) {
          let d = o << 18 & 1835008 | s << 12 & 258048 | l << 6 & 4032 | c & 63;
          d < 65536 || d > 1114111 ? r += "����" : (d -= 65536, r += String.fromCharCode(55296 + (d >> 10), 56320 + (d & 1023))), i += 9;
          continue;
        }
      }
      r += "�";
    }
    return r;
  });
}
De.defaultChars = ";/?:@&=+$,#";
De.componentChars = "";
const Gn = {};
function Ai(e) {
  let t = Gn[e];
  if (t)
    return t;
  t = Gn[e] = [];
  for (let n = 0; n < 128; n++) {
    const u = String.fromCharCode(n);
    /^[0-9a-z]$/i.test(u) ? t.push(u) : t.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
  }
  for (let n = 0; n < e.length; n++)
    t[e.charCodeAt(n)] = e[n];
  return t;
}
function Je(e, t, n) {
  typeof t != "string" && (n = t, t = Je.defaultChars), typeof n > "u" && (n = !0);
  const u = Ai(t);
  let r = "";
  for (let i = 0, a = e.length; i < a; i++) {
    const o = e.charCodeAt(i);
    if (n && o === 37 && i + 2 < a && /^[0-9a-f]{2}$/i.test(e.slice(i + 1, i + 3))) {
      r += e.slice(i, i + 3), i += 2;
      continue;
    }
    if (o < 128) {
      r += u[o];
      continue;
    }
    if (o >= 55296 && o <= 57343) {
      if (o >= 55296 && o <= 56319 && i + 1 < a) {
        const s = e.charCodeAt(i + 1);
        if (s >= 56320 && s <= 57343) {
          r += encodeURIComponent(e[i] + e[i + 1]), i++;
          continue;
        }
      }
      r += "%EF%BF%BD";
      continue;
    }
    r += encodeURIComponent(e[i]);
  }
  return r;
}
Je.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Je.componentChars = "-_.!~*'()";
function xn(e) {
  let t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
}
function ct() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const Ei = /^([a-z0-9.+-]+:)/i, Si = /:[0-9]*$/, Di = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Fi = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Ti = ["{", "}", "|", "\\", "^", "`"].concat(Fi), Ri = ["'"].concat(Ti), Hn = ["%", "/", "?", ";", "#"].concat(Ri), Un = ["/", "?", "#"], Li = 255, Wn = /^[+a-z0-9A-Z_-]{0,63}$/, Pi = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Vn = {
  javascript: !0,
  "javascript:": !0
}, Zn = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function wn(e, t) {
  if (e && e instanceof ct) return e;
  const n = new ct();
  return n.parse(e, t), n;
}
ct.prototype.parse = function(e, t) {
  let n, u, r, i = e;
  if (i = i.trim(), !t && e.split("#").length === 1) {
    const l = Di.exec(i);
    if (l)
      return this.pathname = l[1], l[2] && (this.search = l[2]), this;
  }
  let a = Ei.exec(i);
  if (a && (a = a[0], n = a.toLowerCase(), this.protocol = a, i = i.substr(a.length)), (t || a || i.match(/^\/\/[^@\/]+@[^@\/]+/)) && (r = i.substr(0, 2) === "//", r && !(a && Vn[a]) && (i = i.substr(2), this.slashes = !0)), !Vn[a] && (r || a && !Zn[a])) {
    let l = -1;
    for (let h = 0; h < Un.length; h++)
      u = i.indexOf(Un[h]), u !== -1 && (l === -1 || u < l) && (l = u);
    let c, d;
    l === -1 ? d = i.lastIndexOf("@") : d = i.lastIndexOf("@", l), d !== -1 && (c = i.slice(0, d), i = i.slice(d + 1), this.auth = c), l = -1;
    for (let h = 0; h < Hn.length; h++)
      u = i.indexOf(Hn[h]), u !== -1 && (l === -1 || u < l) && (l = u);
    l === -1 && (l = i.length), i[l - 1] === ":" && l--;
    const f = i.slice(0, l);
    i = i.slice(l), this.parseHost(f), this.hostname = this.hostname || "";
    const p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      const h = this.hostname.split(/\./);
      for (let g = 0, m = h.length; g < m; g++) {
        const b = h[g];
        if (b && !b.match(Wn)) {
          let _ = "";
          for (let y = 0, x = b.length; y < x; y++)
            b.charCodeAt(y) > 127 ? _ += "x" : _ += b[y];
          if (!_.match(Wn)) {
            const y = h.slice(0, g), x = h.slice(g + 1), C = b.match(Pi);
            C && (y.push(C[1]), x.unshift(C[2])), x.length && (i = x.join(".") + i), this.hostname = y.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > Li && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const o = i.indexOf("#");
  o !== -1 && (this.hash = i.substr(o), i = i.slice(0, o));
  const s = i.indexOf("?");
  return s !== -1 && (this.search = i.substr(s), i = i.slice(0, s)), i && (this.pathname = i), Zn[n] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
ct.prototype.parseHost = function(e) {
  let t = Si.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
const Ni = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: De,
  encode: Je,
  format: xn,
  parse: wn
}, Symbol.toStringTag, { value: "Module" })), Ou = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Bu = /[\0-\x1F\x7F-\x9F]/, Ii = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, Cn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, ju = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, zu = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, Mi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any: Ou,
  Cc: Bu,
  Cf: Ii,
  P: Cn,
  S: ju,
  Z: zu
}, Symbol.toStringTag, { value: "Module" })), Oi = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((e) => e.charCodeAt(0))
), Bi = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((e) => e.charCodeAt(0))
);
var Ot;
const ji = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), zi = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Ot = String.fromCodePoint) !== null && Ot !== void 0 ? Ot : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function $i(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = ji.get(e)) !== null && t !== void 0 ? t : e;
}
var z;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(z || (z = {}));
const qi = 32;
var pe;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(pe || (pe = {}));
function rn(e) {
  return e >= z.ZERO && e <= z.NINE;
}
function Gi(e) {
  return e >= z.UPPER_A && e <= z.UPPER_F || e >= z.LOWER_A && e <= z.LOWER_F;
}
function Hi(e) {
  return e >= z.UPPER_A && e <= z.UPPER_Z || e >= z.LOWER_A && e <= z.LOWER_Z || rn(e);
}
function Ui(e) {
  return e === z.EQUALS || Hi(e);
}
var O;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(O || (O = {}));
var he;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(he || (he = {}));
class Wi {
  constructor(t, n, u) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = u, this.state = O.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = he.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = O.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case O.EntityStart:
        return t.charCodeAt(n) === z.NUM ? (this.state = O.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = O.NamedEntity, this.stateNamedEntity(t, n));
      case O.NumericStart:
        return this.stateNumericStart(t, n);
      case O.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case O.NumericHex:
        return this.stateNumericHex(t, n);
      case O.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | qi) === z.LOWER_X ? (this.state = O.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = O.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, u, r) {
    if (n !== u) {
      const i = u - n;
      this.result = this.result * Math.pow(r, i) + parseInt(t.substr(n, i), r), this.consumed += i;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const u = n;
    for (; n < t.length; ) {
      const r = t.charCodeAt(n);
      if (rn(r) || Gi(r))
        n += 1;
      else
        return this.addToNumericResult(t, u, n, 16), this.emitNumericEntity(r, 3);
    }
    return this.addToNumericResult(t, u, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const u = n;
    for (; n < t.length; ) {
      const r = t.charCodeAt(n);
      if (rn(r))
        n += 1;
      else
        return this.addToNumericResult(t, u, n, 10), this.emitNumericEntity(r, 2);
    }
    return this.addToNumericResult(t, u, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var u;
    if (this.consumed <= n)
      return (u = this.errors) === null || u === void 0 || u.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === z.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === he.Strict)
      return 0;
    return this.emitCodePoint($i(this.result), this.consumed), this.errors && (t !== z.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: u } = this;
    let r = u[this.treeIndex], i = (r & pe.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const a = t.charCodeAt(n);
      if (this.treeIndex = Vi(u, r, this.treeIndex + Math.max(1, i), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === he.Attribute && // We shouldn't have consumed any characters after the entity,
        (i === 0 || // And there should be no invalid characters.
        Ui(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (r = u[this.treeIndex], i = (r & pe.VALUE_LENGTH) >> 14, i !== 0) {
        if (a === z.SEMI)
          return this.emitNamedEntityData(this.treeIndex, i, this.consumed + this.excess);
        this.decodeMode !== he.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: u } = this, r = (u[n] & pe.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, r, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, u) {
    const { decodeTree: r } = this;
    return this.emitCodePoint(n === 1 ? r[t] & ~pe.VALUE_LENGTH : r[t + 1], u), n === 3 && this.emitCodePoint(r[t + 2], u), u;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case O.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== he.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case O.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case O.NumericHex:
        return this.emitNumericEntity(0, 3);
      case O.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case O.EntityStart:
        return 0;
    }
  }
}
function $u(e) {
  let t = "";
  const n = new Wi(e, (u) => t += zi(u));
  return function(r, i) {
    let a = 0, o = 0;
    for (; (o = r.indexOf("&", o)) >= 0; ) {
      t += r.slice(a, o), n.startEntity(i);
      const l = n.write(
        r,
        // Skip the "&"
        o + 1
      );
      if (l < 0) {
        a = o + n.end();
        break;
      }
      a = o + l, o = l === 0 ? a + 1 : a;
    }
    const s = t + r.slice(a);
    return t = "", s;
  };
}
function Vi(e, t, n, u) {
  const r = (t & pe.BRANCH_LENGTH) >> 7, i = t & pe.JUMP_TABLE;
  if (r === 0)
    return i !== 0 && u === i ? n : -1;
  if (i) {
    const s = u - i;
    return s < 0 || s >= r ? -1 : e[n + s] - 1;
  }
  let a = n, o = a + r - 1;
  for (; a <= o; ) {
    const s = a + o >>> 1, l = e[s];
    if (l < u)
      a = s + 1;
    else if (l > u)
      o = s - 1;
    else
      return e[s + r];
  }
  return -1;
}
const Zi = $u(Oi);
$u(Bi);
function qu(e, t = he.Legacy) {
  return Zi(e, t);
}
function Ji(e) {
  return Object.prototype.toString.call(e);
}
function vn(e) {
  return Ji(e) === "[object String]";
}
const Ki = Object.prototype.hasOwnProperty;
function Qi(e, t) {
  return Ki.call(e, t);
}
function Et(e) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be object");
      Object.keys(n).forEach(function(u) {
        e[u] = n[u];
      });
    }
  }), e;
}
function Gu(e, t, n) {
  return [].concat(e.slice(0, t), n, e.slice(t + 1));
}
function An(e) {
  return !(e >= 55296 && e <= 57343 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534 || e >= 0 && e <= 8 || e === 11 || e >= 14 && e <= 31 || e >= 127 && e <= 159 || e > 1114111);
}
function dt(e) {
  if (e > 65535) {
    e -= 65536;
    const t = 55296 + (e >> 10), n = 56320 + (e & 1023);
    return String.fromCharCode(t, n);
  }
  return String.fromCharCode(e);
}
const Hu = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, Xi = /&([a-z#][a-z0-9]{1,31});/gi, Yi = new RegExp(Hu.source + "|" + Xi.source, "gi"), ea = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function ta(e, t) {
  if (t.charCodeAt(0) === 35 && ea.test(t)) {
    const u = t[1].toLowerCase() === "x" ? parseInt(t.slice(2), 16) : parseInt(t.slice(1), 10);
    return An(u) ? dt(u) : e;
  }
  const n = qu(e);
  return n !== e ? n : e;
}
function na(e) {
  return e.indexOf("\\") < 0 ? e : e.replace(Hu, "$1");
}
function Fe(e) {
  return e.indexOf("\\") < 0 && e.indexOf("&") < 0 ? e : e.replace(Yi, function(t, n, u) {
    return n || ta(t, u);
  });
}
const ua = /[&<>"]/, ra = /[&<>"]/g, ia = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function aa(e) {
  return ia[e];
}
function me(e) {
  return ua.test(e) ? e.replace(ra, aa) : e;
}
const oa = /[.?*+^$[\]\\(){}|-]/g;
function sa(e) {
  return e.replace(oa, "\\$&");
}
function T(e) {
  switch (e) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function ze(e) {
  if (e >= 8192 && e <= 8202)
    return !0;
  switch (e) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function $e(e) {
  return Cn.test(e) || ju.test(e);
}
function qe(e) {
  switch (e) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function St(e) {
  return e = e.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (e = e.replace(/ẞ/g, "ß")), e.toLowerCase().toUpperCase();
}
const la = { mdurl: Ni, ucmicro: Mi }, ca = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: Gu,
  assign: Et,
  escapeHtml: me,
  escapeRE: sa,
  fromCodePoint: dt,
  has: Qi,
  isMdAsciiPunct: qe,
  isPunctChar: $e,
  isSpace: T,
  isString: vn,
  isValidEntityCode: An,
  isWhiteSpace: ze,
  lib: la,
  normalizeReference: St,
  unescapeAll: Fe,
  unescapeMd: na
}, Symbol.toStringTag, { value: "Module" }));
function da(e, t, n) {
  let u, r, i, a;
  const o = e.posMax, s = e.pos;
  for (e.pos = t + 1, u = 1; e.pos < o; ) {
    if (i = e.src.charCodeAt(e.pos), i === 93 && (u--, u === 0)) {
      r = !0;
      break;
    }
    if (a = e.pos, e.md.inline.skipToken(e), i === 91) {
      if (a === e.pos - 1)
        u++;
      else if (n)
        return e.pos = s, -1;
    }
  }
  let l = -1;
  return r && (l = e.pos), e.pos = s, l;
}
function fa(e, t, n) {
  let u, r = t;
  const i = {
    ok: !1,
    pos: 0,
    str: ""
  };
  if (e.charCodeAt(r) === 60) {
    for (r++; r < n; ) {
      if (u = e.charCodeAt(r), u === 10 || u === 60)
        return i;
      if (u === 62)
        return i.pos = r + 1, i.str = Fe(e.slice(t + 1, r)), i.ok = !0, i;
      if (u === 92 && r + 1 < n) {
        r += 2;
        continue;
      }
      r++;
    }
    return i;
  }
  let a = 0;
  for (; r < n && (u = e.charCodeAt(r), !(u === 32 || u < 32 || u === 127)); ) {
    if (u === 92 && r + 1 < n) {
      if (e.charCodeAt(r + 1) === 32)
        break;
      r += 2;
      continue;
    }
    if (u === 40 && (a++, a > 32))
      return i;
    if (u === 41) {
      if (a === 0)
        break;
      a--;
    }
    r++;
  }
  return t === r || a !== 0 || (i.str = Fe(e.slice(t, r)), i.pos = r, i.ok = !0), i;
}
function ha(e, t, n, u) {
  let r, i = t;
  const a = {
    // if `true`, this is a valid link title
    ok: !1,
    // if `true`, this link can be continued on the next line
    can_continue: !1,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (u)
    a.str = u.str, a.marker = u.marker;
  else {
    if (i >= n)
      return a;
    let o = e.charCodeAt(i);
    if (o !== 34 && o !== 39 && o !== 40)
      return a;
    t++, i++, o === 40 && (o = 41), a.marker = o;
  }
  for (; i < n; ) {
    if (r = e.charCodeAt(i), r === a.marker)
      return a.pos = i + 1, a.str += Fe(e.slice(t, i)), a.ok = !0, a;
    if (r === 40 && a.marker === 41)
      return a;
    r === 92 && i + 1 < n && i++, i++;
  }
  return a.can_continue = !0, a.str += Fe(e.slice(t, i)), a;
}
const pa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination: fa,
  parseLinkLabel: da,
  parseLinkTitle: ha
}, Symbol.toStringTag, { value: "Module" })), ae = {};
ae.code_inline = function(e, t, n, u, r) {
  const i = e[t];
  return "<code" + r.renderAttrs(i) + ">" + me(i.content) + "</code>";
};
ae.code_block = function(e, t, n, u, r) {
  const i = e[t];
  return "<pre" + r.renderAttrs(i) + "><code>" + me(e[t].content) + `</code></pre>
`;
};
ae.fence = function(e, t, n, u, r) {
  const i = e[t], a = i.info ? Fe(i.info).trim() : "";
  let o = "", s = "";
  if (a) {
    const c = a.split(/(\s+)/g);
    o = c[0], s = c.slice(2).join("");
  }
  let l;
  if (n.highlight ? l = n.highlight(i.content, o, s) || me(i.content) : l = me(i.content), l.indexOf("<pre") === 0)
    return l + `
`;
  if (a) {
    const c = i.attrIndex("class"), d = i.attrs ? i.attrs.slice() : [];
    c < 0 ? d.push(["class", n.langPrefix + o]) : (d[c] = d[c].slice(), d[c][1] += " " + n.langPrefix + o);
    const f = {
      attrs: d
    };
    return `<pre><code${r.renderAttrs(f)}>${l}</code></pre>
`;
  }
  return `<pre><code${r.renderAttrs(i)}>${l}</code></pre>
`;
};
ae.image = function(e, t, n, u, r) {
  const i = e[t];
  return i.attrs[i.attrIndex("alt")][1] = r.renderInlineAsText(i.children, n, u), r.renderToken(e, t, n);
};
ae.hardbreak = function(e, t, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
ae.softbreak = function(e, t, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ae.text = function(e, t) {
  return me(e[t].content);
};
ae.html_block = function(e, t) {
  return e[t].content;
};
ae.html_inline = function(e, t) {
  return e[t].content;
};
function Le() {
  this.rules = Et({}, ae);
}
Le.prototype.renderAttrs = function(t) {
  let n, u, r;
  if (!t.attrs)
    return "";
  for (r = "", n = 0, u = t.attrs.length; n < u; n++)
    r += " " + me(t.attrs[n][0]) + '="' + me(t.attrs[n][1]) + '"';
  return r;
};
Le.prototype.renderToken = function(t, n, u) {
  const r = t[n];
  let i = "";
  if (r.hidden)
    return "";
  r.block && r.nesting !== -1 && n && t[n - 1].hidden && (i += `
`), i += (r.nesting === -1 ? "</" : "<") + r.tag, i += this.renderAttrs(r), r.nesting === 0 && u.xhtmlOut && (i += " /");
  let a = !1;
  if (r.block && (a = !0, r.nesting === 1 && n + 1 < t.length)) {
    const o = t[n + 1];
    (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === r.tag) && (a = !1);
  }
  return i += a ? `>
` : ">", i;
};
Le.prototype.renderInline = function(e, t, n) {
  let u = "";
  const r = this.rules;
  for (let i = 0, a = e.length; i < a; i++) {
    const o = e[i].type;
    typeof r[o] < "u" ? u += r[o](e, i, t, n, this) : u += this.renderToken(e, i, t);
  }
  return u;
};
Le.prototype.renderInlineAsText = function(e, t, n) {
  let u = "";
  for (let r = 0, i = e.length; r < i; r++)
    switch (e[r].type) {
      case "text":
        u += e[r].content;
        break;
      case "image":
        u += this.renderInlineAsText(e[r].children, t, n);
        break;
      case "html_inline":
      case "html_block":
        u += e[r].content;
        break;
      case "softbreak":
      case "hardbreak":
        u += `
`;
        break;
    }
  return u;
};
Le.prototype.render = function(e, t, n) {
  let u = "";
  const r = this.rules;
  for (let i = 0, a = e.length; i < a; i++) {
    const o = e[i].type;
    o === "inline" ? u += this.renderInline(e[i].children, t, n) : typeof r[o] < "u" ? u += r[o](e, i, t, n, this) : u += this.renderToken(e, i, t, n);
  }
  return u;
};
function H() {
  this.__rules__ = [], this.__cache__ = null;
}
H.prototype.__find__ = function(e) {
  for (let t = 0; t < this.__rules__.length; t++)
    if (this.__rules__[t].name === e)
      return t;
  return -1;
};
H.prototype.__compile__ = function() {
  const e = this, t = [""];
  e.__rules__.forEach(function(n) {
    n.enabled && n.alt.forEach(function(u) {
      t.indexOf(u) < 0 && t.push(u);
    });
  }), e.__cache__ = {}, t.forEach(function(n) {
    e.__cache__[n] = [], e.__rules__.forEach(function(u) {
      u.enabled && (n && u.alt.indexOf(n) < 0 || e.__cache__[n].push(u.fn));
    });
  });
};
H.prototype.at = function(e, t, n) {
  const u = this.__find__(e), r = n || {};
  if (u === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__[u].fn = t, this.__rules__[u].alt = r.alt || [], this.__cache__ = null;
};
H.prototype.before = function(e, t, n, u) {
  const r = this.__find__(e), i = u || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(r, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: i.alt || []
  }), this.__cache__ = null;
};
H.prototype.after = function(e, t, n, u) {
  const r = this.__find__(e), i = u || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(r + 1, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: i.alt || []
  }), this.__cache__ = null;
};
H.prototype.push = function(e, t, n) {
  const u = n || {};
  this.__rules__.push({
    name: e,
    enabled: !0,
    fn: t,
    alt: u.alt || []
  }), this.__cache__ = null;
};
H.prototype.enable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  const n = [];
  return e.forEach(function(u) {
    const r = this.__find__(u);
    if (r < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + u);
    }
    this.__rules__[r].enabled = !0, n.push(u);
  }, this), this.__cache__ = null, n;
};
H.prototype.enableOnly = function(e, t) {
  Array.isArray(e) || (e = [e]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(e, t);
};
H.prototype.disable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  const n = [];
  return e.forEach(function(u) {
    const r = this.__find__(u);
    if (r < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + u);
    }
    this.__rules__[r].enabled = !1, n.push(u);
  }, this), this.__cache__ = null, n;
};
H.prototype.getRules = function(e) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[e] || [];
};
function Y(e, t, n) {
  this.type = e, this.tag = t, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Y.prototype.attrIndex = function(t) {
  if (!this.attrs)
    return -1;
  const n = this.attrs;
  for (let u = 0, r = n.length; u < r; u++)
    if (n[u][0] === t)
      return u;
  return -1;
};
Y.prototype.attrPush = function(t) {
  this.attrs ? this.attrs.push(t) : this.attrs = [t];
};
Y.prototype.attrSet = function(t, n) {
  const u = this.attrIndex(t), r = [t, n];
  u < 0 ? this.attrPush(r) : this.attrs[u] = r;
};
Y.prototype.attrGet = function(t) {
  const n = this.attrIndex(t);
  let u = null;
  return n >= 0 && (u = this.attrs[n][1]), u;
};
Y.prototype.attrJoin = function(t, n) {
  const u = this.attrIndex(t);
  u < 0 ? this.attrPush([t, n]) : this.attrs[u][1] = this.attrs[u][1] + " " + n;
};
function Uu(e, t, n) {
  this.src = e, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = t;
}
Uu.prototype.Token = Y;
const ma = /\r\n?|\n/g, ga = /\0/g;
function _a(e) {
  let t;
  t = e.src.replace(ma, `
`), t = t.replace(ga, "�"), e.src = t;
}
function ba(e) {
  let t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}
function ya(e) {
  const t = e.tokens;
  for (let n = 0, u = t.length; n < u; n++) {
    const r = t[n];
    r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
  }
}
function ka(e) {
  return /^<a[>\s]/i.test(e);
}
function xa(e) {
  return /^<\/a\s*>/i.test(e);
}
function wa(e) {
  const t = e.tokens;
  if (e.md.options.linkify)
    for (let n = 0, u = t.length; n < u; n++) {
      if (t[n].type !== "inline" || !e.md.linkify.pretest(t[n].content))
        continue;
      let r = t[n].children, i = 0;
      for (let a = r.length - 1; a >= 0; a--) {
        const o = r[a];
        if (o.type === "link_close") {
          for (a--; r[a].level !== o.level && r[a].type !== "link_open"; )
            a--;
          continue;
        }
        if (o.type === "html_inline" && (ka(o.content) && i > 0 && i--, xa(o.content) && i++), !(i > 0) && o.type === "text" && e.md.linkify.test(o.content)) {
          const s = o.content;
          let l = e.md.linkify.match(s);
          const c = [];
          let d = o.level, f = 0;
          l.length > 0 && l[0].index === 0 && a > 0 && r[a - 1].type === "text_special" && (l = l.slice(1));
          for (let p = 0; p < l.length; p++) {
            const h = l[p].url, g = e.md.normalizeLink(h);
            if (!e.md.validateLink(g))
              continue;
            let m = l[p].text;
            l[p].schema ? l[p].schema === "mailto:" && !/^mailto:/i.test(m) ? m = e.md.normalizeLinkText("mailto:" + m).replace(/^mailto:/, "") : m = e.md.normalizeLinkText(m) : m = e.md.normalizeLinkText("http://" + m).replace(/^http:\/\//, "");
            const b = l[p].index;
            if (b > f) {
              const C = new e.Token("text", "", 0);
              C.content = s.slice(f, b), C.level = d, c.push(C);
            }
            const _ = new e.Token("link_open", "a", 1);
            _.attrs = [["href", g]], _.level = d++, _.markup = "linkify", _.info = "auto", c.push(_);
            const y = new e.Token("text", "", 0);
            y.content = m, y.level = d, c.push(y);
            const x = new e.Token("link_close", "a", -1);
            x.level = --d, x.markup = "linkify", x.info = "auto", c.push(x), f = l[p].lastIndex;
          }
          if (f < s.length) {
            const p = new e.Token("text", "", 0);
            p.content = s.slice(f), p.level = d, c.push(p);
          }
          t[n].children = r = Gu(r, a, c);
        }
      }
    }
}
const Wu = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, Ca = /\((c|tm|r)\)/i, va = /\((c|tm|r)\)/ig, Aa = {
  c: "©",
  r: "®",
  tm: "™"
};
function Ea(e, t) {
  return Aa[t.toLowerCase()];
}
function Sa(e) {
  let t = 0;
  for (let n = e.length - 1; n >= 0; n--) {
    const u = e[n];
    u.type === "text" && !t && (u.content = u.content.replace(va, Ea)), u.type === "link_open" && u.info === "auto" && t--, u.type === "link_close" && u.info === "auto" && t++;
  }
}
function Da(e) {
  let t = 0;
  for (let n = e.length - 1; n >= 0; n--) {
    const u = e[n];
    u.type === "text" && !t && Wu.test(u.content) && (u.content = u.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), u.type === "link_open" && u.info === "auto" && t--, u.type === "link_close" && u.info === "auto" && t++;
  }
}
function Fa(e) {
  let t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (Ca.test(e.tokens[t].content) && Sa(e.tokens[t].children), Wu.test(e.tokens[t].content) && Da(e.tokens[t].children));
}
const Ta = /['"]/, Jn = /['"]/g, Kn = "’";
function tt(e, t, n) {
  return e.slice(0, t) + n + e.slice(t + 1);
}
function Ra(e, t) {
  let n;
  const u = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r], a = e[r].level;
    for (n = u.length - 1; n >= 0 && !(u[n].level <= a); n--)
      ;
    if (u.length = n + 1, i.type !== "text")
      continue;
    let o = i.content, s = 0, l = o.length;
    e:
      for (; s < l; ) {
        Jn.lastIndex = s;
        const c = Jn.exec(o);
        if (!c)
          break;
        let d = !0, f = !0;
        s = c.index + 1;
        const p = c[0] === "'";
        let h = 32;
        if (c.index - 1 >= 0)
          h = o.charCodeAt(c.index - 1);
        else
          for (n = r - 1; n >= 0 && !(e[n].type === "softbreak" || e[n].type === "hardbreak"); n--)
            if (e[n].content) {
              h = e[n].content.charCodeAt(e[n].content.length - 1);
              break;
            }
        let g = 32;
        if (s < l)
          g = o.charCodeAt(s);
        else
          for (n = r + 1; n < e.length && !(e[n].type === "softbreak" || e[n].type === "hardbreak"); n++)
            if (e[n].content) {
              g = e[n].content.charCodeAt(0);
              break;
            }
        const m = qe(h) || $e(String.fromCharCode(h)), b = qe(g) || $e(String.fromCharCode(g)), _ = ze(h), y = ze(g);
        if (y ? d = !1 : b && (_ || m || (d = !1)), _ ? f = !1 : m && (y || b || (f = !1)), g === 34 && c[0] === '"' && h >= 48 && h <= 57 && (f = d = !1), d && f && (d = m, f = b), !d && !f) {
          p && (i.content = tt(i.content, c.index, Kn));
          continue;
        }
        if (f)
          for (n = u.length - 1; n >= 0; n--) {
            let x = u[n];
            if (u[n].level < a)
              break;
            if (x.single === p && u[n].level === a) {
              x = u[n];
              let C, v;
              p ? (C = t.md.options.quotes[2], v = t.md.options.quotes[3]) : (C = t.md.options.quotes[0], v = t.md.options.quotes[1]), i.content = tt(i.content, c.index, v), e[x.token].content = tt(
                e[x.token].content,
                x.pos,
                C
              ), s += v.length - 1, x.token === r && (s += C.length - 1), o = i.content, l = o.length, u.length = n;
              continue e;
            }
          }
        d ? u.push({
          token: r,
          pos: c.index,
          single: p,
          level: a
        }) : f && p && (i.content = tt(i.content, c.index, Kn));
      }
  }
}
function La(e) {
  if (e.md.options.typographer)
    for (let t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !Ta.test(e.tokens[t].content) || Ra(e.tokens[t].children, e);
}
function Pa(e) {
  let t, n;
  const u = e.tokens, r = u.length;
  for (let i = 0; i < r; i++) {
    if (u[i].type !== "inline") continue;
    const a = u[i].children, o = a.length;
    for (t = 0; t < o; t++)
      a[t].type === "text_special" && (a[t].type = "text");
    for (t = n = 0; t < o; t++)
      a[t].type === "text" && t + 1 < o && a[t + 1].type === "text" ? a[t + 1].content = a[t].content + a[t + 1].content : (t !== n && (a[n] = a[t]), n++);
    t !== n && (a.length = n);
  }
}
const Bt = [
  ["normalize", _a],
  ["block", ba],
  ["inline", ya],
  ["linkify", wa],
  ["replacements", Fa],
  ["smartquotes", La],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", Pa]
];
function En() {
  this.ruler = new H();
  for (let e = 0; e < Bt.length; e++)
    this.ruler.push(Bt[e][0], Bt[e][1]);
}
En.prototype.process = function(e) {
  const t = this.ruler.getRules("");
  for (let n = 0, u = t.length; n < u; n++)
    t[n](e);
};
En.prototype.State = Uu;
function oe(e, t, n, u) {
  this.src = e, this.md = t, this.env = n, this.tokens = u, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const r = this.src;
  for (let i = 0, a = 0, o = 0, s = 0, l = r.length, c = !1; a < l; a++) {
    const d = r.charCodeAt(a);
    if (!c)
      if (T(d)) {
        o++, d === 9 ? s += 4 - s % 4 : s++;
        continue;
      } else
        c = !0;
    (d === 10 || a === l - 1) && (d !== 10 && a++, this.bMarks.push(i), this.eMarks.push(a), this.tShift.push(o), this.sCount.push(s), this.bsCount.push(0), c = !1, o = 0, s = 0, i = a + 1);
  }
  this.bMarks.push(r.length), this.eMarks.push(r.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
oe.prototype.push = function(e, t, n) {
  const u = new Y(e, t, n);
  return u.block = !0, n < 0 && this.level--, u.level = this.level, n > 0 && this.level++, this.tokens.push(u), u;
};
oe.prototype.isEmpty = function(t) {
  return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
};
oe.prototype.skipEmptyLines = function(t) {
  for (let n = this.lineMax; t < n && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
    ;
  return t;
};
oe.prototype.skipSpaces = function(t) {
  for (let n = this.src.length; t < n; t++) {
    const u = this.src.charCodeAt(t);
    if (!T(u))
      break;
  }
  return t;
};
oe.prototype.skipSpacesBack = function(t, n) {
  if (t <= n)
    return t;
  for (; t > n; )
    if (!T(this.src.charCodeAt(--t)))
      return t + 1;
  return t;
};
oe.prototype.skipChars = function(t, n) {
  for (let u = this.src.length; t < u && this.src.charCodeAt(t) === n; t++)
    ;
  return t;
};
oe.prototype.skipCharsBack = function(t, n, u) {
  if (t <= u)
    return t;
  for (; t > u; )
    if (n !== this.src.charCodeAt(--t))
      return t + 1;
  return t;
};
oe.prototype.getLines = function(t, n, u, r) {
  if (t >= n)
    return "";
  const i = new Array(n - t);
  for (let a = 0, o = t; o < n; o++, a++) {
    let s = 0;
    const l = this.bMarks[o];
    let c = l, d;
    for (o + 1 < n || r ? d = this.eMarks[o] + 1 : d = this.eMarks[o]; c < d && s < u; ) {
      const f = this.src.charCodeAt(c);
      if (T(f))
        f === 9 ? s += 4 - (s + this.bsCount[o]) % 4 : s++;
      else if (c - l < this.tShift[o])
        s++;
      else
        break;
      c++;
    }
    s > u ? i[a] = new Array(s - u + 1).join(" ") + this.src.slice(c, d) : i[a] = this.src.slice(c, d);
  }
  return i.join("");
};
oe.prototype.Token = Y;
const Na = 65536;
function jt(e, t) {
  const n = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  return e.src.slice(n, u);
}
function Qn(e) {
  const t = [], n = e.length;
  let u = 0, r = e.charCodeAt(u), i = !1, a = 0, o = "";
  for (; u < n; )
    r === 124 && (i ? (o += e.substring(a, u - 1), a = u) : (t.push(o + e.substring(a, u)), o = "", a = u + 1)), i = r === 92, u++, r = e.charCodeAt(u);
  return t.push(o + e.substring(a)), t;
}
function Ia(e, t, n, u) {
  if (t + 2 > n)
    return !1;
  let r = t + 1;
  if (e.sCount[r] < e.blkIndent || e.sCount[r] - e.blkIndent >= 4)
    return !1;
  let i = e.bMarks[r] + e.tShift[r];
  if (i >= e.eMarks[r])
    return !1;
  const a = e.src.charCodeAt(i++);
  if (a !== 124 && a !== 45 && a !== 58 || i >= e.eMarks[r])
    return !1;
  const o = e.src.charCodeAt(i++);
  if (o !== 124 && o !== 45 && o !== 58 && !T(o) || a === 45 && T(o))
    return !1;
  for (; i < e.eMarks[r]; ) {
    const x = e.src.charCodeAt(i);
    if (x !== 124 && x !== 45 && x !== 58 && !T(x))
      return !1;
    i++;
  }
  let s = jt(e, t + 1), l = s.split("|");
  const c = [];
  for (let x = 0; x < l.length; x++) {
    const C = l[x].trim();
    if (!C) {
      if (x === 0 || x === l.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(C))
      return !1;
    C.charCodeAt(C.length - 1) === 58 ? c.push(C.charCodeAt(0) === 58 ? "center" : "right") : C.charCodeAt(0) === 58 ? c.push("left") : c.push("");
  }
  if (s = jt(e, t).trim(), s.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4)
    return !1;
  l = Qn(s), l.length && l[0] === "" && l.shift(), l.length && l[l.length - 1] === "" && l.pop();
  const d = l.length;
  if (d === 0 || d !== c.length)
    return !1;
  if (u)
    return !0;
  const f = e.parentType;
  e.parentType = "table";
  const p = e.md.block.ruler.getRules("blockquote"), h = e.push("table_open", "table", 1), g = [t, 0];
  h.map = g;
  const m = e.push("thead_open", "thead", 1);
  m.map = [t, t + 1];
  const b = e.push("tr_open", "tr", 1);
  b.map = [t, t + 1];
  for (let x = 0; x < l.length; x++) {
    const C = e.push("th_open", "th", 1);
    c[x] && (C.attrs = [["style", "text-align:" + c[x]]]);
    const v = e.push("inline", "", 0);
    v.content = l[x].trim(), v.children = [], e.push("th_close", "th", -1);
  }
  e.push("tr_close", "tr", -1), e.push("thead_close", "thead", -1);
  let _, y = 0;
  for (r = t + 2; r < n && !(e.sCount[r] < e.blkIndent); r++) {
    let x = !1;
    for (let v = 0, A = p.length; v < A; v++)
      if (p[v](e, r, n, !0)) {
        x = !0;
        break;
      }
    if (x || (s = jt(e, r).trim(), !s) || e.sCount[r] - e.blkIndent >= 4 || (l = Qn(s), l.length && l[0] === "" && l.shift(), l.length && l[l.length - 1] === "" && l.pop(), y += d - l.length, y > Na))
      break;
    if (r === t + 2) {
      const v = e.push("tbody_open", "tbody", 1);
      v.map = _ = [t + 2, 0];
    }
    const C = e.push("tr_open", "tr", 1);
    C.map = [r, r + 1];
    for (let v = 0; v < d; v++) {
      const A = e.push("td_open", "td", 1);
      c[v] && (A.attrs = [["style", "text-align:" + c[v]]]);
      const S = e.push("inline", "", 0);
      S.content = l[v] ? l[v].trim() : "", S.children = [], e.push("td_close", "td", -1);
    }
    e.push("tr_close", "tr", -1);
  }
  return _ && (e.push("tbody_close", "tbody", -1), _[1] = r), e.push("table_close", "table", -1), g[1] = r, e.parentType = f, e.line = r, !0;
}
function Ma(e, t, n) {
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  let u = t + 1, r = u;
  for (; u < n; ) {
    if (e.isEmpty(u)) {
      u++;
      continue;
    }
    if (e.sCount[u] - e.blkIndent >= 4) {
      u++, r = u;
      continue;
    }
    break;
  }
  e.line = r;
  const i = e.push("code_block", "code", 0);
  return i.content = e.getLines(t, r, 4 + e.blkIndent, !1) + `
`, i.map = [t, e.line], !0;
}
function Oa(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || r + 3 > i)
    return !1;
  const a = e.src.charCodeAt(r);
  if (a !== 126 && a !== 96)
    return !1;
  let o = r;
  r = e.skipChars(r, a);
  let s = r - o;
  if (s < 3)
    return !1;
  const l = e.src.slice(o, r), c = e.src.slice(r, i);
  if (a === 96 && c.indexOf(String.fromCharCode(a)) >= 0)
    return !1;
  if (u)
    return !0;
  let d = t, f = !1;
  for (; d++, !(d >= n || (r = o = e.bMarks[d] + e.tShift[d], i = e.eMarks[d], r < i && e.sCount[d] < e.blkIndent)); )
    if (e.src.charCodeAt(r) === a && !(e.sCount[d] - e.blkIndent >= 4) && (r = e.skipChars(r, a), !(r - o < s) && (r = e.skipSpaces(r), !(r < i)))) {
      f = !0;
      break;
    }
  s = e.sCount[t], e.line = d + (f ? 1 : 0);
  const p = e.push("fence", "code", 0);
  return p.info = c, p.content = e.getLines(t + 1, d, s, !0), p.markup = l, p.map = [t, e.line], !0;
}
function Ba(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  const a = e.lineMax;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(r) !== 62)
    return !1;
  if (u)
    return !0;
  const o = [], s = [], l = [], c = [], d = e.md.block.ruler.getRules("blockquote"), f = e.parentType;
  e.parentType = "blockquote";
  let p = !1, h;
  for (h = t; h < n; h++) {
    const y = e.sCount[h] < e.blkIndent;
    if (r = e.bMarks[h] + e.tShift[h], i = e.eMarks[h], r >= i)
      break;
    if (e.src.charCodeAt(r++) === 62 && !y) {
      let C = e.sCount[h] + 1, v, A;
      e.src.charCodeAt(r) === 32 ? (r++, C++, A = !1, v = !0) : e.src.charCodeAt(r) === 9 ? (v = !0, (e.bsCount[h] + C) % 4 === 3 ? (r++, C++, A = !1) : A = !0) : v = !1;
      let S = C;
      for (o.push(e.bMarks[h]), e.bMarks[h] = r; r < i; ) {
        const L = e.src.charCodeAt(r);
        if (T(L))
          L === 9 ? S += 4 - (S + e.bsCount[h] + (A ? 1 : 0)) % 4 : S++;
        else
          break;
        r++;
      }
      p = r >= i, s.push(e.bsCount[h]), e.bsCount[h] = e.sCount[h] + 1 + (v ? 1 : 0), l.push(e.sCount[h]), e.sCount[h] = S - C, c.push(e.tShift[h]), e.tShift[h] = r - e.bMarks[h];
      continue;
    }
    if (p)
      break;
    let x = !1;
    for (let C = 0, v = d.length; C < v; C++)
      if (d[C](e, h, n, !0)) {
        x = !0;
        break;
      }
    if (x) {
      e.lineMax = h, e.blkIndent !== 0 && (o.push(e.bMarks[h]), s.push(e.bsCount[h]), c.push(e.tShift[h]), l.push(e.sCount[h]), e.sCount[h] -= e.blkIndent);
      break;
    }
    o.push(e.bMarks[h]), s.push(e.bsCount[h]), c.push(e.tShift[h]), l.push(e.sCount[h]), e.sCount[h] = -1;
  }
  const g = e.blkIndent;
  e.blkIndent = 0;
  const m = e.push("blockquote_open", "blockquote", 1);
  m.markup = ">";
  const b = [t, 0];
  m.map = b, e.md.block.tokenize(e, t, h);
  const _ = e.push("blockquote_close", "blockquote", -1);
  _.markup = ">", e.lineMax = a, e.parentType = f, b[1] = e.line;
  for (let y = 0; y < c.length; y++)
    e.bMarks[y + t] = o[y], e.tShift[y + t] = c[y], e.sCount[y + t] = l[y], e.bsCount[y + t] = s[y];
  return e.blkIndent = g, !0;
}
function ja(e, t, n, u) {
  const r = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  let i = e.bMarks[t] + e.tShift[t];
  const a = e.src.charCodeAt(i++);
  if (a !== 42 && a !== 45 && a !== 95)
    return !1;
  let o = 1;
  for (; i < r; ) {
    const l = e.src.charCodeAt(i++);
    if (l !== a && !T(l))
      return !1;
    l === a && o++;
  }
  if (o < 3)
    return !1;
  if (u)
    return !0;
  e.line = t + 1;
  const s = e.push("hr", "hr", 0);
  return s.map = [t, e.line], s.markup = Array(o + 1).join(String.fromCharCode(a)), !0;
}
function Xn(e, t) {
  const n = e.eMarks[t];
  let u = e.bMarks[t] + e.tShift[t];
  const r = e.src.charCodeAt(u++);
  if (r !== 42 && r !== 45 && r !== 43)
    return -1;
  if (u < n) {
    const i = e.src.charCodeAt(u);
    if (!T(i))
      return -1;
  }
  return u;
}
function Yn(e, t) {
  const n = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  let r = n;
  if (r + 1 >= u)
    return -1;
  let i = e.src.charCodeAt(r++);
  if (i < 48 || i > 57)
    return -1;
  for (; ; ) {
    if (r >= u)
      return -1;
    if (i = e.src.charCodeAt(r++), i >= 48 && i <= 57) {
      if (r - n >= 10)
        return -1;
      continue;
    }
    if (i === 41 || i === 46)
      break;
    return -1;
  }
  return r < u && (i = e.src.charCodeAt(r), !T(i)) ? -1 : r;
}
function za(e, t) {
  const n = e.level + 2;
  for (let u = t + 2, r = e.tokens.length - 2; u < r; u++)
    e.tokens[u].level === n && e.tokens[u].type === "paragraph_open" && (e.tokens[u + 2].hidden = !0, e.tokens[u].hidden = !0, u += 2);
}
function $a(e, t, n, u) {
  let r, i, a, o, s = t, l = !0;
  if (e.sCount[s] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[s] - e.listIndent >= 4 && e.sCount[s] < e.blkIndent)
    return !1;
  let c = !1;
  u && e.parentType === "paragraph" && e.sCount[s] >= e.blkIndent && (c = !0);
  let d, f, p;
  if ((p = Yn(e, s)) >= 0) {
    if (d = !0, a = e.bMarks[s] + e.tShift[s], f = Number(e.src.slice(a, p - 1)), c && f !== 1) return !1;
  } else if ((p = Xn(e, s)) >= 0)
    d = !1;
  else
    return !1;
  if (c && e.skipSpaces(p) >= e.eMarks[s])
    return !1;
  if (u)
    return !0;
  const h = e.src.charCodeAt(p - 1), g = e.tokens.length;
  d ? (o = e.push("ordered_list_open", "ol", 1), f !== 1 && (o.attrs = [["start", f]])) : o = e.push("bullet_list_open", "ul", 1);
  const m = [s, 0];
  o.map = m, o.markup = String.fromCharCode(h);
  let b = !1;
  const _ = e.md.block.ruler.getRules("list"), y = e.parentType;
  for (e.parentType = "list"; s < n; ) {
    i = p, r = e.eMarks[s];
    const x = e.sCount[s] + p - (e.bMarks[s] + e.tShift[s]);
    let C = x;
    for (; i < r; ) {
      const G = e.src.charCodeAt(i);
      if (G === 9)
        C += 4 - (C + e.bsCount[s]) % 4;
      else if (G === 32)
        C++;
      else
        break;
      i++;
    }
    const v = i;
    let A;
    v >= r ? A = 1 : A = C - x, A > 4 && (A = 1);
    const S = x + A;
    o = e.push("list_item_open", "li", 1), o.markup = String.fromCharCode(h);
    const L = [s, 0];
    o.map = L, d && (o.info = e.src.slice(a, p - 1));
    const M = e.tight, Z = e.tShift[s], P = e.sCount[s], $ = e.listIndent;
    if (e.listIndent = e.blkIndent, e.blkIndent = S, e.tight = !0, e.tShift[s] = v - e.bMarks[s], e.sCount[s] = C, v >= r && e.isEmpty(s + 1) ? e.line = Math.min(e.line + 2, n) : e.md.block.tokenize(e, s, n, !0), (!e.tight || b) && (l = !1), b = e.line - s > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = $, e.tShift[s] = Z, e.sCount[s] = P, e.tight = M, o = e.push("list_item_close", "li", -1), o.markup = String.fromCharCode(h), s = e.line, L[1] = s, s >= n || e.sCount[s] < e.blkIndent || e.sCount[s] - e.blkIndent >= 4)
      break;
    let D = !1;
    for (let G = 0, Ie = _.length; G < Ie; G++)
      if (_[G](e, s, n, !0)) {
        D = !0;
        break;
      }
    if (D)
      break;
    if (d) {
      if (p = Yn(e, s), p < 0)
        break;
      a = e.bMarks[s] + e.tShift[s];
    } else if (p = Xn(e, s), p < 0)
      break;
    if (h !== e.src.charCodeAt(p - 1))
      break;
  }
  return d ? o = e.push("ordered_list_close", "ol", -1) : o = e.push("bullet_list_close", "ul", -1), o.markup = String.fromCharCode(h), m[1] = s, e.line = s, e.parentType = y, l && za(e, g), !0;
}
function qa(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t], a = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(r) !== 91)
    return !1;
  function o(_) {
    const y = e.lineMax;
    if (_ >= y || e.isEmpty(_))
      return null;
    let x = !1;
    if (e.sCount[_] - e.blkIndent > 3 && (x = !0), e.sCount[_] < 0 && (x = !0), !x) {
      const A = e.md.block.ruler.getRules("reference"), S = e.parentType;
      e.parentType = "reference";
      let L = !1;
      for (let M = 0, Z = A.length; M < Z; M++)
        if (A[M](e, _, y, !0)) {
          L = !0;
          break;
        }
      if (e.parentType = S, L)
        return null;
    }
    const C = e.bMarks[_] + e.tShift[_], v = e.eMarks[_];
    return e.src.slice(C, v + 1);
  }
  let s = e.src.slice(r, i + 1);
  i = s.length;
  let l = -1;
  for (r = 1; r < i; r++) {
    const _ = s.charCodeAt(r);
    if (_ === 91)
      return !1;
    if (_ === 93) {
      l = r;
      break;
    } else if (_ === 10) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    } else if (_ === 92 && (r++, r < i && s.charCodeAt(r) === 10)) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    }
  }
  if (l < 0 || s.charCodeAt(l + 1) !== 58)
    return !1;
  for (r = l + 2; r < i; r++) {
    const _ = s.charCodeAt(r);
    if (_ === 10) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    } else if (!T(_)) break;
  }
  const c = e.md.helpers.parseLinkDestination(s, r, i);
  if (!c.ok)
    return !1;
  const d = e.md.normalizeLink(c.str);
  if (!e.md.validateLink(d))
    return !1;
  r = c.pos;
  const f = r, p = a, h = r;
  for (; r < i; r++) {
    const _ = s.charCodeAt(r);
    if (_ === 10) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    } else if (!T(_)) break;
  }
  let g = e.md.helpers.parseLinkTitle(s, r, i);
  for (; g.can_continue; ) {
    const _ = o(a);
    if (_ === null) break;
    s += _, r = i, i = s.length, a++, g = e.md.helpers.parseLinkTitle(s, r, i, g);
  }
  let m;
  for (r < i && h !== r && g.ok ? (m = g.str, r = g.pos) : (m = "", r = f, a = p); r < i; ) {
    const _ = s.charCodeAt(r);
    if (!T(_))
      break;
    r++;
  }
  if (r < i && s.charCodeAt(r) !== 10 && m)
    for (m = "", r = f, a = p; r < i; ) {
      const _ = s.charCodeAt(r);
      if (!T(_))
        break;
      r++;
    }
  if (r < i && s.charCodeAt(r) !== 10)
    return !1;
  const b = St(s.slice(1, l));
  return b ? (u || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[b] > "u" && (e.env.references[b] = { title: m, href: d }), e.line = a), !0) : !1;
}
const Ga = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Ha = "[a-zA-Z_:][a-zA-Z0-9:._-]*", Ua = "[^\"'=<>`\\x00-\\x20]+", Wa = "'[^']*'", Va = '"[^"]*"', Za = "(?:" + Ua + "|" + Wa + "|" + Va + ")", Ja = "(?:\\s+" + Ha + "(?:\\s*=\\s*" + Za + ")?)", Vu = "<[A-Za-z][A-Za-z0-9\\-]*" + Ja + "*\\s*\\/?>", Zu = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", Ka = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", Qa = "<[?][\\s\\S]*?[?]>", Xa = "<![A-Za-z][^>]*>", Ya = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", eo = new RegExp("^(?:" + Vu + "|" + Zu + "|" + Ka + "|" + Qa + "|" + Xa + "|" + Ya + ")"), to = new RegExp("^(?:" + Vu + "|" + Zu + ")"), xe = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + Ga.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(to.source + "\\s*$"), /^$/, !1]
];
function no(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(r) !== 60)
    return !1;
  let a = e.src.slice(r, i), o = 0;
  for (; o < xe.length && !xe[o][0].test(a); o++)
    ;
  if (o === xe.length)
    return !1;
  if (u)
    return xe[o][2];
  let s = t + 1;
  if (!xe[o][1].test(a)) {
    for (; s < n && !(e.sCount[s] < e.blkIndent); s++)
      if (r = e.bMarks[s] + e.tShift[s], i = e.eMarks[s], a = e.src.slice(r, i), xe[o][1].test(a)) {
        a.length !== 0 && s++;
        break;
      }
  }
  e.line = s;
  const l = e.push("html_block", "", 0);
  return l.map = [t, s], l.content = e.getLines(t, s, e.blkIndent, !0), !0;
}
function uo(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  let a = e.src.charCodeAt(r);
  if (a !== 35 || r >= i)
    return !1;
  let o = 1;
  for (a = e.src.charCodeAt(++r); a === 35 && r < i && o <= 6; )
    o++, a = e.src.charCodeAt(++r);
  if (o > 6 || r < i && !T(a))
    return !1;
  if (u)
    return !0;
  i = e.skipSpacesBack(i, r);
  const s = e.skipCharsBack(i, 35, r);
  s > r && T(e.src.charCodeAt(s - 1)) && (i = s), e.line = t + 1;
  const l = e.push("heading_open", "h" + String(o), 1);
  l.markup = "########".slice(0, o), l.map = [t, e.line];
  const c = e.push("inline", "", 0);
  c.content = e.src.slice(r, i).trim(), c.map = [t, e.line], c.children = [];
  const d = e.push("heading_close", "h" + String(o), -1);
  return d.markup = "########".slice(0, o), !0;
}
function ro(e, t, n) {
  const u = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  const r = e.parentType;
  e.parentType = "paragraph";
  let i = 0, a, o = t + 1;
  for (; o < n && !e.isEmpty(o); o++) {
    if (e.sCount[o] - e.blkIndent > 3)
      continue;
    if (e.sCount[o] >= e.blkIndent) {
      let p = e.bMarks[o] + e.tShift[o];
      const h = e.eMarks[o];
      if (p < h && (a = e.src.charCodeAt(p), (a === 45 || a === 61) && (p = e.skipChars(p, a), p = e.skipSpaces(p), p >= h))) {
        i = a === 61 ? 1 : 2;
        break;
      }
    }
    if (e.sCount[o] < 0)
      continue;
    let f = !1;
    for (let p = 0, h = u.length; p < h; p++)
      if (u[p](e, o, n, !0)) {
        f = !0;
        break;
      }
    if (f)
      break;
  }
  if (!i)
    return !1;
  const s = e.getLines(t, o, e.blkIndent, !1).trim();
  e.line = o + 1;
  const l = e.push("heading_open", "h" + String(i), 1);
  l.markup = String.fromCharCode(a), l.map = [t, e.line];
  const c = e.push("inline", "", 0);
  c.content = s, c.map = [t, e.line - 1], c.children = [];
  const d = e.push("heading_close", "h" + String(i), -1);
  return d.markup = String.fromCharCode(a), e.parentType = r, !0;
}
function io(e, t, n) {
  const u = e.md.block.ruler.getRules("paragraph"), r = e.parentType;
  let i = t + 1;
  for (e.parentType = "paragraph"; i < n && !e.isEmpty(i); i++) {
    if (e.sCount[i] - e.blkIndent > 3 || e.sCount[i] < 0)
      continue;
    let l = !1;
    for (let c = 0, d = u.length; c < d; c++)
      if (u[c](e, i, n, !0)) {
        l = !0;
        break;
      }
    if (l)
      break;
  }
  const a = e.getLines(t, i, e.blkIndent, !1).trim();
  e.line = i;
  const o = e.push("paragraph_open", "p", 1);
  o.map = [t, e.line];
  const s = e.push("inline", "", 0);
  return s.content = a, s.map = [t, e.line], s.children = [], e.push("paragraph_close", "p", -1), e.parentType = r, !0;
}
const nt = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", Ia, ["paragraph", "reference"]],
  ["code", Ma],
  ["fence", Oa, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", Ba, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", ja, ["paragraph", "reference", "blockquote", "list"]],
  ["list", $a, ["paragraph", "reference", "blockquote"]],
  ["reference", qa],
  ["html_block", no, ["paragraph", "reference", "blockquote"]],
  ["heading", uo, ["paragraph", "reference", "blockquote"]],
  ["lheading", ro],
  ["paragraph", io]
];
function Dt() {
  this.ruler = new H();
  for (let e = 0; e < nt.length; e++)
    this.ruler.push(nt[e][0], nt[e][1], { alt: (nt[e][2] || []).slice() });
}
Dt.prototype.tokenize = function(e, t, n) {
  const u = this.ruler.getRules(""), r = u.length, i = e.md.options.maxNesting;
  let a = t, o = !1;
  for (; a < n && (e.line = a = e.skipEmptyLines(a), !(a >= n || e.sCount[a] < e.blkIndent)); ) {
    if (e.level >= i) {
      e.line = n;
      break;
    }
    const s = e.line;
    let l = !1;
    for (let c = 0; c < r; c++)
      if (l = u[c](e, a, n, !1), l) {
        if (s >= e.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!l) throw new Error("none of the block rules matched");
    e.tight = !o, e.isEmpty(e.line - 1) && (o = !0), a = e.line, a < n && e.isEmpty(a) && (o = !0, a++, e.line = a);
  }
};
Dt.prototype.parse = function(e, t, n, u) {
  if (!e)
    return;
  const r = new this.State(e, t, n, u);
  this.tokenize(r, r.line, r.lineMax);
};
Dt.prototype.State = oe;
function Ke(e, t, n, u) {
  this.src = e, this.env = n, this.md = t, this.tokens = u, this.tokens_meta = Array(u.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Ke.prototype.pushPending = function() {
  const e = new Y("text", "", 0);
  return e.content = this.pending, e.level = this.pendingLevel, this.tokens.push(e), this.pending = "", e;
};
Ke.prototype.push = function(e, t, n) {
  this.pending && this.pushPending();
  const u = new Y(e, t, n);
  let r = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), u.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], r = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(u), this.tokens_meta.push(r), u;
};
Ke.prototype.scanDelims = function(e, t) {
  const n = this.posMax, u = this.src.charCodeAt(e), r = e > 0 ? this.src.charCodeAt(e - 1) : 32;
  let i = e;
  for (; i < n && this.src.charCodeAt(i) === u; )
    i++;
  const a = i - e, o = i < n ? this.src.charCodeAt(i) : 32, s = qe(r) || $e(String.fromCharCode(r)), l = qe(o) || $e(String.fromCharCode(o)), c = ze(r), d = ze(o), f = !d && (!l || c || s), p = !c && (!s || d || l);
  return { can_open: f && (t || !p || s), can_close: p && (t || !f || l), length: a };
};
Ke.prototype.Token = Y;
function ao(e) {
  switch (e) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function oo(e, t) {
  let n = e.pos;
  for (; n < e.posMax && !ao(e.src.charCodeAt(n)); )
    n++;
  return n === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, n)), e.pos = n, !0);
}
const so = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function lo(e, t) {
  if (!e.md.options.linkify || e.linkLevel > 0) return !1;
  const n = e.pos, u = e.posMax;
  if (n + 3 > u || e.src.charCodeAt(n) !== 58 || e.src.charCodeAt(n + 1) !== 47 || e.src.charCodeAt(n + 2) !== 47) return !1;
  const r = e.pending.match(so);
  if (!r) return !1;
  const i = r[1], a = e.md.linkify.matchAtStart(e.src.slice(n - i.length));
  if (!a) return !1;
  let o = a.url;
  if (o.length <= i.length) return !1;
  o = o.replace(/\*+$/, "");
  const s = e.md.normalizeLink(o);
  if (!e.md.validateLink(s)) return !1;
  if (!t) {
    e.pending = e.pending.slice(0, -i.length);
    const l = e.push("link_open", "a", 1);
    l.attrs = [["href", s]], l.markup = "linkify", l.info = "auto";
    const c = e.push("text", "", 0);
    c.content = e.md.normalizeLinkText(o);
    const d = e.push("link_close", "a", -1);
    d.markup = "linkify", d.info = "auto";
  }
  return e.pos += o.length - i.length, !0;
}
function co(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 10)
    return !1;
  const u = e.pending.length - 1, r = e.posMax;
  if (!t)
    if (u >= 0 && e.pending.charCodeAt(u) === 32)
      if (u >= 1 && e.pending.charCodeAt(u - 1) === 32) {
        let i = u - 1;
        for (; i >= 1 && e.pending.charCodeAt(i - 1) === 32; ) i--;
        e.pending = e.pending.slice(0, i), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (n++; n < r && T(e.src.charCodeAt(n)); )
    n++;
  return e.pos = n, !0;
}
const Sn = [];
for (let e = 0; e < 256; e++)
  Sn.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e) {
  Sn[e.charCodeAt(0)] = 1;
});
function fo(e, t) {
  let n = e.pos;
  const u = e.posMax;
  if (e.src.charCodeAt(n) !== 92 || (n++, n >= u)) return !1;
  let r = e.src.charCodeAt(n);
  if (r === 10) {
    for (t || e.push("hardbreak", "br", 0), n++; n < u && (r = e.src.charCodeAt(n), !!T(r)); )
      n++;
    return e.pos = n, !0;
  }
  let i = e.src[n];
  if (r >= 55296 && r <= 56319 && n + 1 < u) {
    const o = e.src.charCodeAt(n + 1);
    o >= 56320 && o <= 57343 && (i += e.src[n + 1], n++);
  }
  const a = "\\" + i;
  if (!t) {
    const o = e.push("text_special", "", 0);
    r < 256 && Sn[r] !== 0 ? o.content = i : o.content = a, o.markup = a, o.info = "escape";
  }
  return e.pos = n + 1, !0;
}
function ho(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 96)
    return !1;
  const r = n;
  n++;
  const i = e.posMax;
  for (; n < i && e.src.charCodeAt(n) === 96; )
    n++;
  const a = e.src.slice(r, n), o = a.length;
  if (e.backticksScanned && (e.backticks[o] || 0) <= r)
    return t || (e.pending += a), e.pos += o, !0;
  let s = n, l;
  for (; (l = e.src.indexOf("`", s)) !== -1; ) {
    for (s = l + 1; s < i && e.src.charCodeAt(s) === 96; )
      s++;
    const c = s - l;
    if (c === o) {
      if (!t) {
        const d = e.push("code_inline", "code", 0);
        d.markup = a, d.content = e.src.slice(n, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return e.pos = s, !0;
    }
    e.backticks[c] = l;
  }
  return e.backticksScanned = !0, t || (e.pending += a), e.pos += o, !0;
}
function po(e, t) {
  const n = e.pos, u = e.src.charCodeAt(n);
  if (t || u !== 126)
    return !1;
  const r = e.scanDelims(e.pos, !0);
  let i = r.length;
  const a = String.fromCharCode(u);
  if (i < 2)
    return !1;
  let o;
  i % 2 && (o = e.push("text", "", 0), o.content = a, i--);
  for (let s = 0; s < i; s += 2)
    o = e.push("text", "", 0), o.content = a + a, e.delimiters.push({
      marker: u,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
}
function eu(e, t) {
  let n;
  const u = [], r = t.length;
  for (let i = 0; i < r; i++) {
    const a = t[i];
    if (a.marker !== 126 || a.end === -1)
      continue;
    const o = t[a.end];
    n = e.tokens[a.token], n.type = "s_open", n.tag = "s", n.nesting = 1, n.markup = "~~", n.content = "", n = e.tokens[o.token], n.type = "s_close", n.tag = "s", n.nesting = -1, n.markup = "~~", n.content = "", e.tokens[o.token - 1].type === "text" && e.tokens[o.token - 1].content === "~" && u.push(o.token - 1);
  }
  for (; u.length; ) {
    const i = u.pop();
    let a = i + 1;
    for (; a < e.tokens.length && e.tokens[a].type === "s_close"; )
      a++;
    a--, i !== a && (n = e.tokens[a], e.tokens[a] = e.tokens[i], e.tokens[i] = n);
  }
}
function mo(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  eu(e, e.delimiters);
  for (let u = 0; u < n; u++)
    t[u] && t[u].delimiters && eu(e, t[u].delimiters);
}
const Ju = {
  tokenize: po,
  postProcess: mo
};
function go(e, t) {
  const n = e.pos, u = e.src.charCodeAt(n);
  if (t || u !== 95 && u !== 42)
    return !1;
  const r = e.scanDelims(e.pos, u === 42);
  for (let i = 0; i < r.length; i++) {
    const a = e.push("text", "", 0);
    a.content = String.fromCharCode(u), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: u,
      // Total length of these series of delimiters.
      //
      length: r.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: r.can_open,
      close: r.can_close
    });
  }
  return e.pos += r.length, !0;
}
function tu(e, t) {
  const n = t.length;
  for (let u = n - 1; u >= 0; u--) {
    const r = t[u];
    if (r.marker !== 95 && r.marker !== 42 || r.end === -1)
      continue;
    const i = t[r.end], a = u > 0 && t[u - 1].end === r.end + 1 && // check that first two markers match and adjacent
    t[u - 1].marker === r.marker && t[u - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    t[r.end + 1].token === i.token + 1, o = String.fromCharCode(r.marker), s = e.tokens[r.token];
    s.type = a ? "strong_open" : "em_open", s.tag = a ? "strong" : "em", s.nesting = 1, s.markup = a ? o + o : o, s.content = "";
    const l = e.tokens[i.token];
    l.type = a ? "strong_close" : "em_close", l.tag = a ? "strong" : "em", l.nesting = -1, l.markup = a ? o + o : o, l.content = "", a && (e.tokens[t[u - 1].token].content = "", e.tokens[t[r.end + 1].token].content = "", u--);
  }
}
function _o(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  tu(e, e.delimiters);
  for (let u = 0; u < n; u++)
    t[u] && t[u].delimiters && tu(e, t[u].delimiters);
}
const Ku = {
  tokenize: go,
  postProcess: _o
};
function bo(e, t) {
  let n, u, r, i, a = "", o = "", s = e.pos, l = !0;
  if (e.src.charCodeAt(e.pos) !== 91)
    return !1;
  const c = e.pos, d = e.posMax, f = e.pos + 1, p = e.md.helpers.parseLinkLabel(e, e.pos, !0);
  if (p < 0)
    return !1;
  let h = p + 1;
  if (h < d && e.src.charCodeAt(h) === 40) {
    for (l = !1, h++; h < d && (n = e.src.charCodeAt(h), !(!T(n) && n !== 10)); h++)
      ;
    if (h >= d)
      return !1;
    if (s = h, r = e.md.helpers.parseLinkDestination(e.src, h, e.posMax), r.ok) {
      for (a = e.md.normalizeLink(r.str), e.md.validateLink(a) ? h = r.pos : a = "", s = h; h < d && (n = e.src.charCodeAt(h), !(!T(n) && n !== 10)); h++)
        ;
      if (r = e.md.helpers.parseLinkTitle(e.src, h, e.posMax), h < d && s !== h && r.ok)
        for (o = r.str, h = r.pos; h < d && (n = e.src.charCodeAt(h), !(!T(n) && n !== 10)); h++)
          ;
    }
    (h >= d || e.src.charCodeAt(h) !== 41) && (l = !0), h++;
  }
  if (l) {
    if (typeof e.env.references > "u")
      return !1;
    if (h < d && e.src.charCodeAt(h) === 91 ? (s = h + 1, h = e.md.helpers.parseLinkLabel(e, h), h >= 0 ? u = e.src.slice(s, h++) : h = p + 1) : h = p + 1, u || (u = e.src.slice(f, p)), i = e.env.references[St(u)], !i)
      return e.pos = c, !1;
    a = i.href, o = i.title;
  }
  if (!t) {
    e.pos = f, e.posMax = p;
    const g = e.push("link_open", "a", 1), m = [["href", a]];
    g.attrs = m, o && m.push(["title", o]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, e.push("link_close", "a", -1);
  }
  return e.pos = h, e.posMax = d, !0;
}
function yo(e, t) {
  let n, u, r, i, a, o, s, l, c = "";
  const d = e.pos, f = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91)
    return !1;
  const p = e.pos + 2, h = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1);
  if (h < 0)
    return !1;
  if (i = h + 1, i < f && e.src.charCodeAt(i) === 40) {
    for (i++; i < f && (n = e.src.charCodeAt(i), !(!T(n) && n !== 10)); i++)
      ;
    if (i >= f)
      return !1;
    for (l = i, o = e.md.helpers.parseLinkDestination(e.src, i, e.posMax), o.ok && (c = e.md.normalizeLink(o.str), e.md.validateLink(c) ? i = o.pos : c = ""), l = i; i < f && (n = e.src.charCodeAt(i), !(!T(n) && n !== 10)); i++)
      ;
    if (o = e.md.helpers.parseLinkTitle(e.src, i, e.posMax), i < f && l !== i && o.ok)
      for (s = o.str, i = o.pos; i < f && (n = e.src.charCodeAt(i), !(!T(n) && n !== 10)); i++)
        ;
    else
      s = "";
    if (i >= f || e.src.charCodeAt(i) !== 41)
      return e.pos = d, !1;
    i++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (i < f && e.src.charCodeAt(i) === 91 ? (l = i + 1, i = e.md.helpers.parseLinkLabel(e, i), i >= 0 ? r = e.src.slice(l, i++) : i = h + 1) : i = h + 1, r || (r = e.src.slice(p, h)), a = e.env.references[St(r)], !a)
      return e.pos = d, !1;
    c = a.href, s = a.title;
  }
  if (!t) {
    u = e.src.slice(p, h);
    const g = [];
    e.md.inline.parse(
      u,
      e.md,
      e.env,
      g
    );
    const m = e.push("image", "img", 0), b = [["src", c], ["alt", ""]];
    m.attrs = b, m.children = g, m.content = u, s && b.push(["title", s]);
  }
  return e.pos = i, e.posMax = f, !0;
}
const ko = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, xo = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function wo(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 60)
    return !1;
  const u = e.pos, r = e.posMax;
  for (; ; ) {
    if (++n >= r) return !1;
    const a = e.src.charCodeAt(n);
    if (a === 60) return !1;
    if (a === 62) break;
  }
  const i = e.src.slice(u + 1, n);
  if (xo.test(i)) {
    const a = e.md.normalizeLink(i);
    if (!e.md.validateLink(a))
      return !1;
    if (!t) {
      const o = e.push("link_open", "a", 1);
      o.attrs = [["href", a]], o.markup = "autolink", o.info = "auto";
      const s = e.push("text", "", 0);
      s.content = e.md.normalizeLinkText(i);
      const l = e.push("link_close", "a", -1);
      l.markup = "autolink", l.info = "auto";
    }
    return e.pos += i.length + 2, !0;
  }
  if (ko.test(i)) {
    const a = e.md.normalizeLink("mailto:" + i);
    if (!e.md.validateLink(a))
      return !1;
    if (!t) {
      const o = e.push("link_open", "a", 1);
      o.attrs = [["href", a]], o.markup = "autolink", o.info = "auto";
      const s = e.push("text", "", 0);
      s.content = e.md.normalizeLinkText(i);
      const l = e.push("link_close", "a", -1);
      l.markup = "autolink", l.info = "auto";
    }
    return e.pos += i.length + 2, !0;
  }
  return !1;
}
function Co(e) {
  return /^<a[>\s]/i.test(e);
}
function vo(e) {
  return /^<\/a\s*>/i.test(e);
}
function Ao(e) {
  const t = e | 32;
  return t >= 97 && t <= 122;
}
function Eo(e, t) {
  if (!e.md.options.html)
    return !1;
  const n = e.posMax, u = e.pos;
  if (e.src.charCodeAt(u) !== 60 || u + 2 >= n)
    return !1;
  const r = e.src.charCodeAt(u + 1);
  if (r !== 33 && r !== 63 && r !== 47 && !Ao(r))
    return !1;
  const i = e.src.slice(u).match(eo);
  if (!i)
    return !1;
  if (!t) {
    const a = e.push("html_inline", "", 0);
    a.content = i[0], Co(a.content) && e.linkLevel++, vo(a.content) && e.linkLevel--;
  }
  return e.pos += i[0].length, !0;
}
const So = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, Do = /^&([a-z][a-z0-9]{1,31});/i;
function Fo(e, t) {
  const n = e.pos, u = e.posMax;
  if (e.src.charCodeAt(n) !== 38 || n + 1 >= u) return !1;
  if (e.src.charCodeAt(n + 1) === 35) {
    const i = e.src.slice(n).match(So);
    if (i) {
      if (!t) {
        const a = i[1][0].toLowerCase() === "x" ? parseInt(i[1].slice(1), 16) : parseInt(i[1], 10), o = e.push("text_special", "", 0);
        o.content = An(a) ? dt(a) : dt(65533), o.markup = i[0], o.info = "entity";
      }
      return e.pos += i[0].length, !0;
    }
  } else {
    const i = e.src.slice(n).match(Do);
    if (i) {
      const a = qu(i[0]);
      if (a !== i[0]) {
        if (!t) {
          const o = e.push("text_special", "", 0);
          o.content = a, o.markup = i[0], o.info = "entity";
        }
        return e.pos += i[0].length, !0;
      }
    }
  }
  return !1;
}
function nu(e) {
  const t = {}, n = e.length;
  if (!n) return;
  let u = 0, r = -2;
  const i = [];
  for (let a = 0; a < n; a++) {
    const o = e[a];
    if (i.push(0), (e[u].marker !== o.marker || r !== o.token - 1) && (u = a), r = o.token, o.length = o.length || 0, !o.close) continue;
    t.hasOwnProperty(o.marker) || (t[o.marker] = [-1, -1, -1, -1, -1, -1]);
    const s = t[o.marker][(o.open ? 3 : 0) + o.length % 3];
    let l = u - i[u] - 1, c = l;
    for (; l > s; l -= i[l] + 1) {
      const d = e[l];
      if (d.marker === o.marker && d.open && d.end < 0) {
        let f = !1;
        if ((d.close || o.open) && (d.length + o.length) % 3 === 0 && (d.length % 3 !== 0 || o.length % 3 !== 0) && (f = !0), !f) {
          const p = l > 0 && !e[l - 1].open ? i[l - 1] + 1 : 0;
          i[a] = a - l + p, i[l] = p, o.open = !1, d.end = a, d.close = !1, c = -1, r = -2;
          break;
        }
      }
    }
    c !== -1 && (t[o.marker][(o.open ? 3 : 0) + (o.length || 0) % 3] = c);
  }
}
function To(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  nu(e.delimiters);
  for (let u = 0; u < n; u++)
    t[u] && t[u].delimiters && nu(t[u].delimiters);
}
function Ro(e) {
  let t, n, u = 0;
  const r = e.tokens, i = e.tokens.length;
  for (t = n = 0; t < i; t++)
    r[t].nesting < 0 && u--, r[t].level = u, r[t].nesting > 0 && u++, r[t].type === "text" && t + 1 < i && r[t + 1].type === "text" ? r[t + 1].content = r[t].content + r[t + 1].content : (t !== n && (r[n] = r[t]), n++);
  t !== n && (r.length = n);
}
const zt = [
  ["text", oo],
  ["linkify", lo],
  ["newline", co],
  ["escape", fo],
  ["backticks", ho],
  ["strikethrough", Ju.tokenize],
  ["emphasis", Ku.tokenize],
  ["link", bo],
  ["image", yo],
  ["autolink", wo],
  ["html_inline", Eo],
  ["entity", Fo]
], $t = [
  ["balance_pairs", To],
  ["strikethrough", Ju.postProcess],
  ["emphasis", Ku.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", Ro]
];
function Qe() {
  this.ruler = new H();
  for (let e = 0; e < zt.length; e++)
    this.ruler.push(zt[e][0], zt[e][1]);
  this.ruler2 = new H();
  for (let e = 0; e < $t.length; e++)
    this.ruler2.push($t[e][0], $t[e][1]);
}
Qe.prototype.skipToken = function(e) {
  const t = e.pos, n = this.ruler.getRules(""), u = n.length, r = e.md.options.maxNesting, i = e.cache;
  if (typeof i[t] < "u") {
    e.pos = i[t];
    return;
  }
  let a = !1;
  if (e.level < r) {
    for (let o = 0; o < u; o++)
      if (e.level++, a = n[o](e, !0), e.level--, a) {
        if (t >= e.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    e.pos = e.posMax;
  a || e.pos++, i[t] = e.pos;
};
Qe.prototype.tokenize = function(e) {
  const t = this.ruler.getRules(""), n = t.length, u = e.posMax, r = e.md.options.maxNesting;
  for (; e.pos < u; ) {
    const i = e.pos;
    let a = !1;
    if (e.level < r) {
      for (let o = 0; o < n; o++)
        if (a = t[o](e, !1), a) {
          if (i >= e.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (a) {
      if (e.pos >= u)
        break;
      continue;
    }
    e.pending += e.src[e.pos++];
  }
  e.pending && e.pushPending();
};
Qe.prototype.parse = function(e, t, n, u) {
  const r = new this.State(e, t, n, u);
  this.tokenize(r);
  const i = this.ruler2.getRules(""), a = i.length;
  for (let o = 0; o < a; o++)
    i[o](r);
};
Qe.prototype.State = Ke;
function Lo(e) {
  const t = {};
  e = e || {}, t.src_Any = Ou.source, t.src_Cc = Bu.source, t.src_Z = zu.source, t.src_P = Cn.source, t.src_ZPCc = [t.src_Z, t.src_P, t.src_Cc].join("|"), t.src_ZCc = [t.src_Z, t.src_Cc].join("|");
  const n = "[><｜]";
  return t.src_pseudo_letter = "(?:(?!" + n + "|" + t.src_ZPCc + ")" + t.src_Any + ")", t.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", t.src_auth = "(?:(?:(?!" + t.src_ZCc + "|[@/\\[\\]()]).)+@)?", t.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", t.src_host_terminator = "(?=$|" + n + "|" + t.src_ZPCc + ")(?!" + (e["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + t.src_ZPCc + "))", t.src_path = "(?:[/?#](?:(?!" + t.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + t.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + t.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + t.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + t.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + t.src_ZCc + "|[']).)+\\'|\\'(?=" + t.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + t.src_ZCc + "|[.]|$)|" + (e["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + t.src_ZCc + "|$)|;(?!" + t.src_ZCc + "|$)|\\!+(?!" + t.src_ZCc + "|[!]|$)|\\?(?!" + t.src_ZCc + "|[?]|$))+|\\/)?", t.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', t.src_xn = "xn--[a-z0-9\\-]{1,59}", t.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + t.src_xn + "|" + t.src_pseudo_letter + "{1,63})", t.src_domain = "(?:" + t.src_xn + "|(?:" + t.src_pseudo_letter + ")|(?:" + t.src_pseudo_letter + "(?:-|" + t.src_pseudo_letter + "){0,61}" + t.src_pseudo_letter + "))", t.src_host = "(?:(?:(?:(?:" + t.src_domain + ")\\.)*" + t.src_domain + "))", t.tpl_host_fuzzy = "(?:" + t.src_ip4 + "|(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%)))", t.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%))", t.src_host_strict = t.src_host + t.src_host_terminator, t.tpl_host_fuzzy_strict = t.tpl_host_fuzzy + t.src_host_terminator, t.src_host_port_strict = t.src_host + t.src_port + t.src_host_terminator, t.tpl_host_port_fuzzy_strict = t.tpl_host_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_port_no_ip_fuzzy_strict = t.tpl_host_no_ip_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + t.src_ZPCc + "|>|$))", t.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + t.src_ZCc + ")(" + t.src_email_name + "@" + t.tpl_host_fuzzy_strict + ")", t.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + t.src_ZPCc + "))((?![$+<=>^`|｜])" + t.tpl_host_port_fuzzy_strict + t.src_path + ")", t.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + t.src_ZPCc + "))((?![$+<=>^`|｜])" + t.tpl_host_port_no_ip_fuzzy_strict + t.src_path + ")", t;
}
function an(e) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    n && Object.keys(n).forEach(function(u) {
      e[u] = n[u];
    });
  }), e;
}
function Ft(e) {
  return Object.prototype.toString.call(e);
}
function Po(e) {
  return Ft(e) === "[object String]";
}
function No(e) {
  return Ft(e) === "[object Object]";
}
function Io(e) {
  return Ft(e) === "[object RegExp]";
}
function uu(e) {
  return Ft(e) === "[object Function]";
}
function Mo(e) {
  return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const Qu = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function Oo(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t || Qu.hasOwnProperty(n);
  }, !1);
}
const Bo = {
  "http:": {
    validate: function(e, t, n) {
      const u = e.slice(t);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(u) ? u.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(e, t, n) {
      const u = e.slice(t);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(u) ? t >= 3 && e[t - 3] === ":" || t >= 3 && e[t - 3] === "/" ? 0 : u.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(e, t, n) {
      const u = e.slice(t);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(u) ? u.match(n.re.mailto)[0].length : 0;
    }
  }
}, jo = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", zo = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function $o(e) {
  e.__index__ = -1, e.__text_cache__ = "";
}
function qo(e) {
  return function(t, n) {
    const u = t.slice(n);
    return e.test(u) ? u.match(e)[0].length : 0;
  };
}
function ru() {
  return function(e, t) {
    t.normalize(e);
  };
}
function ft(e) {
  const t = e.re = Lo(e.__opts__), n = e.__tlds__.slice();
  e.onCompile(), e.__tlds_replaced__ || n.push(jo), n.push(t.src_xn), t.src_tlds = n.join("|");
  function u(o) {
    return o.replace("%TLDS%", t.src_tlds);
  }
  t.email_fuzzy = RegExp(u(t.tpl_email_fuzzy), "i"), t.link_fuzzy = RegExp(u(t.tpl_link_fuzzy), "i"), t.link_no_ip_fuzzy = RegExp(u(t.tpl_link_no_ip_fuzzy), "i"), t.host_fuzzy_test = RegExp(u(t.tpl_host_fuzzy_test), "i");
  const r = [];
  e.__compiled__ = {};
  function i(o, s) {
    throw new Error('(LinkifyIt) Invalid schema "' + o + '": ' + s);
  }
  Object.keys(e.__schemas__).forEach(function(o) {
    const s = e.__schemas__[o];
    if (s === null)
      return;
    const l = { validate: null, link: null };
    if (e.__compiled__[o] = l, No(s)) {
      Io(s.validate) ? l.validate = qo(s.validate) : uu(s.validate) ? l.validate = s.validate : i(o, s), uu(s.normalize) ? l.normalize = s.normalize : s.normalize ? i(o, s) : l.normalize = ru();
      return;
    }
    if (Po(s)) {
      r.push(o);
      return;
    }
    i(o, s);
  }), r.forEach(function(o) {
    e.__compiled__[e.__schemas__[o]] && (e.__compiled__[o].validate = e.__compiled__[e.__schemas__[o]].validate, e.__compiled__[o].normalize = e.__compiled__[e.__schemas__[o]].normalize);
  }), e.__compiled__[""] = { validate: null, normalize: ru() };
  const a = Object.keys(e.__compiled__).filter(function(o) {
    return o.length > 0 && e.__compiled__[o];
  }).map(Mo).join("|");
  e.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + t.src_ZPCc + "))(" + a + ")", "i"), e.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + t.src_ZPCc + "))(" + a + ")", "ig"), e.re.schema_at_start = RegExp("^" + e.re.schema_search.source, "i"), e.re.pretest = RegExp(
    "(" + e.re.schema_test.source + ")|(" + e.re.host_fuzzy_test.source + ")|@",
    "i"
  ), $o(e);
}
function Go(e, t) {
  const n = e.__index__, u = e.__last_index__, r = e.__text_cache__.slice(n, u);
  this.schema = e.__schema__.toLowerCase(), this.index = n + t, this.lastIndex = u + t, this.raw = r, this.text = r, this.url = r;
}
function on(e, t) {
  const n = new Go(e, t);
  return e.__compiled__[n.schema].normalize(n, e), n;
}
function V(e, t) {
  if (!(this instanceof V))
    return new V(e, t);
  t || Oo(e) && (t = e, e = {}), this.__opts__ = an({}, Qu, t), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = an({}, Bo, e), this.__compiled__ = {}, this.__tlds__ = zo, this.__tlds_replaced__ = !1, this.re = {}, ft(this);
}
V.prototype.add = function(t, n) {
  return this.__schemas__[t] = n, ft(this), this;
};
V.prototype.set = function(t) {
  return this.__opts__ = an(this.__opts__, t), this;
};
V.prototype.test = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length)
    return !1;
  let n, u, r, i, a, o, s, l, c;
  if (this.re.schema_test.test(t)) {
    for (s = this.re.schema_search, s.lastIndex = 0; (n = s.exec(t)) !== null; )
      if (i = this.testSchemaAt(t, n[2], s.lastIndex), i) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + i;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = t.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (u = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (a = u.index + u[1].length, (this.__index__ < 0 || a < this.__index__) && (this.__schema__ = "", this.__index__ = a, this.__last_index__ = u.index + u[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (c = t.indexOf("@"), c >= 0 && (r = t.match(this.re.email_fuzzy)) !== null && (a = r.index + r[1].length, o = r.index + r[0].length, (this.__index__ < 0 || a < this.__index__ || a === this.__index__ && o > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = a, this.__last_index__ = o))), this.__index__ >= 0;
};
V.prototype.pretest = function(t) {
  return this.re.pretest.test(t);
};
V.prototype.testSchemaAt = function(t, n, u) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(t, u, this) : 0;
};
V.prototype.match = function(t) {
  const n = [];
  let u = 0;
  this.__index__ >= 0 && this.__text_cache__ === t && (n.push(on(this, u)), u = this.__last_index__);
  let r = u ? t.slice(u) : t;
  for (; this.test(r); )
    n.push(on(this, u)), r = r.slice(this.__last_index__), u += this.__last_index__;
  return n.length ? n : null;
};
V.prototype.matchAtStart = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return null;
  const n = this.re.schema_at_start.exec(t);
  if (!n) return null;
  const u = this.testSchemaAt(t, n[2], n[0].length);
  return u ? (this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + u, on(this, 0)) : null;
};
V.prototype.tlds = function(t, n) {
  return t = Array.isArray(t) ? t : [t], n ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(u, r, i) {
    return u !== i[r - 1];
  }).reverse(), ft(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, ft(this), this);
};
V.prototype.normalize = function(t) {
  t.schema || (t.url = "http://" + t.url), t.schema === "mailto:" && !/^mailto:/i.test(t.url) && (t.url = "mailto:" + t.url);
};
V.prototype.onCompile = function() {
};
const Ae = 2147483647, re = 36, Dn = 1, Ge = 26, Ho = 38, Uo = 700, Xu = 72, Yu = 128, er = "-", Wo = /^xn--/, Vo = /[^\0-\x7F]/, Zo = /[\x2E\u3002\uFF0E\uFF61]/g, Jo = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, qt = re - Dn, ie = Math.floor, Gt = String.fromCharCode;
function fe(e) {
  throw new RangeError(Jo[e]);
}
function Ko(e, t) {
  const n = [];
  let u = e.length;
  for (; u--; )
    n[u] = t(e[u]);
  return n;
}
function tr(e, t) {
  const n = e.split("@");
  let u = "";
  n.length > 1 && (u = n[0] + "@", e = n[1]), e = e.replace(Zo, ".");
  const r = e.split("."), i = Ko(r, t).join(".");
  return u + i;
}
function nr(e) {
  const t = [];
  let n = 0;
  const u = e.length;
  for (; n < u; ) {
    const r = e.charCodeAt(n++);
    if (r >= 55296 && r <= 56319 && n < u) {
      const i = e.charCodeAt(n++);
      (i & 64512) == 56320 ? t.push(((r & 1023) << 10) + (i & 1023) + 65536) : (t.push(r), n--);
    } else
      t.push(r);
  }
  return t;
}
const Qo = (e) => String.fromCodePoint(...e), Xo = function(e) {
  return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : re;
}, iu = function(e, t) {
  return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
}, ur = function(e, t, n) {
  let u = 0;
  for (e = n ? ie(e / Uo) : e >> 1, e += ie(e / t); e > qt * Ge >> 1; u += re)
    e = ie(e / qt);
  return ie(u + (qt + 1) * e / (e + Ho));
}, rr = function(e) {
  const t = [], n = e.length;
  let u = 0, r = Yu, i = Xu, a = e.lastIndexOf(er);
  a < 0 && (a = 0);
  for (let o = 0; o < a; ++o)
    e.charCodeAt(o) >= 128 && fe("not-basic"), t.push(e.charCodeAt(o));
  for (let o = a > 0 ? a + 1 : 0; o < n; ) {
    const s = u;
    for (let c = 1, d = re; ; d += re) {
      o >= n && fe("invalid-input");
      const f = Xo(e.charCodeAt(o++));
      f >= re && fe("invalid-input"), f > ie((Ae - u) / c) && fe("overflow"), u += f * c;
      const p = d <= i ? Dn : d >= i + Ge ? Ge : d - i;
      if (f < p)
        break;
      const h = re - p;
      c > ie(Ae / h) && fe("overflow"), c *= h;
    }
    const l = t.length + 1;
    i = ur(u - s, l, s == 0), ie(u / l) > Ae - r && fe("overflow"), r += ie(u / l), u %= l, t.splice(u++, 0, r);
  }
  return String.fromCodePoint(...t);
}, ir = function(e) {
  const t = [];
  e = nr(e);
  const n = e.length;
  let u = Yu, r = 0, i = Xu;
  for (const s of e)
    s < 128 && t.push(Gt(s));
  const a = t.length;
  let o = a;
  for (a && t.push(er); o < n; ) {
    let s = Ae;
    for (const c of e)
      c >= u && c < s && (s = c);
    const l = o + 1;
    s - u > ie((Ae - r) / l) && fe("overflow"), r += (s - u) * l, u = s;
    for (const c of e)
      if (c < u && ++r > Ae && fe("overflow"), c === u) {
        let d = r;
        for (let f = re; ; f += re) {
          const p = f <= i ? Dn : f >= i + Ge ? Ge : f - i;
          if (d < p)
            break;
          const h = d - p, g = re - p;
          t.push(
            Gt(iu(p + h % g, 0))
          ), d = ie(h / g);
        }
        t.push(Gt(iu(d, 0))), i = ur(r, l, o === a), r = 0, ++o;
      }
    ++r, ++u;
  }
  return t.join("");
}, Yo = function(e) {
  return tr(e, function(t) {
    return Wo.test(t) ? rr(t.slice(4).toLowerCase()) : t;
  });
}, es = function(e) {
  return tr(e, function(t) {
    return Vo.test(t) ? "xn--" + ir(t) : t;
  });
}, ar = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: nr,
    encode: Qo
  },
  decode: rr,
  encode: ir,
  toASCII: es,
  toUnicode: Yo
}, ts = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, ns = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, us = {
  options: {
    // Enable HTML tags in source
    html: !0,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !0,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, rs = {
  default: ts,
  zero: ns,
  commonmark: us
}, is = /^(vbscript|javascript|file|data):/, as = /^data:image\/(gif|png|jpeg|webp);/;
function os(e) {
  const t = e.trim().toLowerCase();
  return is.test(t) ? as.test(t) : !0;
}
const or = ["http:", "https:", "mailto:"];
function ss(e) {
  const t = wn(e, !0);
  if (t.hostname && (!t.protocol || or.indexOf(t.protocol) >= 0))
    try {
      t.hostname = ar.toASCII(t.hostname);
    } catch {
    }
  return Je(xn(t));
}
function ls(e) {
  const t = wn(e, !0);
  if (t.hostname && (!t.protocol || or.indexOf(t.protocol) >= 0))
    try {
      t.hostname = ar.toUnicode(t.hostname);
    } catch {
    }
  return De(xn(t), De.defaultChars + "%");
}
function X(e, t) {
  if (!(this instanceof X))
    return new X(e, t);
  t || vn(e) || (t = e || {}, e = "default"), this.inline = new Qe(), this.block = new Dt(), this.core = new En(), this.renderer = new Le(), this.linkify = new V(), this.validateLink = os, this.normalizeLink = ss, this.normalizeLinkText = ls, this.utils = ca, this.helpers = Et({}, pa), this.options = {}, this.configure(e), t && this.set(t);
}
X.prototype.set = function(e) {
  return Et(this.options, e), this;
};
X.prototype.configure = function(e) {
  const t = this;
  if (vn(e)) {
    const n = e;
    if (e = rs[n], !e)
      throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  }
  if (!e)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return e.options && t.set(e.options), e.components && Object.keys(e.components).forEach(function(n) {
    e.components[n].rules && t[n].ruler.enableOnly(e.components[n].rules), e.components[n].rules2 && t[n].ruler2.enableOnly(e.components[n].rules2);
  }), this;
};
X.prototype.enable = function(e, t) {
  let n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(r) {
    n = n.concat(this[r].ruler.enable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(e, !0));
  const u = e.filter(function(r) {
    return n.indexOf(r) < 0;
  });
  if (u.length && !t)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + u);
  return this;
};
X.prototype.disable = function(e, t) {
  let n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(r) {
    n = n.concat(this[r].ruler.disable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(e, !0));
  const u = e.filter(function(r) {
    return n.indexOf(r) < 0;
  });
  if (u.length && !t)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + u);
  return this;
};
X.prototype.use = function(e) {
  const t = [this].concat(Array.prototype.slice.call(arguments, 1));
  return e.apply(e, t), this;
};
X.prototype.parse = function(e, t) {
  if (typeof e != "string")
    throw new Error("Input data should be a String");
  const n = new this.core.State(e, this, t);
  return this.core.process(n), n.tokens;
};
X.prototype.render = function(e, t) {
  return t = t || {}, this.renderer.render(this.parse(e, t), this.options, t);
};
X.prototype.parseInline = function(e, t) {
  const n = new this.core.State(e, this, t);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
X.prototype.renderInline = function(e, t) {
  return t = t || {}, this.renderer.render(this.parseInline(e, t), this.options, t);
};
var au = !1, Te = { false: "push", true: "unshift", after: "push", before: "unshift" }, ht = { isPermalinkSymbol: !0 };
function sn(e, t, n, u) {
  var r;
  if (!au) {
    var i = "Using deprecated markdown-it-anchor permalink option, see https://github.com/valeriangalliat/markdown-it-anchor#permalinks";
    typeof process == "object" && process && process.emitWarning ? process.emitWarning(i) : console.warn(i), au = !0;
  }
  var a = [Object.assign(new n.Token("link_open", "a", 1), { attrs: [].concat(t.permalinkClass ? [["class", t.permalinkClass]] : [], [["href", t.permalinkHref(e, n)]], Object.entries(t.permalinkAttrs(e, n))) }), Object.assign(new n.Token("html_block", "", 0), { content: t.permalinkSymbol, meta: ht }), new n.Token("link_close", "a", -1)];
  t.permalinkSpace && n.tokens[u + 1].children[Te[t.permalinkBefore]](Object.assign(new n.Token("text", "", 0), { content: " " })), (r = n.tokens[u + 1].children)[Te[t.permalinkBefore]].apply(r, a);
}
function sr(e) {
  return "#" + e;
}
function lr(e) {
  return {};
}
var cs = { class: "header-anchor", symbol: "#", renderHref: sr, renderAttrs: lr };
function Xe(e) {
  function t(n) {
    return n = Object.assign({}, t.defaults, n), function(u, r, i, a) {
      return e(u, n, r, i, a);
    };
  }
  return t.defaults = Object.assign({}, cs), t.renderPermalinkImpl = e, t;
}
function Fn(e) {
  var t = [], n = e.filter(function(u) {
    if (u[0] !== "class") return !0;
    t.push(u[1]);
  });
  return t.length > 0 && n.unshift(["class", t.join(" ")]), n;
}
var Tt = Xe(function(e, t, n, u, r) {
  var i, a = [Object.assign(new u.Token("link_open", "a", 1), { attrs: Fn([].concat(t.class ? [["class", t.class]] : [], [["href", t.renderHref(e, u)]], t.ariaHidden ? [["aria-hidden", "true"]] : [], Object.entries(t.renderAttrs(e, u)))) }), Object.assign(new u.Token("html_inline", "", 0), { content: t.symbol, meta: ht }), new u.Token("link_close", "a", -1)];
  if (t.space) {
    var o = typeof t.space == "string" ? t.space : " ";
    u.tokens[r + 1].children[Te[t.placement]](Object.assign(new u.Token(typeof t.space == "string" ? "html_inline" : "text", "", 0), { content: o }));
  }
  (i = u.tokens[r + 1].children)[Te[t.placement]].apply(i, a);
});
Object.assign(Tt.defaults, { space: !0, placement: "after", ariaHidden: !1 });
var ge = Xe(Tt.renderPermalinkImpl);
ge.defaults = Object.assign({}, Tt.defaults, { ariaHidden: !0 });
var cr = Xe(function(e, t, n, u, r) {
  var i = [Object.assign(new u.Token("link_open", "a", 1), { attrs: Fn([].concat(t.class ? [["class", t.class]] : [], [["href", t.renderHref(e, u)]], Object.entries(t.renderAttrs(e, u)))) })].concat(t.safariReaderFix ? [new u.Token("span_open", "span", 1)] : [], u.tokens[r + 1].children, t.safariReaderFix ? [new u.Token("span_close", "span", -1)] : [], [new u.Token("link_close", "a", -1)]);
  u.tokens[r + 1] = Object.assign(new u.Token("inline", "", 0), { children: i });
});
Object.assign(cr.defaults, { safariReaderFix: !1 });
var ou = Xe(function(e, t, n, u, r) {
  var i;
  if (!["visually-hidden", "aria-label", "aria-describedby", "aria-labelledby"].includes(t.style)) throw new Error("`permalink.linkAfterHeader` called with unknown style option `" + t.style + "`");
  if (!["aria-describedby", "aria-labelledby"].includes(t.style) && !t.assistiveText) throw new Error("`permalink.linkAfterHeader` called without the `assistiveText` option in `" + t.style + "` style");
  if (t.style === "visually-hidden" && !t.visuallyHiddenClass) throw new Error("`permalink.linkAfterHeader` called without the `visuallyHiddenClass` option in `visually-hidden` style");
  var a = u.tokens[r + 1].children.filter(function(d) {
    return d.type === "text" || d.type === "code_inline";
  }).reduce(function(d, f) {
    return d + f.content;
  }, ""), o = [], s = [];
  if (t.class && s.push(["class", t.class]), s.push(["href", t.renderHref(e, u)]), s.push.apply(s, Object.entries(t.renderAttrs(e, u))), t.style === "visually-hidden") {
    if (o.push(Object.assign(new u.Token("span_open", "span", 1), { attrs: [["class", t.visuallyHiddenClass]] }), Object.assign(new u.Token("text", "", 0), { content: t.assistiveText(a) }), new u.Token("span_close", "span", -1)), t.space) {
      var l = typeof t.space == "string" ? t.space : " ";
      o[Te[t.placement]](Object.assign(new u.Token(typeof t.space == "string" ? "html_inline" : "text", "", 0), { content: l }));
    }
    o[Te[t.placement]](Object.assign(new u.Token("span_open", "span", 1), { attrs: [["aria-hidden", "true"]] }), Object.assign(new u.Token("html_inline", "", 0), { content: t.symbol, meta: ht }), new u.Token("span_close", "span", -1));
  } else o.push(Object.assign(new u.Token("html_inline", "", 0), { content: t.symbol, meta: ht }));
  t.style === "aria-label" ? s.push(["aria-label", t.assistiveText(a)]) : ["aria-describedby", "aria-labelledby"].includes(t.style) && s.push([t.style, e]);
  var c = [Object.assign(new u.Token("link_open", "a", 1), { attrs: Fn(s) })].concat(o, [new u.Token("link_close", "a", -1)]);
  (i = u.tokens).splice.apply(i, [r + 3, 0].concat(c)), t.wrapper && (u.tokens.splice(r, 0, Object.assign(new u.Token("html_block", "", 0), { content: t.wrapper[0] + `
` })), u.tokens.splice(r + 3 + c.length + 1, 0, Object.assign(new u.Token("html_block", "", 0), { content: t.wrapper[1] + `
` })));
});
function su(e, t, n, u) {
  var r = e, i = u;
  if (n && Object.prototype.hasOwnProperty.call(t, r)) throw new Error("User defined `id` attribute `" + e + "` is not unique. Please fix it in your Markdown to continue.");
  for (; Object.prototype.hasOwnProperty.call(t, r); ) r = e + "-" + i, i += 1;
  return t[r] = !0, r;
}
function _e(e, t) {
  t = Object.assign({}, _e.defaults, t), e.core.ruler.push("anchor", function(n) {
    for (var u, r = {}, i = n.tokens, a = Array.isArray(t.level) ? (u = t.level, function(d) {
      return u.includes(d);
    }) : /* @__PURE__ */ function(d) {
      return function(f) {
        return f >= d;
      };
    }(t.level), o = 0; o < i.length; o++) {
      var s = i[o];
      if (s.type === "heading_open" && a(Number(s.tag.substr(1)))) {
        var l = t.getTokensText(i[o + 1].children), c = s.attrGet("id");
        c = c == null ? su(c = t.slugifyWithState ? t.slugifyWithState(l, n) : t.slugify(l), r, !1, t.uniqueSlugStartIndex) : su(c, r, !0, t.uniqueSlugStartIndex), s.attrSet("id", c), t.tabIndex !== !1 && s.attrSet("tabindex", "" + t.tabIndex), typeof t.permalink == "function" ? t.permalink(c, t, n, o) : (t.permalink || t.renderPermalink && t.renderPermalink !== sn) && t.renderPermalink(c, t, n, o), o = i.indexOf(s), t.callback && t.callback(s, { slug: c, title: l });
      }
    }
  });
}
Object.assign(ou.defaults, { style: "visually-hidden", space: !0, placement: "after", wrapper: null }), _e.permalink = { __proto__: null, legacy: sn, renderHref: sr, renderAttrs: lr, makePermalink: Xe, linkInsideHeader: Tt, ariaHidden: ge, headerLink: cr, linkAfterHeader: ou }, _e.defaults = { level: 1, slugify: function(e) {
  return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g, "-"));
}, uniqueSlugStartIndex: 1, tabIndex: "-1", getTokensText: function(e) {
  return e.filter(function(t) {
    return ["text", "code_inline"].includes(t.type);
  }).map(function(t) {
    return t.content;
  }).join("");
}, permalink: !1, renderPermalink: sn, permalinkClass: ge.defaults.class, permalinkSpace: ge.defaults.space, permalinkSymbol: "¶", permalinkBefore: ge.defaults.placement === "before", permalinkHref: ge.defaults.renderHref, permalinkAttrs: ge.defaults.renderAttrs }, _e.default = _e;
function ds(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var se = {}, lu;
function fs() {
  if (lu) return se;
  lu = 1, se.getAttrs = function(i, a, o) {
    const s = /[^\t\n\f />"'=]/, l = " ", c = "=", d = ".", f = "#", p = [];
    let h = "", g = "", m = !0, b = !1;
    for (let _ = a + o.leftDelimiter.length; _ < i.length; _++) {
      if (i.slice(_, _ + o.rightDelimiter.length) === o.rightDelimiter) {
        h !== "" && p.push([h, g]);
        break;
      }
      const y = i.charAt(_);
      if (y === c && m) {
        m = !1;
        continue;
      }
      if (y === d && h === "") {
        i.charAt(_ + 1) === d ? (h = "css-module", _ += 1) : h = "class", m = !1;
        continue;
      }
      if (y === f && h === "") {
        h = "id", m = !1;
        continue;
      }
      if (y === '"' && g === "" && !b) {
        b = !0;
        continue;
      }
      if (y === '"' && b) {
        b = !1;
        continue;
      }
      if (y === l && !b) {
        if (h === "")
          continue;
        p.push([h, g]), h = "", g = "", m = !0;
        continue;
      }
      if (!(m && y.search(s) === -1)) {
        if (m) {
          h += y;
          continue;
        }
        g += y;
      }
    }
    if (o.allowedAttributes && o.allowedAttributes.length) {
      const _ = o.allowedAttributes;
      return p.filter(function(y) {
        const x = y[0];
        function C(v) {
          return x === v || v instanceof RegExp && v.test(x);
        }
        return _.some(C);
      });
    }
    return p;
  }, se.addAttrs = function(i, a) {
    for (let o = 0, s = i.length; o < s; ++o) {
      const l = i[o][0];
      l === "class" ? a.attrJoin("class", i[o][1]) : l === "css-module" ? a.attrJoin("css-module", i[o][1]) : a.attrPush(i[o]);
    }
    return a;
  }, se.hasDelimiters = function(i, a) {
    if (!i)
      throw new Error('Parameter `where` not passed. Should be "start", "end" or "only".');
    return function(o) {
      const s = a.leftDelimiter.length + 1 + a.rightDelimiter.length;
      if (!o || typeof o != "string" || o.length < s)
        return !1;
      function l(g) {
        const m = g.charAt(a.leftDelimiter.length) === ".", b = g.charAt(a.leftDelimiter.length) === "#";
        return m || b ? g.length >= s + 1 : g.length >= s;
      }
      let c, d, f, p;
      const h = s - a.rightDelimiter.length;
      switch (i) {
        case "start":
          f = o.slice(0, a.leftDelimiter.length), c = f === a.leftDelimiter ? 0 : -1, d = c === -1 ? -1 : o.indexOf(a.rightDelimiter, h), p = o.charAt(d + a.rightDelimiter.length), p && a.rightDelimiter.indexOf(p) !== -1 && (d = -1);
          break;
        case "end":
          c = o.lastIndexOf(a.leftDelimiter), d = c === -1 ? -1 : o.indexOf(a.rightDelimiter, c + h), d = d === o.length - a.rightDelimiter.length ? d : -1;
          break;
        case "only":
          f = o.slice(0, a.leftDelimiter.length), c = f === a.leftDelimiter ? 0 : -1, f = o.slice(o.length - a.rightDelimiter.length), d = f === a.rightDelimiter ? o.length - a.rightDelimiter.length : -1;
          break;
        default:
          throw new Error(`Unexpected case ${i}, expected 'start', 'end' or 'only'`);
      }
      return c !== -1 && d !== -1 && l(o.substring(c, d + a.rightDelimiter.length));
    };
  }, se.removeDelimiter = function(i, a) {
    const o = e(a.leftDelimiter), s = e(a.rightDelimiter), l = new RegExp(
      "[ \\n]?" + o + "[^" + o + s + "]+" + s + "$"
    ), c = i.search(l);
    return c !== -1 ? i.slice(0, c) : i;
  };
  function e(i) {
    return i.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  se.escapeRegExp = e, se.getMatchingOpeningToken = function(i, a) {
    if (i[a].type === "softbreak")
      return !1;
    if (i[a].nesting === 0)
      return i[a];
    const o = i[a].level, s = i[a].type.replace("_close", "_open");
    for (; a >= 0; --a)
      if (i[a].type === s && i[a].level === o)
        return i[a];
    return !1;
  };
  const t = /[&<>"]/, n = /[&<>"]/g, u = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function r(i) {
    return u[i];
  }
  return se.escapeHtml = function(i) {
    return t.test(i) ? i.replace(n, r) : i;
  }, se;
}
var Ht, cu;
function hs() {
  if (cu) return Ht;
  cu = 1;
  const e = fs();
  Ht = (u) => {
    const r = new RegExp("^ {0,3}[-*_]{3,} ?" + e.escapeRegExp(u.leftDelimiter) + "[^" + e.escapeRegExp(u.rightDelimiter) + "]");
    return [
      {
        /**
         * ```python {.cls}
         * for i in range(10):
         *     print(i)
         * ```
         */
        name: "fenced code blocks",
        tests: [
          {
            shift: 0,
            block: !0,
            info: e.hasDelimiters("end", u)
          }
        ],
        transform: (i, a) => {
          const o = i[a], s = o.info.lastIndexOf(u.leftDelimiter), l = e.getAttrs(o.info, s, u);
          e.addAttrs(l, o), o.info = e.removeDelimiter(o.info, u);
        }
      },
      {
        /**
         * bla `click()`{.c} ![](img.png){.d}
         *
         * differs from 'inline attributes' as it does
         * not have a closing tag (nesting: -1)
         */
        name: "inline nesting 0",
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                shift: -1,
                type: (i) => i === "image" || i === "code_inline"
              },
              {
                shift: 0,
                type: "text",
                content: e.hasDelimiters("start", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content.indexOf(u.rightDelimiter), c = i[a].children[o - 1], d = e.getAttrs(s.content, 0, u);
          e.addAttrs(d, c), s.content.length === l + u.rightDelimiter.length ? i[a].children.splice(o, 1) : s.content = s.content.slice(l + u.rightDelimiter.length);
        }
      },
      {
        /**
         * | h1 |
         * | -- |
         * | c1 |
         *
         * {.c}
         */
        name: "tables",
        tests: [
          {
            // let this token be i, such that for-loop continues at
            // next token after tokens.splice
            shift: 0,
            type: "table_close"
          },
          {
            shift: 1,
            type: "paragraph_open"
          },
          {
            shift: 2,
            type: "inline",
            content: e.hasDelimiters("only", u)
          }
        ],
        transform: (i, a) => {
          const o = i[a + 2], s = e.getMatchingOpeningToken(i, a), l = e.getAttrs(o.content, 0, u);
          e.addAttrs(l, s), i.splice(a + 1, 3);
        }
      },
      {
        /**
         * | A | B |
         * | -- | -- |
         * | 1 | 2 |
         *
         * | C | D |
         * | -- | -- |
         *
         * only `| A | B |` sets the colsnum metadata
         */
        name: "tables thead metadata",
        tests: [
          {
            shift: 0,
            type: "tr_close"
          },
          {
            shift: 1,
            type: "thead_close"
          },
          {
            shift: 2,
            type: "tbody_open"
          }
        ],
        transform: (i, a) => {
          const o = e.getMatchingOpeningToken(i, a), s = i[a - 1];
          let l = 0, c = a;
          for (; --c; ) {
            if (i[c] === o) {
              i[c - 1].meta = Object.assign({}, i[c + 2].meta, { colsnum: l });
              break;
            }
            l += (i[c].level === s.level && i[c].type === s.type) >> 0;
          }
          i[a + 2].meta = Object.assign({}, i[a + 2].meta, { colsnum: l });
        }
      },
      {
        /**
         * | A | B | C | D |
         * | -- | -- | -- | -- |
         * | 1 | 11 | 111 | 1111 {rowspan=3} |
         * | 2 {colspan=2 rowspan=2} | 22 | 222 | 2222 |
         * | 3 | 33 | 333 | 3333 |
         */
        name: "tables tbody calculate",
        tests: [
          {
            shift: 0,
            type: "tbody_close",
            hidden: !1
          }
        ],
        /**
         * @param {number} i index of the tbody ending
         */
        transform: (i, a) => {
          let o = a - 2;
          for (; o > 0 && i[--o].type !== "tbody_open"; ) ;
          const s = i[o].meta.colsnum >> 0;
          if (s < 2)
            return;
          const l = i[a].level + 2;
          for (let c = o; c < a; c++) {
            if (i[c].level > l)
              continue;
            const d = i[c], f = d.hidden ? 0 : d.attrGet("rowspan") >> 0, p = d.hidden ? 0 : d.attrGet("colspan") >> 0;
            if (f > 1) {
              let h = s - (p > 0 ? p : 1);
              for (let g = c, m = f; m > 1; g++)
                i[g].type == "tr_open" && (i[g].meta = Object.assign({}, i[g].meta), i[g].meta && i[g].meta.colsnum && (h -= 1), i[g].meta.colsnum = h, m--);
            }
            if (d.type == "tr_open" && d.meta && d.meta.colsnum) {
              const h = d.meta.colsnum;
              for (let g = c, m = 0; g < a; g++) {
                if (i[g].type == "td_open")
                  m += 1;
                else if (i[g].type == "tr_close")
                  break;
                m > h && (i[g].hidden || n(i[g]));
              }
            }
            if (p > 1) {
              const h = [];
              let g = c + 3, m = s;
              for (let y = c; y > o; y--)
                if (i[y].type == "tr_open") {
                  m = i[y].meta && i[y].meta.colsnum || m;
                  break;
                } else i[y].type === "td_open" && h.unshift(y);
              for (let y = c + 2; y < a; y++)
                if (i[y].type == "tr_close") {
                  g = y;
                  break;
                } else i[y].type == "td_open" && h.push(y);
              const b = h.indexOf(c);
              let _ = m - b;
              _ = _ > p ? p : _, p > _ && d.attrSet("colspan", _ + "");
              for (let y = h.slice(m + 1 - s - _)[0]; y < g; y++)
                i[y].hidden || n(i[y]);
            }
          }
        }
      },
      {
        /**
         * *emphasis*{.with attrs=1}
         */
        name: "inline attributes",
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                shift: -1,
                nesting: -1
                // closing inline tag, </em>{.a}
              },
              {
                shift: 0,
                type: "text",
                content: e.hasDelimiters("start", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content, c = e.getAttrs(l, 0, u), d = e.getMatchingOpeningToken(i[a].children, o - 1);
          e.addAttrs(c, d), s.content = l.slice(l.indexOf(u.rightDelimiter) + u.rightDelimiter.length);
        }
      },
      {
        /**
         * - item
         * {.a}
         */
        name: "list softbreak",
        tests: [
          {
            shift: -2,
            type: "list_item_open"
          },
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -2,
                type: "softbreak"
              },
              {
                position: -1,
                type: "text",
                content: e.hasDelimiters("only", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const l = i[a].children[o].content, c = e.getAttrs(l, 0, u);
          let d = a - 2;
          for (; i[d - 1] && i[d - 1].type !== "ordered_list_open" && i[d - 1].type !== "bullet_list_open"; )
            d--;
          e.addAttrs(c, i[d - 1]), i[a].children = i[a].children.slice(0, -2);
        }
      },
      {
        /**
         * - nested list
         *   - with double \n
         *   {.a} <-- apply to nested ul
         *
         * {.b} <-- apply to root <ul>
         */
        name: "list double softbreak",
        tests: [
          {
            // let this token be i = 0 so that we can erase
            // the <p>{.a}</p> tokens below
            shift: 0,
            type: (i) => i === "bullet_list_close" || i === "ordered_list_close"
          },
          {
            shift: 1,
            type: "paragraph_open"
          },
          {
            shift: 2,
            type: "inline",
            content: e.hasDelimiters("only", u),
            children: (i) => i.length === 1
          },
          {
            shift: 3,
            type: "paragraph_close"
          }
        ],
        transform: (i, a) => {
          const s = i[a + 2].content, l = e.getAttrs(s, 0, u), c = e.getMatchingOpeningToken(i, a);
          e.addAttrs(l, c), i.splice(a + 1, 3);
        }
      },
      {
        /**
         * - end of {.list-item}
         */
        name: "list item end",
        tests: [
          {
            shift: -2,
            type: "list_item_open"
          },
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -1,
                type: "text",
                content: e.hasDelimiters("end", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content, c = e.getAttrs(l, l.lastIndexOf(u.leftDelimiter), u);
          e.addAttrs(c, i[a - 2]);
          const d = l.slice(0, l.lastIndexOf(u.leftDelimiter));
          s.content = t(d) !== " " ? d : d.slice(0, -1);
        }
      },
      {
        /**
         * something with softbreak
         * {.cls}
         */
        name: `
{.a} softbreak then curly in start`,
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -2,
                type: "softbreak"
              },
              {
                position: -1,
                type: "text",
                content: e.hasDelimiters("only", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = e.getAttrs(s.content, 0, u);
          let c = a + 1;
          for (; i[c + 1] && i[c + 1].nesting === -1; )
            c++;
          const d = e.getMatchingOpeningToken(i, c);
          e.addAttrs(l, d), i[a].children = i[a].children.slice(0, -2);
        }
      },
      {
        /**
         * horizontal rule --- {#id}
         */
        name: "horizontal rule",
        tests: [
          {
            shift: 0,
            type: "paragraph_open"
          },
          {
            shift: 1,
            type: "inline",
            children: (i) => i.length === 1,
            content: (i) => i.match(r) !== null
          },
          {
            shift: 2,
            type: "paragraph_close"
          }
        ],
        transform: (i, a) => {
          const o = i[a];
          o.type = "hr", o.tag = "hr", o.nesting = 0;
          const s = i[a + 1].content, l = s.lastIndexOf(u.leftDelimiter), c = e.getAttrs(s, l, u);
          e.addAttrs(c, o), o.markup = s, i.splice(a + 1, 2);
        }
      },
      {
        /**
         * end of {.block}
         */
        name: "end of block",
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -1,
                content: e.hasDelimiters("end", u),
                type: (i) => i !== "code_inline" && i !== "math_inline"
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content, c = e.getAttrs(l, l.lastIndexOf(u.leftDelimiter), u);
          let d = a + 1;
          do
            if (i[d] && i[d].nesting === -1)
              break;
          while (d++ < i.length);
          const f = e.getMatchingOpeningToken(i, d);
          e.addAttrs(c, f);
          const p = l.slice(0, l.lastIndexOf(u.leftDelimiter));
          s.content = t(p) !== " " ? p : p.slice(0, -1);
        }
      }
    ];
  };
  function t(u) {
    return u.slice(-1)[0];
  }
  function n(u) {
    u.hidden = !0, u.children && u.children.forEach((r) => (r.content = "", n(r), void 0));
  }
  return Ht;
}
var Ut, du;
function ps() {
  if (du) return Ut;
  du = 1;
  const e = hs(), t = {
    leftDelimiter: "{",
    rightDelimiter: "}",
    allowedAttributes: []
  };
  Ut = function(s, l) {
    let c = Object.assign({}, t);
    c = Object.assign(c, l);
    const d = e(c);
    function f(p) {
      const h = p.tokens;
      for (let g = 0; g < h.length; g++)
        for (let m = 0; m < d.length; m++) {
          const b = d[m];
          let _ = null;
          if (b.tests.every((x) => {
            const C = n(h, g, x);
            return C.j !== null && (_ = C.j), C.match;
          }))
            try {
              b.transform(h, g, _), (b.name === "inline attributes" || b.name === "inline nesting 0") && m--;
            } catch (x) {
              console.error(`markdown-it-attrs: Error in pattern '${b.name}': ${x.message}`), console.error(x.stack);
            }
        }
    }
    s.core.ruler.before("linkify", "curly_attributes", f);
  };
  function n(o, s, l) {
    const c = {
      match: !1,
      j: null
      // position of child
    }, d = l.shift !== void 0 ? s + l.shift : l.position;
    if (l.shift !== void 0 && d < 0)
      return c;
    const f = i(o, d);
    if (f === void 0)
      return c;
    for (const p of Object.keys(l))
      if (!(p === "shift" || p === "position")) {
        if (f[p] === void 0)
          return c;
        if (p === "children" && u(l.children)) {
          if (f.children.length === 0)
            return c;
          let h;
          const g = l.children, m = f.children;
          if (g.every((b) => b.position !== void 0)) {
            if (h = g.every((b) => n(m, b.position, b).match), h) {
              const b = a(g).position;
              c.j = b >= 0 ? b : m.length + b;
            }
          } else
            for (let b = 0; b < m.length; b++)
              if (h = g.every((_) => n(m, b, _).match), h) {
                c.j = b;
                break;
              }
          if (h === !1)
            return c;
          continue;
        }
        switch (typeof l[p]) {
          case "boolean":
          case "number":
          case "string":
            if (f[p] !== l[p])
              return c;
            break;
          case "function":
            if (!l[p](f[p]))
              return c;
            break;
          case "object":
            if (r(l[p])) {
              if (l[p].every((g) => g(f[p])) === !1)
                return c;
              break;
            }
          // fall through for objects !== arrays of functions
          default:
            throw new Error(`Unknown type of pattern test (key: ${p}). Test should be of type boolean, number, string, function or array of functions.`);
        }
      }
    return c.match = !0, c;
  }
  function u(o) {
    return Array.isArray(o) && o.length && o.every((s) => typeof s == "object");
  }
  function r(o) {
    return Array.isArray(o) && o.length && o.every((s) => typeof s == "function");
  }
  function i(o, s) {
    return s >= 0 ? o[s] : o[o.length + s];
  }
  function a(o) {
    return o.slice(-1)[0] || {};
  }
  return Ut;
}
var ms = ps();
const gs = /* @__PURE__ */ ds(ms);
function _s(e, t) {
  return e[t].content;
}
function bs(e, t, n, u, r) {
  const i = e.utils.arrayReplaceAt, a = e.utils.lib.ucmicro, o = e.utils.has, s = new RegExp([a.Z.source, a.P.source, a.Cc.source].join("|"));
  function l(c, d, f) {
    let p = 0;
    const h = [];
    if (c.replace(r, function(g, m, b) {
      let _;
      if (o(n, g)) {
        if (_ = n[g], m > 0 && !s.test(b[m - 1]) || m + g.length < b.length && !s.test(b[m + g.length]))
          return;
      } else
        _ = g.slice(1, -1);
      if (m > p) {
        const x = new f("text", "", 0);
        x.content = c.slice(p, m), h.push(x);
      }
      const y = new f("emoji", "", 0);
      y.markup = _, y.content = t[_], h.push(y), p = m + g.length;
    }), p < c.length) {
      const g = new f("text", "", 0);
      g.content = c.slice(p), h.push(g);
    }
    return h;
  }
  return function(d) {
    let f;
    const p = d.tokens;
    let h = 0;
    for (let g = 0, m = p.length; g < m; g++) {
      if (p[g].type !== "inline")
        continue;
      let b = p[g].children;
      for (let _ = b.length - 1; _ >= 0; _--)
        f = b[_], (f.type === "link_open" || f.type === "link_close") && f.info === "auto" && (h -= f.nesting), f.type === "text" && h === 0 && u.test(f.content) && (p[g].children = b = i(
          b,
          _,
          l(f.content, f.level, d.Token)
        ));
    }
  };
}
function ys(e) {
  return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
function ks(e) {
  let t = e.defs;
  e.enabled.length && (t = Object.keys(t).reduce((o, s) => (e.enabled.indexOf(s) >= 0 && (o[s] = t[s]), o), {}));
  const n = Object.keys(e.shortcuts).reduce((o, s) => t[s] ? Array.isArray(e.shortcuts[s]) ? (e.shortcuts[s].forEach((l) => {
    o[l] = s;
  }), o) : (o[e.shortcuts[s]] = s, o) : o, {}), u = Object.keys(t);
  let r;
  u.length === 0 ? r = "^$" : r = u.map((o) => `:${o}:`).concat(Object.keys(n)).sort().reverse().map((o) => ys(o)).join("|");
  const i = RegExp(r), a = RegExp(r, "g");
  return {
    defs: t,
    shortcuts: n,
    scanRE: i,
    replaceRE: a
  };
}
function xs(e, t) {
  const n = {
    defs: {},
    shortcuts: {},
    enabled: []
  }, u = ks(e.utils.assign({}, n, t || {}));
  e.renderer.rules.emoji = _s, e.core.ruler.after(
    "linkify",
    "emoji",
    bs(e, u.defs, u.shortcuts, u.scanRE, u.replaceRE)
  );
}
const ws = {
  angry: [">:(", ">:-("],
  blush: [':")', ':-")'],
  broken_heart: ["</3", "<\\3"],
  // :\ and :-\ not used because of conflict with markdown escaping
  confused: [":/", ":-/"],
  // twemoji shows question
  cry: [":'(", ":'-(", ":,(", ":,-("],
  frowning: [":(", ":-("],
  heart: ["<3"],
  imp: ["]:(", "]:-("],
  innocent: ["o:)", "O:)", "o:-)", "O:-)", "0:)", "0:-)"],
  joy: [":')", ":'-)", ":,)", ":,-)", ":'D", ":'-D", ":,D", ":,-D"],
  kissing: [":*", ":-*"],
  laughing: ["x-)", "X-)"],
  neutral_face: [":|", ":-|"],
  open_mouth: [":o", ":-o", ":O", ":-O"],
  rage: [":@", ":-@"],
  smile: [":D", ":-D"],
  smiley: [":)", ":-)"],
  smiling_imp: ["]:)", "]:-)"],
  sob: [":,'(", ":,'-(", ";(", ";-("],
  stuck_out_tongue: [":P", ":-P"],
  sunglasses: ["8-)", "B-)"],
  sweat: [",:(", ",:-("],
  sweat_smile: [",:)", ",:-)"],
  unamused: [":s", ":-S", ":z", ":-Z", ":$", ":-$"],
  wink: [";)", ";-)"]
}, Cs = {
  100: "💯",
  1234: "🔢",
  grinning: "😀",
  smiley: "😃",
  smile: "😄",
  grin: "😁",
  laughing: "😆",
  satisfied: "😆",
  sweat_smile: "😅",
  rofl: "🤣",
  joy: "😂",
  slightly_smiling_face: "🙂",
  upside_down_face: "🙃",
  melting_face: "🫠",
  wink: "😉",
  blush: "😊",
  innocent: "😇",
  smiling_face_with_three_hearts: "🥰",
  heart_eyes: "😍",
  star_struck: "🤩",
  kissing_heart: "😘",
  kissing: "😗",
  relaxed: "☺️",
  kissing_closed_eyes: "😚",
  kissing_smiling_eyes: "😙",
  smiling_face_with_tear: "🥲",
  yum: "😋",
  stuck_out_tongue: "😛",
  stuck_out_tongue_winking_eye: "😜",
  zany_face: "🤪",
  stuck_out_tongue_closed_eyes: "😝",
  money_mouth_face: "🤑",
  hugs: "🤗",
  hand_over_mouth: "🤭",
  face_with_open_eyes_and_hand_over_mouth: "🫢",
  face_with_peeking_eye: "🫣",
  shushing_face: "🤫",
  thinking: "🤔",
  saluting_face: "🫡",
  zipper_mouth_face: "🤐",
  raised_eyebrow: "🤨",
  neutral_face: "😐",
  expressionless: "😑",
  no_mouth: "😶",
  dotted_line_face: "🫥",
  face_in_clouds: "😶‍🌫️",
  smirk: "😏",
  unamused: "😒",
  roll_eyes: "🙄",
  grimacing: "😬",
  face_exhaling: "😮‍💨",
  lying_face: "🤥",
  shaking_face: "🫨",
  relieved: "😌",
  pensive: "😔",
  sleepy: "😪",
  drooling_face: "🤤",
  sleeping: "😴",
  mask: "😷",
  face_with_thermometer: "🤒",
  face_with_head_bandage: "🤕",
  nauseated_face: "🤢",
  vomiting_face: "🤮",
  sneezing_face: "🤧",
  hot_face: "🥵",
  cold_face: "🥶",
  woozy_face: "🥴",
  dizzy_face: "😵",
  face_with_spiral_eyes: "😵‍💫",
  exploding_head: "🤯",
  cowboy_hat_face: "🤠",
  partying_face: "🥳",
  disguised_face: "🥸",
  sunglasses: "😎",
  nerd_face: "🤓",
  monocle_face: "🧐",
  confused: "😕",
  face_with_diagonal_mouth: "🫤",
  worried: "😟",
  slightly_frowning_face: "🙁",
  frowning_face: "☹️",
  open_mouth: "😮",
  hushed: "😯",
  astonished: "😲",
  flushed: "😳",
  pleading_face: "🥺",
  face_holding_back_tears: "🥹",
  frowning: "😦",
  anguished: "😧",
  fearful: "😨",
  cold_sweat: "😰",
  disappointed_relieved: "😥",
  cry: "😢",
  sob: "😭",
  scream: "😱",
  confounded: "😖",
  persevere: "😣",
  disappointed: "😞",
  sweat: "😓",
  weary: "😩",
  tired_face: "😫",
  yawning_face: "🥱",
  triumph: "😤",
  rage: "😡",
  pout: "😡",
  angry: "😠",
  cursing_face: "🤬",
  smiling_imp: "😈",
  imp: "👿",
  skull: "💀",
  skull_and_crossbones: "☠️",
  hankey: "💩",
  poop: "💩",
  shit: "💩",
  clown_face: "🤡",
  japanese_ogre: "👹",
  japanese_goblin: "👺",
  ghost: "👻",
  alien: "👽",
  space_invader: "👾",
  robot: "🤖",
  smiley_cat: "😺",
  smile_cat: "😸",
  joy_cat: "😹",
  heart_eyes_cat: "😻",
  smirk_cat: "😼",
  kissing_cat: "😽",
  scream_cat: "🙀",
  crying_cat_face: "😿",
  pouting_cat: "😾",
  see_no_evil: "🙈",
  hear_no_evil: "🙉",
  speak_no_evil: "🙊",
  love_letter: "💌",
  cupid: "💘",
  gift_heart: "💝",
  sparkling_heart: "💖",
  heartpulse: "💗",
  heartbeat: "💓",
  revolving_hearts: "💞",
  two_hearts: "💕",
  heart_decoration: "💟",
  heavy_heart_exclamation: "❣️",
  broken_heart: "💔",
  heart_on_fire: "❤️‍🔥",
  mending_heart: "❤️‍🩹",
  heart: "❤️",
  pink_heart: "🩷",
  orange_heart: "🧡",
  yellow_heart: "💛",
  green_heart: "💚",
  blue_heart: "💙",
  light_blue_heart: "🩵",
  purple_heart: "💜",
  brown_heart: "🤎",
  black_heart: "🖤",
  grey_heart: "🩶",
  white_heart: "🤍",
  kiss: "💋",
  anger: "💢",
  boom: "💥",
  collision: "💥",
  dizzy: "💫",
  sweat_drops: "💦",
  dash: "💨",
  hole: "🕳️",
  speech_balloon: "💬",
  eye_speech_bubble: "👁️‍🗨️",
  left_speech_bubble: "🗨️",
  right_anger_bubble: "🗯️",
  thought_balloon: "💭",
  zzz: "💤",
  wave: "👋",
  raised_back_of_hand: "🤚",
  raised_hand_with_fingers_splayed: "🖐️",
  hand: "✋",
  raised_hand: "✋",
  vulcan_salute: "🖖",
  rightwards_hand: "🫱",
  leftwards_hand: "🫲",
  palm_down_hand: "🫳",
  palm_up_hand: "🫴",
  leftwards_pushing_hand: "🫷",
  rightwards_pushing_hand: "🫸",
  ok_hand: "👌",
  pinched_fingers: "🤌",
  pinching_hand: "🤏",
  v: "✌️",
  crossed_fingers: "🤞",
  hand_with_index_finger_and_thumb_crossed: "🫰",
  love_you_gesture: "🤟",
  metal: "🤘",
  call_me_hand: "🤙",
  point_left: "👈",
  point_right: "👉",
  point_up_2: "👆",
  middle_finger: "🖕",
  fu: "🖕",
  point_down: "👇",
  point_up: "☝️",
  index_pointing_at_the_viewer: "🫵",
  "+1": "👍",
  thumbsup: "👍",
  "-1": "👎",
  thumbsdown: "👎",
  fist_raised: "✊",
  fist: "✊",
  fist_oncoming: "👊",
  facepunch: "👊",
  punch: "👊",
  fist_left: "🤛",
  fist_right: "🤜",
  clap: "👏",
  raised_hands: "🙌",
  heart_hands: "🫶",
  open_hands: "👐",
  palms_up_together: "🤲",
  handshake: "🤝",
  pray: "🙏",
  writing_hand: "✍️",
  nail_care: "💅",
  selfie: "🤳",
  muscle: "💪",
  mechanical_arm: "🦾",
  mechanical_leg: "🦿",
  leg: "🦵",
  foot: "🦶",
  ear: "👂",
  ear_with_hearing_aid: "🦻",
  nose: "👃",
  brain: "🧠",
  anatomical_heart: "🫀",
  lungs: "🫁",
  tooth: "🦷",
  bone: "🦴",
  eyes: "👀",
  eye: "👁️",
  tongue: "👅",
  lips: "👄",
  biting_lip: "🫦",
  baby: "👶",
  child: "🧒",
  boy: "👦",
  girl: "👧",
  adult: "🧑",
  blond_haired_person: "👱",
  man: "👨",
  bearded_person: "🧔",
  man_beard: "🧔‍♂️",
  woman_beard: "🧔‍♀️",
  red_haired_man: "👨‍🦰",
  curly_haired_man: "👨‍🦱",
  white_haired_man: "👨‍🦳",
  bald_man: "👨‍🦲",
  woman: "👩",
  red_haired_woman: "👩‍🦰",
  person_red_hair: "🧑‍🦰",
  curly_haired_woman: "👩‍🦱",
  person_curly_hair: "🧑‍🦱",
  white_haired_woman: "👩‍🦳",
  person_white_hair: "🧑‍🦳",
  bald_woman: "👩‍🦲",
  person_bald: "🧑‍🦲",
  blond_haired_woman: "👱‍♀️",
  blonde_woman: "👱‍♀️",
  blond_haired_man: "👱‍♂️",
  older_adult: "🧓",
  older_man: "👴",
  older_woman: "👵",
  frowning_person: "🙍",
  frowning_man: "🙍‍♂️",
  frowning_woman: "🙍‍♀️",
  pouting_face: "🙎",
  pouting_man: "🙎‍♂️",
  pouting_woman: "🙎‍♀️",
  no_good: "🙅",
  no_good_man: "🙅‍♂️",
  ng_man: "🙅‍♂️",
  no_good_woman: "🙅‍♀️",
  ng_woman: "🙅‍♀️",
  ok_person: "🙆",
  ok_man: "🙆‍♂️",
  ok_woman: "🙆‍♀️",
  tipping_hand_person: "💁",
  information_desk_person: "💁",
  tipping_hand_man: "💁‍♂️",
  sassy_man: "💁‍♂️",
  tipping_hand_woman: "💁‍♀️",
  sassy_woman: "💁‍♀️",
  raising_hand: "🙋",
  raising_hand_man: "🙋‍♂️",
  raising_hand_woman: "🙋‍♀️",
  deaf_person: "🧏",
  deaf_man: "🧏‍♂️",
  deaf_woman: "🧏‍♀️",
  bow: "🙇",
  bowing_man: "🙇‍♂️",
  bowing_woman: "🙇‍♀️",
  facepalm: "🤦",
  man_facepalming: "🤦‍♂️",
  woman_facepalming: "🤦‍♀️",
  shrug: "🤷",
  man_shrugging: "🤷‍♂️",
  woman_shrugging: "🤷‍♀️",
  health_worker: "🧑‍⚕️",
  man_health_worker: "👨‍⚕️",
  woman_health_worker: "👩‍⚕️",
  student: "🧑‍🎓",
  man_student: "👨‍🎓",
  woman_student: "👩‍🎓",
  teacher: "🧑‍🏫",
  man_teacher: "👨‍🏫",
  woman_teacher: "👩‍🏫",
  judge: "🧑‍⚖️",
  man_judge: "👨‍⚖️",
  woman_judge: "👩‍⚖️",
  farmer: "🧑‍🌾",
  man_farmer: "👨‍🌾",
  woman_farmer: "👩‍🌾",
  cook: "🧑‍🍳",
  man_cook: "👨‍🍳",
  woman_cook: "👩‍🍳",
  mechanic: "🧑‍🔧",
  man_mechanic: "👨‍🔧",
  woman_mechanic: "👩‍🔧",
  factory_worker: "🧑‍🏭",
  man_factory_worker: "👨‍🏭",
  woman_factory_worker: "👩‍🏭",
  office_worker: "🧑‍💼",
  man_office_worker: "👨‍💼",
  woman_office_worker: "👩‍💼",
  scientist: "🧑‍🔬",
  man_scientist: "👨‍🔬",
  woman_scientist: "👩‍🔬",
  technologist: "🧑‍💻",
  man_technologist: "👨‍💻",
  woman_technologist: "👩‍💻",
  singer: "🧑‍🎤",
  man_singer: "👨‍🎤",
  woman_singer: "👩‍🎤",
  artist: "🧑‍🎨",
  man_artist: "👨‍🎨",
  woman_artist: "👩‍🎨",
  pilot: "🧑‍✈️",
  man_pilot: "👨‍✈️",
  woman_pilot: "👩‍✈️",
  astronaut: "🧑‍🚀",
  man_astronaut: "👨‍🚀",
  woman_astronaut: "👩‍🚀",
  firefighter: "🧑‍🚒",
  man_firefighter: "👨‍🚒",
  woman_firefighter: "👩‍🚒",
  police_officer: "👮",
  cop: "👮",
  policeman: "👮‍♂️",
  policewoman: "👮‍♀️",
  detective: "🕵️",
  male_detective: "🕵️‍♂️",
  female_detective: "🕵️‍♀️",
  guard: "💂",
  guardsman: "💂‍♂️",
  guardswoman: "💂‍♀️",
  ninja: "🥷",
  construction_worker: "👷",
  construction_worker_man: "👷‍♂️",
  construction_worker_woman: "👷‍♀️",
  person_with_crown: "🫅",
  prince: "🤴",
  princess: "👸",
  person_with_turban: "👳",
  man_with_turban: "👳‍♂️",
  woman_with_turban: "👳‍♀️",
  man_with_gua_pi_mao: "👲",
  woman_with_headscarf: "🧕",
  person_in_tuxedo: "🤵",
  man_in_tuxedo: "🤵‍♂️",
  woman_in_tuxedo: "🤵‍♀️",
  person_with_veil: "👰",
  man_with_veil: "👰‍♂️",
  woman_with_veil: "👰‍♀️",
  bride_with_veil: "👰‍♀️",
  pregnant_woman: "🤰",
  pregnant_man: "🫃",
  pregnant_person: "🫄",
  breast_feeding: "🤱",
  woman_feeding_baby: "👩‍🍼",
  man_feeding_baby: "👨‍🍼",
  person_feeding_baby: "🧑‍🍼",
  angel: "👼",
  santa: "🎅",
  mrs_claus: "🤶",
  mx_claus: "🧑‍🎄",
  superhero: "🦸",
  superhero_man: "🦸‍♂️",
  superhero_woman: "🦸‍♀️",
  supervillain: "🦹",
  supervillain_man: "🦹‍♂️",
  supervillain_woman: "🦹‍♀️",
  mage: "🧙",
  mage_man: "🧙‍♂️",
  mage_woman: "🧙‍♀️",
  fairy: "🧚",
  fairy_man: "🧚‍♂️",
  fairy_woman: "🧚‍♀️",
  vampire: "🧛",
  vampire_man: "🧛‍♂️",
  vampire_woman: "🧛‍♀️",
  merperson: "🧜",
  merman: "🧜‍♂️",
  mermaid: "🧜‍♀️",
  elf: "🧝",
  elf_man: "🧝‍♂️",
  elf_woman: "🧝‍♀️",
  genie: "🧞",
  genie_man: "🧞‍♂️",
  genie_woman: "🧞‍♀️",
  zombie: "🧟",
  zombie_man: "🧟‍♂️",
  zombie_woman: "🧟‍♀️",
  troll: "🧌",
  massage: "💆",
  massage_man: "💆‍♂️",
  massage_woman: "💆‍♀️",
  haircut: "💇",
  haircut_man: "💇‍♂️",
  haircut_woman: "💇‍♀️",
  walking: "🚶",
  walking_man: "🚶‍♂️",
  walking_woman: "🚶‍♀️",
  standing_person: "🧍",
  standing_man: "🧍‍♂️",
  standing_woman: "🧍‍♀️",
  kneeling_person: "🧎",
  kneeling_man: "🧎‍♂️",
  kneeling_woman: "🧎‍♀️",
  person_with_probing_cane: "🧑‍🦯",
  man_with_probing_cane: "👨‍🦯",
  woman_with_probing_cane: "👩‍🦯",
  person_in_motorized_wheelchair: "🧑‍🦼",
  man_in_motorized_wheelchair: "👨‍🦼",
  woman_in_motorized_wheelchair: "👩‍🦼",
  person_in_manual_wheelchair: "🧑‍🦽",
  man_in_manual_wheelchair: "👨‍🦽",
  woman_in_manual_wheelchair: "👩‍🦽",
  runner: "🏃",
  running: "🏃",
  running_man: "🏃‍♂️",
  running_woman: "🏃‍♀️",
  woman_dancing: "💃",
  dancer: "💃",
  man_dancing: "🕺",
  business_suit_levitating: "🕴️",
  dancers: "👯",
  dancing_men: "👯‍♂️",
  dancing_women: "👯‍♀️",
  sauna_person: "🧖",
  sauna_man: "🧖‍♂️",
  sauna_woman: "🧖‍♀️",
  climbing: "🧗",
  climbing_man: "🧗‍♂️",
  climbing_woman: "🧗‍♀️",
  person_fencing: "🤺",
  horse_racing: "🏇",
  skier: "⛷️",
  snowboarder: "🏂",
  golfing: "🏌️",
  golfing_man: "🏌️‍♂️",
  golfing_woman: "🏌️‍♀️",
  surfer: "🏄",
  surfing_man: "🏄‍♂️",
  surfing_woman: "🏄‍♀️",
  rowboat: "🚣",
  rowing_man: "🚣‍♂️",
  rowing_woman: "🚣‍♀️",
  swimmer: "🏊",
  swimming_man: "🏊‍♂️",
  swimming_woman: "🏊‍♀️",
  bouncing_ball_person: "⛹️",
  bouncing_ball_man: "⛹️‍♂️",
  basketball_man: "⛹️‍♂️",
  bouncing_ball_woman: "⛹️‍♀️",
  basketball_woman: "⛹️‍♀️",
  weight_lifting: "🏋️",
  weight_lifting_man: "🏋️‍♂️",
  weight_lifting_woman: "🏋️‍♀️",
  bicyclist: "🚴",
  biking_man: "🚴‍♂️",
  biking_woman: "🚴‍♀️",
  mountain_bicyclist: "🚵",
  mountain_biking_man: "🚵‍♂️",
  mountain_biking_woman: "🚵‍♀️",
  cartwheeling: "🤸",
  man_cartwheeling: "🤸‍♂️",
  woman_cartwheeling: "🤸‍♀️",
  wrestling: "🤼",
  men_wrestling: "🤼‍♂️",
  women_wrestling: "🤼‍♀️",
  water_polo: "🤽",
  man_playing_water_polo: "🤽‍♂️",
  woman_playing_water_polo: "🤽‍♀️",
  handball_person: "🤾",
  man_playing_handball: "🤾‍♂️",
  woman_playing_handball: "🤾‍♀️",
  juggling_person: "🤹",
  man_juggling: "🤹‍♂️",
  woman_juggling: "🤹‍♀️",
  lotus_position: "🧘",
  lotus_position_man: "🧘‍♂️",
  lotus_position_woman: "🧘‍♀️",
  bath: "🛀",
  sleeping_bed: "🛌",
  people_holding_hands: "🧑‍🤝‍🧑",
  two_women_holding_hands: "👭",
  couple: "👫",
  two_men_holding_hands: "👬",
  couplekiss: "💏",
  couplekiss_man_woman: "👩‍❤️‍💋‍👨",
  couplekiss_man_man: "👨‍❤️‍💋‍👨",
  couplekiss_woman_woman: "👩‍❤️‍💋‍👩",
  couple_with_heart: "💑",
  couple_with_heart_woman_man: "👩‍❤️‍👨",
  couple_with_heart_man_man: "👨‍❤️‍👨",
  couple_with_heart_woman_woman: "👩‍❤️‍👩",
  family: "👪",
  family_man_woman_boy: "👨‍👩‍👦",
  family_man_woman_girl: "👨‍👩‍👧",
  family_man_woman_girl_boy: "👨‍👩‍👧‍👦",
  family_man_woman_boy_boy: "👨‍👩‍👦‍👦",
  family_man_woman_girl_girl: "👨‍👩‍👧‍👧",
  family_man_man_boy: "👨‍👨‍👦",
  family_man_man_girl: "👨‍👨‍👧",
  family_man_man_girl_boy: "👨‍👨‍👧‍👦",
  family_man_man_boy_boy: "👨‍👨‍👦‍👦",
  family_man_man_girl_girl: "👨‍👨‍👧‍👧",
  family_woman_woman_boy: "👩‍👩‍👦",
  family_woman_woman_girl: "👩‍👩‍👧",
  family_woman_woman_girl_boy: "👩‍👩‍👧‍👦",
  family_woman_woman_boy_boy: "👩‍👩‍👦‍👦",
  family_woman_woman_girl_girl: "👩‍👩‍👧‍👧",
  family_man_boy: "👨‍👦",
  family_man_boy_boy: "👨‍👦‍👦",
  family_man_girl: "👨‍👧",
  family_man_girl_boy: "👨‍👧‍👦",
  family_man_girl_girl: "👨‍👧‍👧",
  family_woman_boy: "👩‍👦",
  family_woman_boy_boy: "👩‍👦‍👦",
  family_woman_girl: "👩‍👧",
  family_woman_girl_boy: "👩‍👧‍👦",
  family_woman_girl_girl: "👩‍👧‍👧",
  speaking_head: "🗣️",
  bust_in_silhouette: "👤",
  busts_in_silhouette: "👥",
  people_hugging: "🫂",
  footprints: "👣",
  monkey_face: "🐵",
  monkey: "🐒",
  gorilla: "🦍",
  orangutan: "🦧",
  dog: "🐶",
  dog2: "🐕",
  guide_dog: "🦮",
  service_dog: "🐕‍🦺",
  poodle: "🐩",
  wolf: "🐺",
  fox_face: "🦊",
  raccoon: "🦝",
  cat: "🐱",
  cat2: "🐈",
  black_cat: "🐈‍⬛",
  lion: "🦁",
  tiger: "🐯",
  tiger2: "🐅",
  leopard: "🐆",
  horse: "🐴",
  moose: "🫎",
  donkey: "🫏",
  racehorse: "🐎",
  unicorn: "🦄",
  zebra: "🦓",
  deer: "🦌",
  bison: "🦬",
  cow: "🐮",
  ox: "🐂",
  water_buffalo: "🐃",
  cow2: "🐄",
  pig: "🐷",
  pig2: "🐖",
  boar: "🐗",
  pig_nose: "🐽",
  ram: "🐏",
  sheep: "🐑",
  goat: "🐐",
  dromedary_camel: "🐪",
  camel: "🐫",
  llama: "🦙",
  giraffe: "🦒",
  elephant: "🐘",
  mammoth: "🦣",
  rhinoceros: "🦏",
  hippopotamus: "🦛",
  mouse: "🐭",
  mouse2: "🐁",
  rat: "🐀",
  hamster: "🐹",
  rabbit: "🐰",
  rabbit2: "🐇",
  chipmunk: "🐿️",
  beaver: "🦫",
  hedgehog: "🦔",
  bat: "🦇",
  bear: "🐻",
  polar_bear: "🐻‍❄️",
  koala: "🐨",
  panda_face: "🐼",
  sloth: "🦥",
  otter: "🦦",
  skunk: "🦨",
  kangaroo: "🦘",
  badger: "🦡",
  feet: "🐾",
  paw_prints: "🐾",
  turkey: "🦃",
  chicken: "🐔",
  rooster: "🐓",
  hatching_chick: "🐣",
  baby_chick: "🐤",
  hatched_chick: "🐥",
  bird: "🐦",
  penguin: "🐧",
  dove: "🕊️",
  eagle: "🦅",
  duck: "🦆",
  swan: "🦢",
  owl: "🦉",
  dodo: "🦤",
  feather: "🪶",
  flamingo: "🦩",
  peacock: "🦚",
  parrot: "🦜",
  wing: "🪽",
  black_bird: "🐦‍⬛",
  goose: "🪿",
  frog: "🐸",
  crocodile: "🐊",
  turtle: "🐢",
  lizard: "🦎",
  snake: "🐍",
  dragon_face: "🐲",
  dragon: "🐉",
  sauropod: "🦕",
  "t-rex": "🦖",
  whale: "🐳",
  whale2: "🐋",
  dolphin: "🐬",
  flipper: "🐬",
  seal: "🦭",
  fish: "🐟",
  tropical_fish: "🐠",
  blowfish: "🐡",
  shark: "🦈",
  octopus: "🐙",
  shell: "🐚",
  coral: "🪸",
  jellyfish: "🪼",
  snail: "🐌",
  butterfly: "🦋",
  bug: "🐛",
  ant: "🐜",
  bee: "🐝",
  honeybee: "🐝",
  beetle: "🪲",
  lady_beetle: "🐞",
  cricket: "🦗",
  cockroach: "🪳",
  spider: "🕷️",
  spider_web: "🕸️",
  scorpion: "🦂",
  mosquito: "🦟",
  fly: "🪰",
  worm: "🪱",
  microbe: "🦠",
  bouquet: "💐",
  cherry_blossom: "🌸",
  white_flower: "💮",
  lotus: "🪷",
  rosette: "🏵️",
  rose: "🌹",
  wilted_flower: "🥀",
  hibiscus: "🌺",
  sunflower: "🌻",
  blossom: "🌼",
  tulip: "🌷",
  hyacinth: "🪻",
  seedling: "🌱",
  potted_plant: "🪴",
  evergreen_tree: "🌲",
  deciduous_tree: "🌳",
  palm_tree: "🌴",
  cactus: "🌵",
  ear_of_rice: "🌾",
  herb: "🌿",
  shamrock: "☘️",
  four_leaf_clover: "🍀",
  maple_leaf: "🍁",
  fallen_leaf: "🍂",
  leaves: "🍃",
  empty_nest: "🪹",
  nest_with_eggs: "🪺",
  mushroom: "🍄",
  grapes: "🍇",
  melon: "🍈",
  watermelon: "🍉",
  tangerine: "🍊",
  orange: "🍊",
  mandarin: "🍊",
  lemon: "🍋",
  banana: "🍌",
  pineapple: "🍍",
  mango: "🥭",
  apple: "🍎",
  green_apple: "🍏",
  pear: "🍐",
  peach: "🍑",
  cherries: "🍒",
  strawberry: "🍓",
  blueberries: "🫐",
  kiwi_fruit: "🥝",
  tomato: "🍅",
  olive: "🫒",
  coconut: "🥥",
  avocado: "🥑",
  eggplant: "🍆",
  potato: "🥔",
  carrot: "🥕",
  corn: "🌽",
  hot_pepper: "🌶️",
  bell_pepper: "🫑",
  cucumber: "🥒",
  leafy_green: "🥬",
  broccoli: "🥦",
  garlic: "🧄",
  onion: "🧅",
  peanuts: "🥜",
  beans: "🫘",
  chestnut: "🌰",
  ginger_root: "🫚",
  pea_pod: "🫛",
  bread: "🍞",
  croissant: "🥐",
  baguette_bread: "🥖",
  flatbread: "🫓",
  pretzel: "🥨",
  bagel: "🥯",
  pancakes: "🥞",
  waffle: "🧇",
  cheese: "🧀",
  meat_on_bone: "🍖",
  poultry_leg: "🍗",
  cut_of_meat: "🥩",
  bacon: "🥓",
  hamburger: "🍔",
  fries: "🍟",
  pizza: "🍕",
  hotdog: "🌭",
  sandwich: "🥪",
  taco: "🌮",
  burrito: "🌯",
  tamale: "🫔",
  stuffed_flatbread: "🥙",
  falafel: "🧆",
  egg: "🥚",
  fried_egg: "🍳",
  shallow_pan_of_food: "🥘",
  stew: "🍲",
  fondue: "🫕",
  bowl_with_spoon: "🥣",
  green_salad: "🥗",
  popcorn: "🍿",
  butter: "🧈",
  salt: "🧂",
  canned_food: "🥫",
  bento: "🍱",
  rice_cracker: "🍘",
  rice_ball: "🍙",
  rice: "🍚",
  curry: "🍛",
  ramen: "🍜",
  spaghetti: "🍝",
  sweet_potato: "🍠",
  oden: "🍢",
  sushi: "🍣",
  fried_shrimp: "🍤",
  fish_cake: "🍥",
  moon_cake: "🥮",
  dango: "🍡",
  dumpling: "🥟",
  fortune_cookie: "🥠",
  takeout_box: "🥡",
  crab: "🦀",
  lobster: "🦞",
  shrimp: "🦐",
  squid: "🦑",
  oyster: "🦪",
  icecream: "🍦",
  shaved_ice: "🍧",
  ice_cream: "🍨",
  doughnut: "🍩",
  cookie: "🍪",
  birthday: "🎂",
  cake: "🍰",
  cupcake: "🧁",
  pie: "🥧",
  chocolate_bar: "🍫",
  candy: "🍬",
  lollipop: "🍭",
  custard: "🍮",
  honey_pot: "🍯",
  baby_bottle: "🍼",
  milk_glass: "🥛",
  coffee: "☕",
  teapot: "🫖",
  tea: "🍵",
  sake: "🍶",
  champagne: "🍾",
  wine_glass: "🍷",
  cocktail: "🍸",
  tropical_drink: "🍹",
  beer: "🍺",
  beers: "🍻",
  clinking_glasses: "🥂",
  tumbler_glass: "🥃",
  pouring_liquid: "🫗",
  cup_with_straw: "🥤",
  bubble_tea: "🧋",
  beverage_box: "🧃",
  mate: "🧉",
  ice_cube: "🧊",
  chopsticks: "🥢",
  plate_with_cutlery: "🍽️",
  fork_and_knife: "🍴",
  spoon: "🥄",
  hocho: "🔪",
  knife: "🔪",
  jar: "🫙",
  amphora: "🏺",
  earth_africa: "🌍",
  earth_americas: "🌎",
  earth_asia: "🌏",
  globe_with_meridians: "🌐",
  world_map: "🗺️",
  japan: "🗾",
  compass: "🧭",
  mountain_snow: "🏔️",
  mountain: "⛰️",
  volcano: "🌋",
  mount_fuji: "🗻",
  camping: "🏕️",
  beach_umbrella: "🏖️",
  desert: "🏜️",
  desert_island: "🏝️",
  national_park: "🏞️",
  stadium: "🏟️",
  classical_building: "🏛️",
  building_construction: "🏗️",
  bricks: "🧱",
  rock: "🪨",
  wood: "🪵",
  hut: "🛖",
  houses: "🏘️",
  derelict_house: "🏚️",
  house: "🏠",
  house_with_garden: "🏡",
  office: "🏢",
  post_office: "🏣",
  european_post_office: "🏤",
  hospital: "🏥",
  bank: "🏦",
  hotel: "🏨",
  love_hotel: "🏩",
  convenience_store: "🏪",
  school: "🏫",
  department_store: "🏬",
  factory: "🏭",
  japanese_castle: "🏯",
  european_castle: "🏰",
  wedding: "💒",
  tokyo_tower: "🗼",
  statue_of_liberty: "🗽",
  church: "⛪",
  mosque: "🕌",
  hindu_temple: "🛕",
  synagogue: "🕍",
  shinto_shrine: "⛩️",
  kaaba: "🕋",
  fountain: "⛲",
  tent: "⛺",
  foggy: "🌁",
  night_with_stars: "🌃",
  cityscape: "🏙️",
  sunrise_over_mountains: "🌄",
  sunrise: "🌅",
  city_sunset: "🌆",
  city_sunrise: "🌇",
  bridge_at_night: "🌉",
  hotsprings: "♨️",
  carousel_horse: "🎠",
  playground_slide: "🛝",
  ferris_wheel: "🎡",
  roller_coaster: "🎢",
  barber: "💈",
  circus_tent: "🎪",
  steam_locomotive: "🚂",
  railway_car: "🚃",
  bullettrain_side: "🚄",
  bullettrain_front: "🚅",
  train2: "🚆",
  metro: "🚇",
  light_rail: "🚈",
  station: "🚉",
  tram: "🚊",
  monorail: "🚝",
  mountain_railway: "🚞",
  train: "🚋",
  bus: "🚌",
  oncoming_bus: "🚍",
  trolleybus: "🚎",
  minibus: "🚐",
  ambulance: "🚑",
  fire_engine: "🚒",
  police_car: "🚓",
  oncoming_police_car: "🚔",
  taxi: "🚕",
  oncoming_taxi: "🚖",
  car: "🚗",
  red_car: "🚗",
  oncoming_automobile: "🚘",
  blue_car: "🚙",
  pickup_truck: "🛻",
  truck: "🚚",
  articulated_lorry: "🚛",
  tractor: "🚜",
  racing_car: "🏎️",
  motorcycle: "🏍️",
  motor_scooter: "🛵",
  manual_wheelchair: "🦽",
  motorized_wheelchair: "🦼",
  auto_rickshaw: "🛺",
  bike: "🚲",
  kick_scooter: "🛴",
  skateboard: "🛹",
  roller_skate: "🛼",
  busstop: "🚏",
  motorway: "🛣️",
  railway_track: "🛤️",
  oil_drum: "🛢️",
  fuelpump: "⛽",
  wheel: "🛞",
  rotating_light: "🚨",
  traffic_light: "🚥",
  vertical_traffic_light: "🚦",
  stop_sign: "🛑",
  construction: "🚧",
  anchor: "⚓",
  ring_buoy: "🛟",
  boat: "⛵",
  sailboat: "⛵",
  canoe: "🛶",
  speedboat: "🚤",
  passenger_ship: "🛳️",
  ferry: "⛴️",
  motor_boat: "🛥️",
  ship: "🚢",
  airplane: "✈️",
  small_airplane: "🛩️",
  flight_departure: "🛫",
  flight_arrival: "🛬",
  parachute: "🪂",
  seat: "💺",
  helicopter: "🚁",
  suspension_railway: "🚟",
  mountain_cableway: "🚠",
  aerial_tramway: "🚡",
  artificial_satellite: "🛰️",
  rocket: "🚀",
  flying_saucer: "🛸",
  bellhop_bell: "🛎️",
  luggage: "🧳",
  hourglass: "⌛",
  hourglass_flowing_sand: "⏳",
  watch: "⌚",
  alarm_clock: "⏰",
  stopwatch: "⏱️",
  timer_clock: "⏲️",
  mantelpiece_clock: "🕰️",
  clock12: "🕛",
  clock1230: "🕧",
  clock1: "🕐",
  clock130: "🕜",
  clock2: "🕑",
  clock230: "🕝",
  clock3: "🕒",
  clock330: "🕞",
  clock4: "🕓",
  clock430: "🕟",
  clock5: "🕔",
  clock530: "🕠",
  clock6: "🕕",
  clock630: "🕡",
  clock7: "🕖",
  clock730: "🕢",
  clock8: "🕗",
  clock830: "🕣",
  clock9: "🕘",
  clock930: "🕤",
  clock10: "🕙",
  clock1030: "🕥",
  clock11: "🕚",
  clock1130: "🕦",
  new_moon: "🌑",
  waxing_crescent_moon: "🌒",
  first_quarter_moon: "🌓",
  moon: "🌔",
  waxing_gibbous_moon: "🌔",
  full_moon: "🌕",
  waning_gibbous_moon: "🌖",
  last_quarter_moon: "🌗",
  waning_crescent_moon: "🌘",
  crescent_moon: "🌙",
  new_moon_with_face: "🌚",
  first_quarter_moon_with_face: "🌛",
  last_quarter_moon_with_face: "🌜",
  thermometer: "🌡️",
  sunny: "☀️",
  full_moon_with_face: "🌝",
  sun_with_face: "🌞",
  ringed_planet: "🪐",
  star: "⭐",
  star2: "🌟",
  stars: "🌠",
  milky_way: "🌌",
  cloud: "☁️",
  partly_sunny: "⛅",
  cloud_with_lightning_and_rain: "⛈️",
  sun_behind_small_cloud: "🌤️",
  sun_behind_large_cloud: "🌥️",
  sun_behind_rain_cloud: "🌦️",
  cloud_with_rain: "🌧️",
  cloud_with_snow: "🌨️",
  cloud_with_lightning: "🌩️",
  tornado: "🌪️",
  fog: "🌫️",
  wind_face: "🌬️",
  cyclone: "🌀",
  rainbow: "🌈",
  closed_umbrella: "🌂",
  open_umbrella: "☂️",
  umbrella: "☔",
  parasol_on_ground: "⛱️",
  zap: "⚡",
  snowflake: "❄️",
  snowman_with_snow: "☃️",
  snowman: "⛄",
  comet: "☄️",
  fire: "🔥",
  droplet: "💧",
  ocean: "🌊",
  jack_o_lantern: "🎃",
  christmas_tree: "🎄",
  fireworks: "🎆",
  sparkler: "🎇",
  firecracker: "🧨",
  sparkles: "✨",
  balloon: "🎈",
  tada: "🎉",
  confetti_ball: "🎊",
  tanabata_tree: "🎋",
  bamboo: "🎍",
  dolls: "🎎",
  flags: "🎏",
  wind_chime: "🎐",
  rice_scene: "🎑",
  red_envelope: "🧧",
  ribbon: "🎀",
  gift: "🎁",
  reminder_ribbon: "🎗️",
  tickets: "🎟️",
  ticket: "🎫",
  medal_military: "🎖️",
  trophy: "🏆",
  medal_sports: "🏅",
  "1st_place_medal": "🥇",
  "2nd_place_medal": "🥈",
  "3rd_place_medal": "🥉",
  soccer: "⚽",
  baseball: "⚾",
  softball: "🥎",
  basketball: "🏀",
  volleyball: "🏐",
  football: "🏈",
  rugby_football: "🏉",
  tennis: "🎾",
  flying_disc: "🥏",
  bowling: "🎳",
  cricket_game: "🏏",
  field_hockey: "🏑",
  ice_hockey: "🏒",
  lacrosse: "🥍",
  ping_pong: "🏓",
  badminton: "🏸",
  boxing_glove: "🥊",
  martial_arts_uniform: "🥋",
  goal_net: "🥅",
  golf: "⛳",
  ice_skate: "⛸️",
  fishing_pole_and_fish: "🎣",
  diving_mask: "🤿",
  running_shirt_with_sash: "🎽",
  ski: "🎿",
  sled: "🛷",
  curling_stone: "🥌",
  dart: "🎯",
  yo_yo: "🪀",
  kite: "🪁",
  gun: "🔫",
  "8ball": "🎱",
  crystal_ball: "🔮",
  magic_wand: "🪄",
  video_game: "🎮",
  joystick: "🕹️",
  slot_machine: "🎰",
  game_die: "🎲",
  jigsaw: "🧩",
  teddy_bear: "🧸",
  pinata: "🪅",
  mirror_ball: "🪩",
  nesting_dolls: "🪆",
  spades: "♠️",
  hearts: "♥️",
  diamonds: "♦️",
  clubs: "♣️",
  chess_pawn: "♟️",
  black_joker: "🃏",
  mahjong: "🀄",
  flower_playing_cards: "🎴",
  performing_arts: "🎭",
  framed_picture: "🖼️",
  art: "🎨",
  thread: "🧵",
  sewing_needle: "🪡",
  yarn: "🧶",
  knot: "🪢",
  eyeglasses: "👓",
  dark_sunglasses: "🕶️",
  goggles: "🥽",
  lab_coat: "🥼",
  safety_vest: "🦺",
  necktie: "👔",
  shirt: "👕",
  tshirt: "👕",
  jeans: "👖",
  scarf: "🧣",
  gloves: "🧤",
  coat: "🧥",
  socks: "🧦",
  dress: "👗",
  kimono: "👘",
  sari: "🥻",
  one_piece_swimsuit: "🩱",
  swim_brief: "🩲",
  shorts: "🩳",
  bikini: "👙",
  womans_clothes: "👚",
  folding_hand_fan: "🪭",
  purse: "👛",
  handbag: "👜",
  pouch: "👝",
  shopping: "🛍️",
  school_satchel: "🎒",
  thong_sandal: "🩴",
  mans_shoe: "👞",
  shoe: "👞",
  athletic_shoe: "👟",
  hiking_boot: "🥾",
  flat_shoe: "🥿",
  high_heel: "👠",
  sandal: "👡",
  ballet_shoes: "🩰",
  boot: "👢",
  hair_pick: "🪮",
  crown: "👑",
  womans_hat: "👒",
  tophat: "🎩",
  mortar_board: "🎓",
  billed_cap: "🧢",
  military_helmet: "🪖",
  rescue_worker_helmet: "⛑️",
  prayer_beads: "📿",
  lipstick: "💄",
  ring: "💍",
  gem: "💎",
  mute: "🔇",
  speaker: "🔈",
  sound: "🔉",
  loud_sound: "🔊",
  loudspeaker: "📢",
  mega: "📣",
  postal_horn: "📯",
  bell: "🔔",
  no_bell: "🔕",
  musical_score: "🎼",
  musical_note: "🎵",
  notes: "🎶",
  studio_microphone: "🎙️",
  level_slider: "🎚️",
  control_knobs: "🎛️",
  microphone: "🎤",
  headphones: "🎧",
  radio: "📻",
  saxophone: "🎷",
  accordion: "🪗",
  guitar: "🎸",
  musical_keyboard: "🎹",
  trumpet: "🎺",
  violin: "🎻",
  banjo: "🪕",
  drum: "🥁",
  long_drum: "🪘",
  maracas: "🪇",
  flute: "🪈",
  iphone: "📱",
  calling: "📲",
  phone: "☎️",
  telephone: "☎️",
  telephone_receiver: "📞",
  pager: "📟",
  fax: "📠",
  battery: "🔋",
  low_battery: "🪫",
  electric_plug: "🔌",
  computer: "💻",
  desktop_computer: "🖥️",
  printer: "🖨️",
  keyboard: "⌨️",
  computer_mouse: "🖱️",
  trackball: "🖲️",
  minidisc: "💽",
  floppy_disk: "💾",
  cd: "💿",
  dvd: "📀",
  abacus: "🧮",
  movie_camera: "🎥",
  film_strip: "🎞️",
  film_projector: "📽️",
  clapper: "🎬",
  tv: "📺",
  camera: "📷",
  camera_flash: "📸",
  video_camera: "📹",
  vhs: "📼",
  mag: "🔍",
  mag_right: "🔎",
  candle: "🕯️",
  bulb: "💡",
  flashlight: "🔦",
  izakaya_lantern: "🏮",
  lantern: "🏮",
  diya_lamp: "🪔",
  notebook_with_decorative_cover: "📔",
  closed_book: "📕",
  book: "📖",
  open_book: "📖",
  green_book: "📗",
  blue_book: "📘",
  orange_book: "📙",
  books: "📚",
  notebook: "📓",
  ledger: "📒",
  page_with_curl: "📃",
  scroll: "📜",
  page_facing_up: "📄",
  newspaper: "📰",
  newspaper_roll: "🗞️",
  bookmark_tabs: "📑",
  bookmark: "🔖",
  label: "🏷️",
  moneybag: "💰",
  coin: "🪙",
  yen: "💴",
  dollar: "💵",
  euro: "💶",
  pound: "💷",
  money_with_wings: "💸",
  credit_card: "💳",
  receipt: "🧾",
  chart: "💹",
  envelope: "✉️",
  email: "📧",
  "e-mail": "📧",
  incoming_envelope: "📨",
  envelope_with_arrow: "📩",
  outbox_tray: "📤",
  inbox_tray: "📥",
  package: "📦",
  mailbox: "📫",
  mailbox_closed: "📪",
  mailbox_with_mail: "📬",
  mailbox_with_no_mail: "📭",
  postbox: "📮",
  ballot_box: "🗳️",
  pencil2: "✏️",
  black_nib: "✒️",
  fountain_pen: "🖋️",
  pen: "🖊️",
  paintbrush: "🖌️",
  crayon: "🖍️",
  memo: "📝",
  pencil: "📝",
  briefcase: "💼",
  file_folder: "📁",
  open_file_folder: "📂",
  card_index_dividers: "🗂️",
  date: "📅",
  calendar: "📆",
  spiral_notepad: "🗒️",
  spiral_calendar: "🗓️",
  card_index: "📇",
  chart_with_upwards_trend: "📈",
  chart_with_downwards_trend: "📉",
  bar_chart: "📊",
  clipboard: "📋",
  pushpin: "📌",
  round_pushpin: "📍",
  paperclip: "📎",
  paperclips: "🖇️",
  straight_ruler: "📏",
  triangular_ruler: "📐",
  scissors: "✂️",
  card_file_box: "🗃️",
  file_cabinet: "🗄️",
  wastebasket: "🗑️",
  lock: "🔒",
  unlock: "🔓",
  lock_with_ink_pen: "🔏",
  closed_lock_with_key: "🔐",
  key: "🔑",
  old_key: "🗝️",
  hammer: "🔨",
  axe: "🪓",
  pick: "⛏️",
  hammer_and_pick: "⚒️",
  hammer_and_wrench: "🛠️",
  dagger: "🗡️",
  crossed_swords: "⚔️",
  bomb: "💣",
  boomerang: "🪃",
  bow_and_arrow: "🏹",
  shield: "🛡️",
  carpentry_saw: "🪚",
  wrench: "🔧",
  screwdriver: "🪛",
  nut_and_bolt: "🔩",
  gear: "⚙️",
  clamp: "🗜️",
  balance_scale: "⚖️",
  probing_cane: "🦯",
  link: "🔗",
  chains: "⛓️",
  hook: "🪝",
  toolbox: "🧰",
  magnet: "🧲",
  ladder: "🪜",
  alembic: "⚗️",
  test_tube: "🧪",
  petri_dish: "🧫",
  dna: "🧬",
  microscope: "🔬",
  telescope: "🔭",
  satellite: "📡",
  syringe: "💉",
  drop_of_blood: "🩸",
  pill: "💊",
  adhesive_bandage: "🩹",
  crutch: "🩼",
  stethoscope: "🩺",
  x_ray: "🩻",
  door: "🚪",
  elevator: "🛗",
  mirror: "🪞",
  window: "🪟",
  bed: "🛏️",
  couch_and_lamp: "🛋️",
  chair: "🪑",
  toilet: "🚽",
  plunger: "🪠",
  shower: "🚿",
  bathtub: "🛁",
  mouse_trap: "🪤",
  razor: "🪒",
  lotion_bottle: "🧴",
  safety_pin: "🧷",
  broom: "🧹",
  basket: "🧺",
  roll_of_paper: "🧻",
  bucket: "🪣",
  soap: "🧼",
  bubbles: "🫧",
  toothbrush: "🪥",
  sponge: "🧽",
  fire_extinguisher: "🧯",
  shopping_cart: "🛒",
  smoking: "🚬",
  coffin: "⚰️",
  headstone: "🪦",
  funeral_urn: "⚱️",
  nazar_amulet: "🧿",
  hamsa: "🪬",
  moyai: "🗿",
  placard: "🪧",
  identification_card: "🪪",
  atm: "🏧",
  put_litter_in_its_place: "🚮",
  potable_water: "🚰",
  wheelchair: "♿",
  mens: "🚹",
  womens: "🚺",
  restroom: "🚻",
  baby_symbol: "🚼",
  wc: "🚾",
  passport_control: "🛂",
  customs: "🛃",
  baggage_claim: "🛄",
  left_luggage: "🛅",
  warning: "⚠️",
  children_crossing: "🚸",
  no_entry: "⛔",
  no_entry_sign: "🚫",
  no_bicycles: "🚳",
  no_smoking: "🚭",
  do_not_litter: "🚯",
  "non-potable_water": "🚱",
  no_pedestrians: "🚷",
  no_mobile_phones: "📵",
  underage: "🔞",
  radioactive: "☢️",
  biohazard: "☣️",
  arrow_up: "⬆️",
  arrow_upper_right: "↗️",
  arrow_right: "➡️",
  arrow_lower_right: "↘️",
  arrow_down: "⬇️",
  arrow_lower_left: "↙️",
  arrow_left: "⬅️",
  arrow_upper_left: "↖️",
  arrow_up_down: "↕️",
  left_right_arrow: "↔️",
  leftwards_arrow_with_hook: "↩️",
  arrow_right_hook: "↪️",
  arrow_heading_up: "⤴️",
  arrow_heading_down: "⤵️",
  arrows_clockwise: "🔃",
  arrows_counterclockwise: "🔄",
  back: "🔙",
  end: "🔚",
  on: "🔛",
  soon: "🔜",
  top: "🔝",
  place_of_worship: "🛐",
  atom_symbol: "⚛️",
  om: "🕉️",
  star_of_david: "✡️",
  wheel_of_dharma: "☸️",
  yin_yang: "☯️",
  latin_cross: "✝️",
  orthodox_cross: "☦️",
  star_and_crescent: "☪️",
  peace_symbol: "☮️",
  menorah: "🕎",
  six_pointed_star: "🔯",
  khanda: "🪯",
  aries: "♈",
  taurus: "♉",
  gemini: "♊",
  cancer: "♋",
  leo: "♌",
  virgo: "♍",
  libra: "♎",
  scorpius: "♏",
  sagittarius: "♐",
  capricorn: "♑",
  aquarius: "♒",
  pisces: "♓",
  ophiuchus: "⛎",
  twisted_rightwards_arrows: "🔀",
  repeat: "🔁",
  repeat_one: "🔂",
  arrow_forward: "▶️",
  fast_forward: "⏩",
  next_track_button: "⏭️",
  play_or_pause_button: "⏯️",
  arrow_backward: "◀️",
  rewind: "⏪",
  previous_track_button: "⏮️",
  arrow_up_small: "🔼",
  arrow_double_up: "⏫",
  arrow_down_small: "🔽",
  arrow_double_down: "⏬",
  pause_button: "⏸️",
  stop_button: "⏹️",
  record_button: "⏺️",
  eject_button: "⏏️",
  cinema: "🎦",
  low_brightness: "🔅",
  high_brightness: "🔆",
  signal_strength: "📶",
  wireless: "🛜",
  vibration_mode: "📳",
  mobile_phone_off: "📴",
  female_sign: "♀️",
  male_sign: "♂️",
  transgender_symbol: "⚧️",
  heavy_multiplication_x: "✖️",
  heavy_plus_sign: "➕",
  heavy_minus_sign: "➖",
  heavy_division_sign: "➗",
  heavy_equals_sign: "🟰",
  infinity: "♾️",
  bangbang: "‼️",
  interrobang: "⁉️",
  question: "❓",
  grey_question: "❔",
  grey_exclamation: "❕",
  exclamation: "❗",
  heavy_exclamation_mark: "❗",
  wavy_dash: "〰️",
  currency_exchange: "💱",
  heavy_dollar_sign: "💲",
  medical_symbol: "⚕️",
  recycle: "♻️",
  fleur_de_lis: "⚜️",
  trident: "🔱",
  name_badge: "📛",
  beginner: "🔰",
  o: "⭕",
  white_check_mark: "✅",
  ballot_box_with_check: "☑️",
  heavy_check_mark: "✔️",
  x: "❌",
  negative_squared_cross_mark: "❎",
  curly_loop: "➰",
  loop: "➿",
  part_alternation_mark: "〽️",
  eight_spoked_asterisk: "✳️",
  eight_pointed_black_star: "✴️",
  sparkle: "❇️",
  copyright: "©️",
  registered: "®️",
  tm: "™️",
  hash: "#️⃣",
  asterisk: "*️⃣",
  zero: "0️⃣",
  one: "1️⃣",
  two: "2️⃣",
  three: "3️⃣",
  four: "4️⃣",
  five: "5️⃣",
  six: "6️⃣",
  seven: "7️⃣",
  eight: "8️⃣",
  nine: "9️⃣",
  keycap_ten: "🔟",
  capital_abcd: "🔠",
  abcd: "🔡",
  symbols: "🔣",
  abc: "🔤",
  a: "🅰️",
  ab: "🆎",
  b: "🅱️",
  cl: "🆑",
  cool: "🆒",
  free: "🆓",
  information_source: "ℹ️",
  id: "🆔",
  m: "Ⓜ️",
  new: "🆕",
  ng: "🆖",
  o2: "🅾️",
  ok: "🆗",
  parking: "🅿️",
  sos: "🆘",
  up: "🆙",
  vs: "🆚",
  koko: "🈁",
  sa: "🈂️",
  ideograph_advantage: "🉐",
  accept: "🉑",
  congratulations: "㊗️",
  secret: "㊙️",
  u6e80: "🈵",
  red_circle: "🔴",
  orange_circle: "🟠",
  yellow_circle: "🟡",
  green_circle: "🟢",
  large_blue_circle: "🔵",
  purple_circle: "🟣",
  brown_circle: "🟤",
  black_circle: "⚫",
  white_circle: "⚪",
  red_square: "🟥",
  orange_square: "🟧",
  yellow_square: "🟨",
  green_square: "🟩",
  blue_square: "🟦",
  purple_square: "🟪",
  brown_square: "🟫",
  black_large_square: "⬛",
  white_large_square: "⬜",
  black_medium_square: "◼️",
  white_medium_square: "◻️",
  black_medium_small_square: "◾",
  white_medium_small_square: "◽",
  black_small_square: "▪️",
  white_small_square: "▫️",
  large_orange_diamond: "🔶",
  large_blue_diamond: "🔷",
  small_orange_diamond: "🔸",
  small_blue_diamond: "🔹",
  small_red_triangle: "🔺",
  small_red_triangle_down: "🔻",
  diamond_shape_with_a_dot_inside: "💠",
  radio_button: "🔘",
  white_square_button: "🔳",
  black_square_button: "🔲",
  checkered_flag: "🏁",
  triangular_flag_on_post: "🚩",
  crossed_flags: "🎌",
  black_flag: "🏴",
  white_flag: "🏳️",
  rainbow_flag: "🏳️‍🌈",
  transgender_flag: "🏳️‍⚧️",
  pirate_flag: "🏴‍☠️",
  ascension_island: "🇦🇨",
  andorra: "🇦🇩",
  united_arab_emirates: "🇦🇪",
  afghanistan: "🇦🇫",
  antigua_barbuda: "🇦🇬",
  anguilla: "🇦🇮",
  albania: "🇦🇱",
  armenia: "🇦🇲",
  angola: "🇦🇴",
  antarctica: "🇦🇶",
  argentina: "🇦🇷",
  american_samoa: "🇦🇸",
  austria: "🇦🇹",
  australia: "🇦🇺",
  aruba: "🇦🇼",
  aland_islands: "🇦🇽",
  azerbaijan: "🇦🇿",
  bosnia_herzegovina: "🇧🇦",
  barbados: "🇧🇧",
  bangladesh: "🇧🇩",
  belgium: "🇧🇪",
  burkina_faso: "🇧🇫",
  bulgaria: "🇧🇬",
  bahrain: "🇧🇭",
  burundi: "🇧🇮",
  benin: "🇧🇯",
  st_barthelemy: "🇧🇱",
  bermuda: "🇧🇲",
  brunei: "🇧🇳",
  bolivia: "🇧🇴",
  caribbean_netherlands: "🇧🇶",
  brazil: "🇧🇷",
  bahamas: "🇧🇸",
  bhutan: "🇧🇹",
  bouvet_island: "🇧🇻",
  botswana: "🇧🇼",
  belarus: "🇧🇾",
  belize: "🇧🇿",
  canada: "🇨🇦",
  cocos_islands: "🇨🇨",
  congo_kinshasa: "🇨🇩",
  central_african_republic: "🇨🇫",
  congo_brazzaville: "🇨🇬",
  switzerland: "🇨🇭",
  cote_divoire: "🇨🇮",
  cook_islands: "🇨🇰",
  chile: "🇨🇱",
  cameroon: "🇨🇲",
  cn: "🇨🇳",
  colombia: "🇨🇴",
  clipperton_island: "🇨🇵",
  costa_rica: "🇨🇷",
  cuba: "🇨🇺",
  cape_verde: "🇨🇻",
  curacao: "🇨🇼",
  christmas_island: "🇨🇽",
  cyprus: "🇨🇾",
  czech_republic: "🇨🇿",
  de: "🇩🇪",
  diego_garcia: "🇩🇬",
  djibouti: "🇩🇯",
  denmark: "🇩🇰",
  dominica: "🇩🇲",
  dominican_republic: "🇩🇴",
  algeria: "🇩🇿",
  ceuta_melilla: "🇪🇦",
  ecuador: "🇪🇨",
  estonia: "🇪🇪",
  egypt: "🇪🇬",
  western_sahara: "🇪🇭",
  eritrea: "🇪🇷",
  es: "🇪🇸",
  ethiopia: "🇪🇹",
  eu: "🇪🇺",
  european_union: "🇪🇺",
  finland: "🇫🇮",
  fiji: "🇫🇯",
  falkland_islands: "🇫🇰",
  micronesia: "🇫🇲",
  faroe_islands: "🇫🇴",
  fr: "🇫🇷",
  gabon: "🇬🇦",
  gb: "🇬🇧",
  uk: "🇬🇧",
  grenada: "🇬🇩",
  georgia: "🇬🇪",
  french_guiana: "🇬🇫",
  guernsey: "🇬🇬",
  ghana: "🇬🇭",
  gibraltar: "🇬🇮",
  greenland: "🇬🇱",
  gambia: "🇬🇲",
  guinea: "🇬🇳",
  guadeloupe: "🇬🇵",
  equatorial_guinea: "🇬🇶",
  greece: "🇬🇷",
  south_georgia_south_sandwich_islands: "🇬🇸",
  guatemala: "🇬🇹",
  guam: "🇬🇺",
  guinea_bissau: "🇬🇼",
  guyana: "🇬🇾",
  hong_kong: "🇭🇰",
  heard_mcdonald_islands: "🇭🇲",
  honduras: "🇭🇳",
  croatia: "🇭🇷",
  haiti: "🇭🇹",
  hungary: "🇭🇺",
  canary_islands: "🇮🇨",
  indonesia: "🇮🇩",
  ireland: "🇮🇪",
  israel: "🇮🇱",
  isle_of_man: "🇮🇲",
  india: "🇮🇳",
  british_indian_ocean_territory: "🇮🇴",
  iraq: "🇮🇶",
  iran: "🇮🇷",
  iceland: "🇮🇸",
  it: "🇮🇹",
  jersey: "🇯🇪",
  jamaica: "🇯🇲",
  jordan: "🇯🇴",
  jp: "🇯🇵",
  kenya: "🇰🇪",
  kyrgyzstan: "🇰🇬",
  cambodia: "🇰🇭",
  kiribati: "🇰🇮",
  comoros: "🇰🇲",
  st_kitts_nevis: "🇰🇳",
  north_korea: "🇰🇵",
  kr: "🇰🇷",
  kuwait: "🇰🇼",
  cayman_islands: "🇰🇾",
  kazakhstan: "🇰🇿",
  laos: "🇱🇦",
  lebanon: "🇱🇧",
  st_lucia: "🇱🇨",
  liechtenstein: "🇱🇮",
  sri_lanka: "🇱🇰",
  liberia: "🇱🇷",
  lesotho: "🇱🇸",
  lithuania: "🇱🇹",
  luxembourg: "🇱🇺",
  latvia: "🇱🇻",
  libya: "🇱🇾",
  morocco: "🇲🇦",
  monaco: "🇲🇨",
  moldova: "🇲🇩",
  montenegro: "🇲🇪",
  st_martin: "🇲🇫",
  madagascar: "🇲🇬",
  marshall_islands: "🇲🇭",
  macedonia: "🇲🇰",
  mali: "🇲🇱",
  myanmar: "🇲🇲",
  mongolia: "🇲🇳",
  macau: "🇲🇴",
  northern_mariana_islands: "🇲🇵",
  martinique: "🇲🇶",
  mauritania: "🇲🇷",
  montserrat: "🇲🇸",
  malta: "🇲🇹",
  mauritius: "🇲🇺",
  maldives: "🇲🇻",
  malawi: "🇲🇼",
  mexico: "🇲🇽",
  malaysia: "🇲🇾",
  mozambique: "🇲🇿",
  namibia: "🇳🇦",
  new_caledonia: "🇳🇨",
  niger: "🇳🇪",
  norfolk_island: "🇳🇫",
  nigeria: "🇳🇬",
  nicaragua: "🇳🇮",
  netherlands: "🇳🇱",
  norway: "🇳🇴",
  nepal: "🇳🇵",
  nauru: "🇳🇷",
  niue: "🇳🇺",
  new_zealand: "🇳🇿",
  oman: "🇴🇲",
  panama: "🇵🇦",
  peru: "🇵🇪",
  french_polynesia: "🇵🇫",
  papua_new_guinea: "🇵🇬",
  philippines: "🇵🇭",
  pakistan: "🇵🇰",
  poland: "🇵🇱",
  st_pierre_miquelon: "🇵🇲",
  pitcairn_islands: "🇵🇳",
  puerto_rico: "🇵🇷",
  palestinian_territories: "🇵🇸",
  portugal: "🇵🇹",
  palau: "🇵🇼",
  paraguay: "🇵🇾",
  qatar: "🇶🇦",
  reunion: "🇷🇪",
  romania: "🇷🇴",
  serbia: "🇷🇸",
  ru: "🇷🇺",
  rwanda: "🇷🇼",
  saudi_arabia: "🇸🇦",
  solomon_islands: "🇸🇧",
  seychelles: "🇸🇨",
  sudan: "🇸🇩",
  sweden: "🇸🇪",
  singapore: "🇸🇬",
  st_helena: "🇸🇭",
  slovenia: "🇸🇮",
  svalbard_jan_mayen: "🇸🇯",
  slovakia: "🇸🇰",
  sierra_leone: "🇸🇱",
  san_marino: "🇸🇲",
  senegal: "🇸🇳",
  somalia: "🇸🇴",
  suriname: "🇸🇷",
  south_sudan: "🇸🇸",
  sao_tome_principe: "🇸🇹",
  el_salvador: "🇸🇻",
  sint_maarten: "🇸🇽",
  syria: "🇸🇾",
  swaziland: "🇸🇿",
  tristan_da_cunha: "🇹🇦",
  turks_caicos_islands: "🇹🇨",
  chad: "🇹🇩",
  french_southern_territories: "🇹🇫",
  togo: "🇹🇬",
  thailand: "🇹🇭",
  tajikistan: "🇹🇯",
  tokelau: "🇹🇰",
  timor_leste: "🇹🇱",
  turkmenistan: "🇹🇲",
  tunisia: "🇹🇳",
  tonga: "🇹🇴",
  tr: "🇹🇷",
  trinidad_tobago: "🇹🇹",
  tuvalu: "🇹🇻",
  taiwan: "🇹🇼",
  tanzania: "🇹🇿",
  ukraine: "🇺🇦",
  uganda: "🇺🇬",
  us_outlying_islands: "🇺🇲",
  united_nations: "🇺🇳",
  us: "🇺🇸",
  uruguay: "🇺🇾",
  uzbekistan: "🇺🇿",
  vatican_city: "🇻🇦",
  st_vincent_grenadines: "🇻🇨",
  venezuela: "🇻🇪",
  british_virgin_islands: "🇻🇬",
  us_virgin_islands: "🇻🇮",
  vietnam: "🇻🇳",
  vanuatu: "🇻🇺",
  wallis_futuna: "🇼🇫",
  samoa: "🇼🇸",
  kosovo: "🇽🇰",
  yemen: "🇾🇪",
  mayotte: "🇾🇹",
  south_africa: "🇿🇦",
  zambia: "🇿🇲",
  zimbabwe: "🇿🇼",
  england: "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
  scotland: "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
  wales: "🏴󠁧󠁢󠁷󠁬󠁳󠁿"
};
function vs(e, t) {
  const n = {
    defs: Cs,
    shortcuts: ws,
    enabled: []
  }, u = e.utils.assign({}, n, t || {});
  xs(e, u);
}
function pt(e, t, n) {
  function u(f) {
    return f.trim().split(" ", 2)[0] === t;
  }
  function r(f, p, h, g, m) {
    return f[p].nesting === 1 && f[p].attrJoin("class", t), m.renderToken(f, p, h, g, m);
  }
  n = n || {};
  const i = 3, a = n.marker || ":", o = a.charCodeAt(0), s = a.length, l = n.validate || u, c = n.render || r;
  function d(f, p, h, g) {
    let m, b = !1, _ = f.bMarks[p] + f.tShift[p], y = f.eMarks[p];
    if (o !== f.src.charCodeAt(_))
      return !1;
    for (m = _ + 1; m <= y && a[(m - _) % s] === f.src[m]; m++)
      ;
    const x = Math.floor((m - _) / s);
    if (x < i)
      return !1;
    m -= (m - _) % s;
    const C = f.src.slice(_, m), v = f.src.slice(m, y);
    if (!l(v, C))
      return !1;
    if (g)
      return !0;
    let A = p;
    for (; A++, !(A >= h || (_ = f.bMarks[A] + f.tShift[A], y = f.eMarks[A], _ < y && f.sCount[A] < f.blkIndent)); )
      if (o === f.src.charCodeAt(_) && !(f.sCount[A] - f.blkIndent >= 4)) {
        for (m = _ + 1; m <= y && a[(m - _) % s] === f.src[m]; m++)
          ;
        if (!(Math.floor((m - _) / s) < x) && (m -= (m - _) % s, m = f.skipSpaces(m), !(m < y))) {
          b = !0;
          break;
        }
      }
    const S = f.parentType, L = f.lineMax;
    f.parentType = "container", f.lineMax = A;
    const M = f.push("container_" + t + "_open", "div", 1);
    M.markup = C, M.block = !0, M.info = v, M.map = [p, A], f.md.block.tokenize(f, p + 1, A);
    const Z = f.push("container_" + t + "_close", "div", -1);
    return Z.markup = f.src.slice(_, m), Z.block = !0, f.parentType = S, f.lineMax = L, f.line = A + (b ? 1 : 0), !0;
  }
  e.block.ruler.before("fence", "container_" + t, d, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), e.renderer.rules["container_" + t + "_open"] = c, e.renderer.rules["container_" + t + "_close"] = c;
}
let As = (e) => crypto.getRandomValues(new Uint8Array(e)), Es = (e, t, n) => {
  let u = (2 << Math.log(e.length - 1) / Math.LN2) - 1, r = -~(1.6 * u * t / e.length);
  return (i = t) => {
    let a = "";
    for (; ; ) {
      let o = n(r), s = r | 0;
      for (; s--; )
        if (a += e[o[s] & u] || "", a.length === i) return a;
    }
  };
}, Ss = (e, t = 21) => Es(e, t, As), fu = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
const ln = /^[a-z]+:/i, Ds = /^pathname:\/\//, Tn = Symbol("vue-md-shiki-component"), Fs = () => [
  "abap",
  "actionscript-3",
  "ada",
  "apache",
  "apex",
  "apl",
  "applescript",
  "ara",
  "asm",
  "astro",
  "awk",
  "ballerina",
  "bat",
  "batch",
  "berry",
  "be",
  "bibtex",
  "bicep",
  "blade",
  "c",
  "cadence",
  "cdc",
  "clarity",
  "clojure",
  "clj",
  "cmake",
  "cobol",
  "codeql",
  "ql",
  "coffee",
  "cpp",
  "c++",
  "crystal",
  "csharp",
  "c#",
  "cs",
  "css",
  "cue",
  "d",
  "dart",
  "dax",
  "diff",
  "docker",
  "dockerfile",
  "dream-maker",
  "elixir",
  "elm",
  "erb",
  "erlang",
  "erl",
  "fish",
  "fsharp",
  "f#",
  "fs",
  "gdresource",
  "gdscript",
  "gdshader",
  "gherkin",
  "git-commit",
  "git-rebase",
  "glsl",
  "gnuplot",
  "go",
  "golang",
  "graphql",
  "groovy",
  "hack",
  "haml",
  "handlebars",
  "hbs",
  "haskell",
  "hs",
  "hcl",
  "hlsl",
  "html",
  "http",
  "imba",
  "ini",
  "properties",
  "java",
  "javascript",
  "js",
  "jinja-html",
  "jison",
  "json",
  "json5",
  "jsonc",
  "jsonnet",
  "jssm",
  "fsl",
  "jsx",
  "julia",
  "kotlin",
  "kusto",
  "kql",
  "latex",
  "less",
  "liquid",
  "lisp",
  "logo",
  "lua",
  "make",
  "makefile",
  "markdown",
  "md",
  "marko",
  "matlab",
  "mdx",
  "mermaid",
  "nginx",
  "nim",
  "nix",
  "objective-c",
  "objc",
  "objective-cpp",
  "ocaml",
  "pascal",
  "perl",
  "php",
  "plsql",
  "postcss",
  "powerquery",
  "powershell",
  "ps",
  "ps1",
  "prisma",
  "prolog",
  "proto",
  "pug",
  "jade",
  "puppet",
  "purescript",
  "python",
  "py",
  "r",
  "raku",
  "perl6",
  "razor",
  "reg",
  "rel",
  "riscv",
  "rst",
  "ruby",
  "rb",
  "rust",
  "rs",
  "sas",
  "sass",
  "scala",
  "scheme",
  "scss",
  "shaderlab",
  "shader",
  "shellscript",
  "bash",
  "console",
  "sh",
  "shell",
  "zsh",
  "smalltalk",
  "solidity",
  "sparql",
  "sql",
  "ssh-config",
  "stata",
  "stylus",
  "styl",
  "svelte",
  "swift",
  "system-verilog",
  "tasl",
  "tcl",
  "tex",
  "toml",
  "tsx",
  "turtle",
  "twig",
  "typescript",
  "ts",
  "v",
  "vb",
  "cmd",
  "verilog",
  "vhdl",
  "viml",
  "vim",
  "vimscript",
  "vue-html",
  "vue",
  "wasm",
  "wenyan",
  "文言",
  "wgsl",
  "xml",
  "xsl",
  "yaml",
  "yml",
  "zenscript",
  ...Object.keys(dr)
], dr = {
  "c++": "cpp",
  "c#": "csharp",
  cs: "csharp",
  golang: "go"
};
function Ts(e) {
  const t = e.renderer.rules.fence;
  e.renderer.rules.fence = (...n) => {
    const [u, r] = n, i = u[r];
    i.info = i.info.replace(/\[.*\]/, "");
    let a = fr(i.info);
    Fs().includes(a) || (a = "plainText");
    const s = t(...n);
    return `<div class="language-${a}">${s}</div>`;
  };
}
function Rs(e) {
  var t;
  return ((t = e.match(/\[(.*)\]/)) == null ? void 0 : t[1]) || fr(e) || "txt";
}
const fr = (e) => e.trim().replace(/:(no-)?line-numbers({| |$).*/, "").replace(/(-vue|{| ).*$/, "").replace(/^vue-html$/, "template"), Ls = (e) => {
  e.use(...Me("tip", "TIP", e)).use(...Me("info", "INFO", e)).use(...Me("warning", "WARNING", e)).use(...Me("danger", "DANGER", e)).use(...Me("details", "Details", e)).use(pt, "v-pre", {
    render: (t, n) => t[n].nesting === 1 ? `<div v-pre>
` : `</div>
`
  }).use(pt, "raw", {
    render: (t, n) => t[n].nesting === 1 ? `<div class="vp-raw">
` : `</div>
`
  }).use(...Ps());
};
function Me(e, t, n) {
  return [
    pt,
    e,
    {
      render(u, r) {
        const i = u[r], a = i.info.trim().slice(e.length).trim();
        if (i.nesting === 1) {
          const o = n.renderInline(a || t);
          return e === "details" ? `<details class="${e} custom-block"><summary>${o}</summary>
` : `<div class="${e} custom-block"><p class="custom-block-title">${o}</p>
`;
        } else
          return e === "details" ? `</details>
` : `</div>
`;
      }
    }
  ];
}
function Ps() {
  return [
    pt,
    "code-group",
    {
      render(e, t) {
        if (e[t].nesting === 1) {
          const n = fu(5);
          let u = "", r = 'checked="checked"';
          for (let i = t + 1; !(e[i].nesting === -1 && e[i].type === "container_code-group_close"); ++i)
            if (e[i].type === "fence" && e[i].tag === "code") {
              const a = Rs(e[i].info), o = fu(7);
              u += `<input type="radio" name="group-${n}" id="tab-${o}" ${r}><label for="tab-${o}">${a}</label>`, r && (e[i].info += " active", r = "");
            }
          return `<div class="vp-code-group"><div class="tabs">${u}</div><div class="blocks">
`;
        }
        return `</div></div>
`;
      }
    }
  ];
}
const Rt = (e, t) => (n) => {
  const u = [], { code: r } = n;
  return {
    code: r,
    options: {
      transformLines: u,
      ...t || {}
    }
  };
};
function He(e, t, n) {
  const u = new RegExp(`<${n}[^>]*class="([\\w+-:;\\/* ]*)"`);
  return t = Array.isArray(t) ? t : [t], e.replace(u, (r, i) => r.replace(i, `${i} ${t}`));
}
function Ns(e = {}) {
  const t = e.commonDiffClass ?? "diff", n = e.removedLinesClasses ?? ["remove"], u = e.addedLinesClasses ?? ["add"], r = e.removeLineTag ?? "--", i = e.addLineTag ?? "++", a = e.hasDiffClass ?? "has-diff";
  return {
    name: "diff",
    handler: Rt(
      {
        [r]: [t, ...n],
        [i]: [t, ...u]
      },
      e
    ),
    postProcess: ({ code: o }) => o.includes(t) ? He(o, a, "pre") : o
  };
}
function Is(e = {}) {
  const t = e.hasFocusClass ?? "has-focus", n = e.hasFocusedLinesClass ?? "has-focused-lines";
  return e.focusTag, {
    name: "focus",
    handler: Rt(
      {},
      e
    ),
    postProcess: ({ code: u }) => u.includes(t) ? He(u, n, "pre") : u
  };
}
function Ms(e = {}) {
  const t = e.hasHighlightClass ?? "has-highlight", n = e.hasHighlightedLinesClass ?? "has-highlighted-lines";
  return e.highlightTag, {
    name: "highlight",
    handler: Rt({}, e),
    postProcess: ({ code: u }) => u.includes(t) ? He(u, n, "pre") : u
  };
}
function Os(e, t, n, u = {}) {
  const r = [], i = {
    code: t,
    language: n,
    options: u
  };
  for (const s of e)
    if (s.handler) {
      const l = s.handler(i);
      l && (Array.isArray(l) ? r.push(...l) : r.push(l));
    }
  let a = t, o = [];
  for (const s of r)
    if (s.code !== void 0 && (a = s.code), s.options && s.options.transformLines) {
      const l = s.options.transformLines;
      o = [...o, ...l];
    }
  return {
    code: a,
    lineOptions: o
  };
}
function Bs(e, t, n) {
  let u = t;
  for (const r of e)
    if (r.transformer) {
      const i = r.transformer(u, n, {});
      i && i.code && (u = i.code);
    }
  return u;
}
let j = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function js(e) {
  return Rn(e);
}
function Rn(e) {
  return Array.isArray(e) ? zs(e) : e instanceof RegExp ? e : typeof e == "object" ? $s(e) : e;
}
function zs(e) {
  let t = [];
  for (let n = 0, u = e.length; n < u; n++)
    t[n] = Rn(e[n]);
  return t;
}
function $s(e) {
  let t = {};
  for (let n in e)
    t[n] = Rn(e[n]);
  return t;
}
function hr(e, ...t) {
  return t.forEach((n) => {
    for (let u in n)
      e[u] = n[u];
  }), e;
}
function pr(e) {
  const t = ~e.lastIndexOf("/") || ~e.lastIndexOf("\\");
  return t === 0 ? e : ~t === e.length - 1 ? pr(e.substring(0, e.length - 1)) : e.substr(~t + 1);
}
var Wt = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, ut = class {
  static hasCaptures(e) {
    return e === null ? !1 : (Wt.lastIndex = 0, Wt.test(e));
  }
  static replaceCaptures(e, t, n) {
    return e.replace(Wt, (u, r, i, a) => {
      let o = n[parseInt(r || i, 10)];
      if (o) {
        let s = t.substring(o.start, o.end);
        for (; s[0] === "."; )
          s = s.substring(1);
        switch (a) {
          case "downcase":
            return s.toLowerCase();
          case "upcase":
            return s.toUpperCase();
          default:
            return s;
        }
      } else
        return u;
    });
  }
};
function mr(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function gr(e, t) {
  if (e === null && t === null)
    return 0;
  if (!e)
    return -1;
  if (!t)
    return 1;
  let n = e.length, u = t.length;
  if (n === u) {
    for (let r = 0; r < n; r++) {
      let i = mr(e[r], t[r]);
      if (i !== 0)
        return i;
    }
    return 0;
  }
  return n - u;
}
function hu(e) {
  return !!(/^#[0-9a-f]{6}$/i.test(e) || /^#[0-9a-f]{8}$/i.test(e) || /^#[0-9a-f]{3}$/i.test(e) || /^#[0-9a-f]{4}$/i.test(e));
}
function _r(e) {
  return e.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var br = class {
  constructor(e) {
    k(this, "cache", /* @__PURE__ */ new Map());
    this.fn = e;
  }
  get(e) {
    if (this.cache.has(e))
      return this.cache.get(e);
    const t = this.fn(e);
    return this.cache.set(e, t), t;
  }
}, mt = class {
  constructor(e, t, n) {
    k(this, "_cachedMatchRoot", new br(
      (e) => this._root.match(e)
    ));
    this._colorMap = e, this._defaults = t, this._root = n;
  }
  static createFromRawTheme(e, t) {
    return this.createFromParsedTheme(Hs(e), t);
  }
  static createFromParsedTheme(e, t) {
    return Ws(e, t);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(e) {
    if (e === null)
      return this._defaults;
    const t = e.scopeName, u = this._cachedMatchRoot.get(t).find(
      (r) => qs(e.parent, r.parentScopes)
    );
    return u ? new yr(
      u.fontStyle,
      u.foreground,
      u.background
    ) : null;
  }
}, Vt = class ot {
  constructor(t, n) {
    this.parent = t, this.scopeName = n;
  }
  static push(t, n) {
    for (const u of n)
      t = new ot(t, u);
    return t;
  }
  static from(...t) {
    let n = null;
    for (let u = 0; u < t.length; u++)
      n = new ot(n, t[u]);
    return n;
  }
  push(t) {
    return new ot(this, t);
  }
  getSegments() {
    let t = this;
    const n = [];
    for (; t; )
      n.push(t.scopeName), t = t.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(t) {
    return this === t ? !0 : this.parent === null ? !1 : this.parent.extends(t);
  }
  getExtensionIfDefined(t) {
    const n = [];
    let u = this;
    for (; u && u !== t; )
      n.push(u.scopeName), u = u.parent;
    return u === t ? n.reverse() : void 0;
  }
};
function qs(e, t) {
  if (t.length === 0)
    return !0;
  for (let n = 0; n < t.length; n++) {
    let u = t[n], r = !1;
    if (u === ">") {
      if (n === t.length - 1)
        return !1;
      u = t[++n], r = !0;
    }
    for (; e && !Gs(e.scopeName, u); ) {
      if (r)
        return !1;
      e = e.parent;
    }
    if (!e)
      return !1;
    e = e.parent;
  }
  return !0;
}
function Gs(e, t) {
  return t === e || e.startsWith(t) && e[t.length] === ".";
}
var yr = class {
  constructor(e, t, n) {
    this.fontStyle = e, this.foregroundId = t, this.backgroundId = n;
  }
};
function Hs(e) {
  if (!e)
    return [];
  if (!e.settings || !Array.isArray(e.settings))
    return [];
  let t = e.settings, n = [], u = 0;
  for (let r = 0, i = t.length; r < i; r++) {
    let a = t[r];
    if (!a.settings)
      continue;
    let o;
    if (typeof a.scope == "string") {
      let d = a.scope;
      d = d.replace(/^[,]+/, ""), d = d.replace(/[,]+$/, ""), o = d.split(",");
    } else Array.isArray(a.scope) ? o = a.scope : o = [""];
    let s = -1;
    if (typeof a.settings.fontStyle == "string") {
      s = 0;
      let d = a.settings.fontStyle.split(" ");
      for (let f = 0, p = d.length; f < p; f++)
        switch (d[f]) {
          case "italic":
            s = s | 1;
            break;
          case "bold":
            s = s | 2;
            break;
          case "underline":
            s = s | 4;
            break;
          case "strikethrough":
            s = s | 8;
            break;
        }
    }
    let l = null;
    typeof a.settings.foreground == "string" && hu(a.settings.foreground) && (l = a.settings.foreground);
    let c = null;
    typeof a.settings.background == "string" && hu(a.settings.background) && (c = a.settings.background);
    for (let d = 0, f = o.length; d < f; d++) {
      let h = o[d].trim().split(" "), g = h[h.length - 1], m = null;
      h.length > 1 && (m = h.slice(0, h.length - 1), m.reverse()), n[u++] = new Us(
        g,
        m,
        r,
        s,
        l,
        c
      );
    }
  }
  return n;
}
var Us = class {
  constructor(e, t, n, u, r, i) {
    this.scope = e, this.parentScopes = t, this.index = n, this.fontStyle = u, this.foreground = r, this.background = i;
  }
}, ce = /* @__PURE__ */ ((e) => (e[e.NotSet = -1] = "NotSet", e[e.None = 0] = "None", e[e.Italic = 1] = "Italic", e[e.Bold = 2] = "Bold", e[e.Underline = 4] = "Underline", e[e.Strikethrough = 8] = "Strikethrough", e))(ce || {});
function Ws(e, t) {
  e.sort((s, l) => {
    let c = mr(s.scope, l.scope);
    return c !== 0 || (c = gr(s.parentScopes, l.parentScopes), c !== 0) ? c : s.index - l.index;
  });
  let n = 0, u = "#000000", r = "#ffffff";
  for (; e.length >= 1 && e[0].scope === ""; ) {
    let s = e.shift();
    s.fontStyle !== -1 && (n = s.fontStyle), s.foreground !== null && (u = s.foreground), s.background !== null && (r = s.background);
  }
  let i = new Vs(t), a = new yr(n, i.getId(u), i.getId(r)), o = new Js(new cn(0, null, -1, 0, 0), []);
  for (let s = 0, l = e.length; s < l; s++) {
    let c = e[s];
    o.insert(0, c.scope, c.parentScopes, c.fontStyle, i.getId(c.foreground), i.getId(c.background));
  }
  return new mt(i, a, o);
}
var Vs = class {
  constructor(e) {
    k(this, "_isFrozen");
    k(this, "_lastColorId");
    k(this, "_id2color");
    k(this, "_color2id");
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e)) {
      this._isFrozen = !0;
      for (let t = 0, n = e.length; t < n; t++)
        this._color2id[e[t]] = t, this._id2color[t] = e[t];
    } else
      this._isFrozen = !1;
  }
  getId(e) {
    if (e === null)
      return 0;
    e = e.toUpperCase();
    let t = this._color2id[e];
    if (t)
      return t;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${e}`);
    return t = ++this._lastColorId, this._color2id[e] = t, this._id2color[t] = e, t;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, Zs = Object.freeze([]), cn = class kr {
  constructor(t, n, u, r, i) {
    k(this, "scopeDepth");
    k(this, "parentScopes");
    k(this, "fontStyle");
    k(this, "foreground");
    k(this, "background");
    this.scopeDepth = t, this.parentScopes = n || Zs, this.fontStyle = u, this.foreground = r, this.background = i;
  }
  clone() {
    return new kr(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(t) {
    let n = [];
    for (let u = 0, r = t.length; u < r; u++)
      n[u] = t[u].clone();
    return n;
  }
  acceptOverwrite(t, n, u, r) {
    this.scopeDepth > t ? console.log("how did this happen?") : this.scopeDepth = t, n !== -1 && (this.fontStyle = n), u !== 0 && (this.foreground = u), r !== 0 && (this.background = r);
  }
}, Js = class dn {
  constructor(t, n = [], u = {}) {
    k(this, "_rulesWithParentScopes");
    this._mainRule = t, this._children = u, this._rulesWithParentScopes = n;
  }
  static _cmpBySpecificity(t, n) {
    if (t.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - t.scopeDepth;
    let u = 0, r = 0;
    for (; t.parentScopes[u] === ">" && u++, n.parentScopes[r] === ">" && r++, !(u >= t.parentScopes.length || r >= n.parentScopes.length); ) {
      const i = n.parentScopes[r].length - t.parentScopes[u].length;
      if (i !== 0)
        return i;
      u++, r++;
    }
    return n.parentScopes.length - t.parentScopes.length;
  }
  match(t) {
    if (t !== "") {
      let u = t.indexOf("."), r, i;
      if (u === -1 ? (r = t, i = "") : (r = t.substring(0, u), i = t.substring(u + 1)), this._children.hasOwnProperty(r))
        return this._children[r].match(i);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(dn._cmpBySpecificity), n;
  }
  insert(t, n, u, r, i, a) {
    if (n === "") {
      this._doInsertHere(t, u, r, i, a);
      return;
    }
    let o = n.indexOf("."), s, l;
    o === -1 ? (s = n, l = "") : (s = n.substring(0, o), l = n.substring(o + 1));
    let c;
    this._children.hasOwnProperty(s) ? c = this._children[s] : (c = new dn(this._mainRule.clone(), cn.cloneArr(this._rulesWithParentScopes)), this._children[s] = c), c.insert(t + 1, l, u, r, i, a);
  }
  _doInsertHere(t, n, u, r, i) {
    if (n === null) {
      this._mainRule.acceptOverwrite(t, u, r, i);
      return;
    }
    for (let a = 0, o = this._rulesWithParentScopes.length; a < o; a++) {
      let s = this._rulesWithParentScopes[a];
      if (gr(s.parentScopes, n) === 0) {
        s.acceptOverwrite(t, u, r, i);
        return;
      }
    }
    u === -1 && (u = this._mainRule.fontStyle), r === 0 && (r = this._mainRule.foreground), i === 0 && (i = this._mainRule.background), this._rulesWithParentScopes.push(new cn(t, n, u, r, i));
  }
}, Re = class J {
  static toBinaryStr(t) {
    return t.toString(2).padStart(32, "0");
  }
  static print(t) {
    const n = J.getLanguageId(t), u = J.getTokenType(t), r = J.getFontStyle(t), i = J.getForeground(t), a = J.getBackground(t);
    console.log({
      languageId: n,
      tokenType: u,
      fontStyle: r,
      foreground: i,
      background: a
    });
  }
  static getLanguageId(t) {
    return (t & 255) >>> 0;
  }
  static getTokenType(t) {
    return (t & 768) >>> 8;
  }
  static containsBalancedBrackets(t) {
    return (t & 1024) !== 0;
  }
  static getFontStyle(t) {
    return (t & 30720) >>> 11;
  }
  static getForeground(t) {
    return (t & 16744448) >>> 15;
  }
  static getBackground(t) {
    return (t & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(t, n, u, r, i, a, o) {
    let s = J.getLanguageId(t), l = J.getTokenType(t), c = J.containsBalancedBrackets(t) ? 1 : 0, d = J.getFontStyle(t), f = J.getForeground(t), p = J.getBackground(t);
    return n !== 0 && (s = n), u !== 8 && (l = u), r !== null && (c = r ? 1 : 0), i !== -1 && (d = i), a !== 0 && (f = a), o !== 0 && (p = o), (s << 0 | l << 8 | c << 10 | d << 11 | f << 15 | p << 24) >>> 0;
  }
};
function gt(e, t) {
  const n = [], u = Ks(e);
  let r = u.next();
  for (; r !== null; ) {
    let s = 0;
    if (r.length === 2 && r.charAt(1) === ":") {
      switch (r.charAt(0)) {
        case "R":
          s = 1;
          break;
        case "L":
          s = -1;
          break;
        default:
          console.log(`Unknown priority ${r} in scope selector`);
      }
      r = u.next();
    }
    let l = a();
    if (n.push({ matcher: l, priority: s }), r !== ",")
      break;
    r = u.next();
  }
  return n;
  function i() {
    if (r === "-") {
      r = u.next();
      const s = i();
      return (l) => !!s && !s(l);
    }
    if (r === "(") {
      r = u.next();
      const s = o();
      return r === ")" && (r = u.next()), s;
    }
    if (pu(r)) {
      const s = [];
      do
        s.push(r), r = u.next();
      while (pu(r));
      return (l) => t(s, l);
    }
    return null;
  }
  function a() {
    const s = [];
    let l = i();
    for (; l; )
      s.push(l), l = i();
    return (c) => s.every((d) => d(c));
  }
  function o() {
    const s = [];
    let l = a();
    for (; l && (s.push(l), r === "|" || r === ","); ) {
      do
        r = u.next();
      while (r === "|" || r === ",");
      l = a();
    }
    return (c) => s.some((d) => d(c));
  }
}
function pu(e) {
  return !!e && !!e.match(/[\w\.:]+/);
}
function Ks(e) {
  let t = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = t.exec(e);
  return {
    next: () => {
      if (!n)
        return null;
      const u = n[0];
      return n = t.exec(e), u;
    }
  };
}
function xr(e) {
  typeof e.dispose == "function" && e.dispose();
}
var Ue = class {
  constructor(e) {
    this.scopeName = e;
  }
  toKey() {
    return this.scopeName;
  }
}, Qs = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, Xs = class {
  constructor() {
    k(this, "_references", []);
    k(this, "_seenReferenceKeys", /* @__PURE__ */ new Set());
    k(this, "visitedRule", /* @__PURE__ */ new Set());
  }
  get references() {
    return this._references;
  }
  add(e) {
    const t = e.toKey();
    this._seenReferenceKeys.has(t) || (this._seenReferenceKeys.add(t), this._references.push(e));
  }
}, Ys = class {
  constructor(e, t) {
    k(this, "seenFullScopeRequests", /* @__PURE__ */ new Set());
    k(this, "seenPartialScopeRequests", /* @__PURE__ */ new Set());
    k(this, "Q");
    this.repo = e, this.initialScopeName = t, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new Ue(this.initialScopeName)];
  }
  processQueue() {
    const e = this.Q;
    this.Q = [];
    const t = new Xs();
    for (const n of e)
      el(n, this.initialScopeName, this.repo, t);
    for (const n of t.references)
      if (n instanceof Ue) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function el(e, t, n, u) {
  const r = n.lookup(e.scopeName);
  if (!r) {
    if (e.scopeName === t)
      throw new Error(`No grammar provided for <${t}>`);
    return;
  }
  const i = n.lookup(t);
  e instanceof Ue ? st({ baseGrammar: i, selfGrammar: r }, u) : fn(
    e.ruleName,
    { baseGrammar: i, selfGrammar: r, repository: r.repository },
    u
  );
  const a = n.injections(e.scopeName);
  if (a)
    for (const o of a)
      u.add(new Ue(o));
}
function fn(e, t, n) {
  if (t.repository && t.repository[e]) {
    const u = t.repository[e];
    _t([u], t, n);
  }
}
function st(e, t) {
  e.selfGrammar.patterns && Array.isArray(e.selfGrammar.patterns) && _t(
    e.selfGrammar.patterns,
    { ...e, repository: e.selfGrammar.repository },
    t
  ), e.selfGrammar.injections && _t(
    Object.values(e.selfGrammar.injections),
    { ...e, repository: e.selfGrammar.repository },
    t
  );
}
function _t(e, t, n) {
  for (const u of e) {
    if (n.visitedRule.has(u))
      continue;
    n.visitedRule.add(u);
    const r = u.repository ? hr({}, t.repository, u.repository) : t.repository;
    Array.isArray(u.patterns) && _t(u.patterns, { ...t, repository: r }, n);
    const i = u.include;
    if (!i)
      continue;
    const a = wr(i);
    switch (a.kind) {
      case 0:
        st({ ...t, selfGrammar: t.baseGrammar }, n);
        break;
      case 1:
        st(t, n);
        break;
      case 2:
        fn(a.ruleName, { ...t, repository: r }, n);
        break;
      case 3:
      case 4:
        const o = a.scopeName === t.selfGrammar.scopeName ? t.selfGrammar : a.scopeName === t.baseGrammar.scopeName ? t.baseGrammar : void 0;
        if (o) {
          const s = { baseGrammar: t.baseGrammar, selfGrammar: o, repository: r };
          a.kind === 4 ? fn(a.ruleName, s, n) : st(s, n);
        } else
          a.kind === 4 ? n.add(new Qs(a.scopeName, a.ruleName)) : n.add(new Ue(a.scopeName));
        break;
    }
  }
}
var tl = class {
  constructor() {
    k(this, "kind", 0);
  }
}, nl = class {
  constructor() {
    k(this, "kind", 1);
  }
}, ul = class {
  constructor(e) {
    k(this, "kind", 2);
    this.ruleName = e;
  }
}, rl = class {
  constructor(e) {
    k(this, "kind", 3);
    this.scopeName = e;
  }
}, il = class {
  constructor(e, t) {
    k(this, "kind", 4);
    this.scopeName = e, this.ruleName = t;
  }
};
function wr(e) {
  if (e === "$base")
    return new tl();
  if (e === "$self")
    return new nl();
  const t = e.indexOf("#");
  if (t === -1)
    return new rl(e);
  if (t === 0)
    return new ul(e.substring(1));
  {
    const n = e.substring(0, t), u = e.substring(t + 1);
    return new il(n, u);
  }
}
var al = /\\(\d+)/, mu = /\\(\d+)/g, ol = -1, Cr = -2;
var Ye = class {
  constructor(e, t, n, u) {
    k(this, "$location");
    k(this, "id");
    k(this, "_nameIsCapturing");
    k(this, "_name");
    k(this, "_contentNameIsCapturing");
    k(this, "_contentName");
    this.$location = e, this.id = t, this._name = n || null, this._nameIsCapturing = ut.hasCaptures(this._name), this._contentName = u || null, this._contentNameIsCapturing = ut.hasCaptures(this._contentName);
  }
  get debugName() {
    const e = this.$location ? `${pr(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${e}`;
  }
  getName(e, t) {
    return !this._nameIsCapturing || this._name === null || e === null || t === null ? this._name : ut.replaceCaptures(this._name, e, t);
  }
  getContentName(e, t) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : ut.replaceCaptures(this._contentName, e, t);
  }
}, sl = class extends Ye {
  constructor(t, n, u, r, i) {
    super(t, n, u, r);
    k(this, "retokenizeCapturedWithRuleId");
    this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(t, n) {
    throw new Error("Not supported!");
  }
  compile(t, n) {
    throw new Error("Not supported!");
  }
  compileAG(t, n, u, r) {
    throw new Error("Not supported!");
  }
}, ll = class extends Ye {
  constructor(t, n, u, r, i) {
    super(t, n, u, null);
    k(this, "_match");
    k(this, "captures");
    k(this, "_cachedCompiledPatterns");
    this._match = new We(r, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(t, n) {
    n.push(this._match);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Ve(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, gu = class extends Ye {
  constructor(t, n, u, r, i) {
    super(t, n, u, r);
    k(this, "hasMissingPatterns");
    k(this, "patterns");
    k(this, "_cachedCompiledPatterns");
    this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(t, n) {
    for (const u of this.patterns)
      t.getRule(u).collectPatterns(t, n);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Ve(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, hn = class extends Ye {
  constructor(t, n, u, r, i, a, o, s, l, c) {
    super(t, n, u, r);
    k(this, "_begin");
    k(this, "beginCaptures");
    k(this, "_end");
    k(this, "endHasBackReferences");
    k(this, "endCaptures");
    k(this, "applyEndPatternLast");
    k(this, "hasMissingPatterns");
    k(this, "patterns");
    k(this, "_cachedCompiledPatterns");
    this._begin = new We(i, this.id), this.beginCaptures = a, this._end = new We(o || "￿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = s, this.applyEndPatternLast = l || !1, this.patterns = c.patterns, this.hasMissingPatterns = c.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(t, n) {
    return this._end.resolveBackReferences(t, n);
  }
  collectPatterns(t, n) {
    n.push(this._begin);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t, n).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t, n).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t, n) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Ve();
      for (const u of this.patterns)
        t.getRule(u).collectPatterns(t, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, n) : this._cachedCompiledPatterns.setSource(0, n)), this._cachedCompiledPatterns;
  }
}, bt = class extends Ye {
  constructor(t, n, u, r, i, a, o, s, l) {
    super(t, n, u, r);
    k(this, "_begin");
    k(this, "beginCaptures");
    k(this, "whileCaptures");
    k(this, "_while");
    k(this, "whileHasBackReferences");
    k(this, "hasMissingPatterns");
    k(this, "patterns");
    k(this, "_cachedCompiledPatterns");
    k(this, "_cachedCompiledWhilePatterns");
    this._begin = new We(i, this.id), this.beginCaptures = a, this.whileCaptures = s, this._while = new We(o, Cr), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = l.patterns, this.hasMissingPatterns = l.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(t, n) {
    return this._while.resolveBackReferences(t, n);
  }
  collectPatterns(t, n) {
    n.push(this._begin);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Ve();
      for (const n of this.patterns)
        t.getRule(n).collectPatterns(t, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(t, n) {
    return this._getCachedCompiledWhilePatterns(t, n).compile(t);
  }
  compileWhileAG(t, n, u, r) {
    return this._getCachedCompiledWhilePatterns(t, n).compileAG(t, u, r);
  }
  _getCachedCompiledWhilePatterns(t, n) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new Ve(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, n || "￿"), this._cachedCompiledWhilePatterns;
  }
}, vr = class q {
  static createCaptureRule(t, n, u, r, i) {
    return t.registerRule((a) => new sl(n, a, u, r, i));
  }
  static getCompiledRuleId(t, n, u) {
    return t.id || n.registerRule((r) => {
      if (t.id = r, t.match)
        return new ll(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.match,
          q._compileCaptures(t.captures, n, u)
        );
      if (typeof t.begin > "u") {
        t.repository && (u = hr({}, u, t.repository));
        let i = t.patterns;
        return typeof i > "u" && t.include && (i = [{ include: t.include }]), new gu(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.contentName,
          q._compilePatterns(i, n, u)
        );
      }
      return t.while ? new bt(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        q._compileCaptures(t.beginCaptures || t.captures, n, u),
        t.while,
        q._compileCaptures(t.whileCaptures || t.captures, n, u),
        q._compilePatterns(t.patterns, n, u)
      ) : new hn(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        q._compileCaptures(t.beginCaptures || t.captures, n, u),
        t.end,
        q._compileCaptures(t.endCaptures || t.captures, n, u),
        t.applyEndPatternLast,
        q._compilePatterns(t.patterns, n, u)
      );
    }), t.id;
  }
  static _compileCaptures(t, n, u) {
    let r = [];
    if (t) {
      let i = 0;
      for (const a in t) {
        if (a === "$vscodeTextmateLocation")
          continue;
        const o = parseInt(a, 10);
        o > i && (i = o);
      }
      for (let a = 0; a <= i; a++)
        r[a] = null;
      for (const a in t) {
        if (a === "$vscodeTextmateLocation")
          continue;
        const o = parseInt(a, 10);
        let s = 0;
        t[a].patterns && (s = q.getCompiledRuleId(t[a], n, u)), r[o] = q.createCaptureRule(n, t[a].$vscodeTextmateLocation, t[a].name, t[a].contentName, s);
      }
    }
    return r;
  }
  static _compilePatterns(t, n, u) {
    let r = [];
    if (t)
      for (let i = 0, a = t.length; i < a; i++) {
        const o = t[i];
        let s = -1;
        if (o.include) {
          const l = wr(o.include);
          switch (l.kind) {
            case 0:
            case 1:
              s = q.getCompiledRuleId(u[o.include], n, u);
              break;
            case 2:
              let c = u[l.ruleName];
              c && (s = q.getCompiledRuleId(c, n, u));
              break;
            case 3:
            case 4:
              const d = l.scopeName, f = l.kind === 4 ? l.ruleName : null, p = n.getExternalGrammar(d, u);
              if (p)
                if (f) {
                  let h = p.repository[f];
                  h && (s = q.getCompiledRuleId(h, n, p.repository));
                } else
                  s = q.getCompiledRuleId(p.repository.$self, n, p.repository);
              break;
          }
        } else
          s = q.getCompiledRuleId(o, n, u);
        if (s !== -1) {
          const l = n.getRule(s);
          let c = !1;
          if ((l instanceof gu || l instanceof hn || l instanceof bt) && l.hasMissingPatterns && l.patterns.length === 0 && (c = !0), c)
            continue;
          r.push(s);
        }
      }
    return {
      patterns: r,
      hasMissingPatterns: (t ? t.length : 0) !== r.length
    };
  }
}, We = class Ar {
  constructor(t, n) {
    k(this, "source");
    k(this, "ruleId");
    k(this, "hasAnchor");
    k(this, "hasBackReferences");
    k(this, "_anchorCache");
    if (t && typeof t == "string") {
      const u = t.length;
      let r = 0, i = [], a = !1;
      for (let o = 0; o < u; o++)
        if (t.charAt(o) === "\\" && o + 1 < u) {
          const l = t.charAt(o + 1);
          l === "z" ? (i.push(t.substring(r, o)), i.push("$(?!\\n)(?<!\\n)"), r = o + 2) : (l === "A" || l === "G") && (a = !0), o++;
        }
      this.hasAnchor = a, r === 0 ? this.source = t : (i.push(t.substring(r, u)), this.source = i.join(""));
    } else
      this.hasAnchor = !1, this.source = t;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = al.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new Ar(this.source, this.ruleId);
  }
  setSource(t) {
    this.source !== t && (this.source = t, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(t, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let u = n.map((r) => t.substring(r.start, r.end));
    return mu.lastIndex = 0, this.source.replace(mu, (r, i) => _r(u[parseInt(i, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let t = [], n = [], u = [], r = [], i, a, o, s;
    for (i = 0, a = this.source.length; i < a; i++)
      o = this.source.charAt(i), t[i] = o, n[i] = o, u[i] = o, r[i] = o, o === "\\" && i + 1 < a && (s = this.source.charAt(i + 1), s === "A" ? (t[i + 1] = "￿", n[i + 1] = "￿", u[i + 1] = "A", r[i + 1] = "A") : s === "G" ? (t[i + 1] = "￿", n[i + 1] = "G", u[i + 1] = "￿", r[i + 1] = "G") : (t[i + 1] = s, n[i + 1] = s, u[i + 1] = s, r[i + 1] = s), i++);
    return {
      A0_G0: t.join(""),
      A0_G1: n.join(""),
      A1_G0: u.join(""),
      A1_G1: r.join("")
    };
  }
  resolveAnchors(t, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : t ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, Ve = class {
  constructor() {
    k(this, "_items");
    k(this, "_hasAnchors");
    k(this, "_cached");
    k(this, "_anchorCache");
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(e) {
    this._items.push(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  unshift(e) {
    this._items.unshift(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(e, t) {
    this._items[e].source !== t && (this._disposeCaches(), this._items[e].setSource(t));
  }
  compile(e) {
    if (!this._cached) {
      let t = this._items.map((n) => n.source);
      this._cached = new _u(e, t, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(e, t, n) {
    return this._hasAnchors ? t ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G0) : this.compile(e);
  }
  _resolveAnchors(e, t, n) {
    let u = this._items.map((r) => r.resolveAnchors(t, n));
    return new _u(e, u, this._items.map((r) => r.ruleId));
  }
}, _u = class {
  constructor(e, t, n) {
    k(this, "scanner");
    this.regExps = t, this.rules = n, this.scanner = e.createOnigScanner(t);
  }
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const e = [];
    for (let t = 0, n = this.rules.length; t < n; t++)
      e.push("   - " + this.rules[t] + ": " + this.regExps[t]);
    return e.join(`
`);
  }
  findNextMatchSync(e, t, n) {
    const u = this.scanner.findNextMatchSync(e, t, n);
    return u ? {
      ruleId: this.rules[u.index],
      captureIndices: u.captureIndices
    } : null;
  }
}, Zt = class {
  constructor(e, t) {
    this.languageId = e, this.tokenType = t;
  }
}, le, cl = (le = class {
  constructor(t, n) {
    k(this, "_defaultAttributes");
    k(this, "_embeddedLanguagesMatcher");
    k(this, "_getBasicScopeAttributes", new br((t) => {
      const n = this._scopeToLanguage(t), u = this._toStandardTokenType(t);
      return new Zt(n, u);
    }));
    this._defaultAttributes = new Zt(
      t,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new dl(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(t) {
    return t === null ? le._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(t);
  }
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(t) {
    return this._embeddedLanguagesMatcher.match(t) || 0;
  }
  _toStandardTokenType(t) {
    const n = t.match(le.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
}, k(le, "_NULL_SCOPE_METADATA", new Zt(0, 0)), k(le, "STANDARD_TOKEN_TYPE_REGEXP", /\b(comment|string|regex|meta\.embedded)\b/), le), dl = class {
  constructor(e) {
    k(this, "values");
    k(this, "scopesRegExp");
    if (e.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(e);
      const t = e.map(
        ([n, u]) => _r(n)
      );
      t.sort(), t.reverse(), this.scopesRegExp = new RegExp(
        `^((${t.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(e) {
    if (!this.scopesRegExp)
      return;
    const t = e.match(this.scopesRegExp);
    if (t)
      return this.values.get(t[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var bu = class {
  constructor(e, t) {
    this.stack = e, this.stoppedEarly = t;
  }
};
function Er(e, t, n, u, r, i, a, o) {
  const s = t.content.length;
  let l = !1, c = -1;
  if (a) {
    const p = fl(
      e,
      t,
      n,
      u,
      r,
      i
    );
    r = p.stack, u = p.linePos, n = p.isFirstLine, c = p.anchorPosition;
  }
  const d = Date.now();
  for (; !l; ) {
    if (o !== 0 && Date.now() - d > o)
      return new bu(r, !0);
    f();
  }
  return new bu(r, !1);
  function f() {
    const p = hl(
      e,
      t,
      n,
      u,
      r,
      c
    );
    if (!p) {
      i.produce(r, s), l = !0;
      return;
    }
    const h = p.captureIndices, g = p.matchedRuleId, m = h && h.length > 0 ? h[0].end > u : !1;
    if (g === ol) {
      const b = r.getRule(e);
      i.produce(r, h[0].start), r = r.withContentNameScopesList(r.nameScopesList), Be(
        e,
        t,
        n,
        r,
        i,
        b.endCaptures,
        h
      ), i.produce(r, h[0].end);
      const _ = r;
      if (r = r.parent, c = _.getAnchorPos(), !m && _.getEnterPos() === u) {
        r = _, i.produce(r, s), l = !0;
        return;
      }
    } else {
      const b = e.getRule(g);
      i.produce(r, h[0].start);
      const _ = r, y = b.getName(t.content, h), x = r.contentNameScopesList.pushAttributed(
        y,
        e
      );
      if (r = r.push(
        g,
        u,
        c,
        h[0].end === s,
        null,
        x,
        x
      ), b instanceof hn) {
        const C = b;
        Be(
          e,
          t,
          n,
          r,
          i,
          C.beginCaptures,
          h
        ), i.produce(r, h[0].end), c = h[0].end;
        const v = C.getContentName(
          t.content,
          h
        ), A = x.pushAttributed(
          v,
          e
        );
        if (r = r.withContentNameScopesList(A), C.endHasBackReferences && (r = r.withEndRule(
          C.getEndWithResolvedBackReferences(
            t.content,
            h
          )
        )), !m && _.hasSameRuleAs(r)) {
          r = r.pop(), i.produce(r, s), l = !0;
          return;
        }
      } else if (b instanceof bt) {
        const C = b;
        Be(
          e,
          t,
          n,
          r,
          i,
          C.beginCaptures,
          h
        ), i.produce(r, h[0].end), c = h[0].end;
        const v = C.getContentName(
          t.content,
          h
        ), A = x.pushAttributed(
          v,
          e
        );
        if (r = r.withContentNameScopesList(A), C.whileHasBackReferences && (r = r.withEndRule(
          C.getWhileWithResolvedBackReferences(
            t.content,
            h
          )
        )), !m && _.hasSameRuleAs(r)) {
          r = r.pop(), i.produce(r, s), l = !0;
          return;
        }
      } else if (Be(
        e,
        t,
        n,
        r,
        i,
        b.captures,
        h
      ), i.produce(r, h[0].end), r = r.pop(), !m) {
        r = r.safePop(), i.produce(r, s), l = !0;
        return;
      }
    }
    h[0].end > u && (u = h[0].end, n = !1);
  }
}
function fl(e, t, n, u, r, i) {
  let a = r.beginRuleCapturedEOL ? 0 : -1;
  const o = [];
  for (let s = r; s; s = s.pop()) {
    const l = s.getRule(e);
    l instanceof bt && o.push({
      rule: l,
      stack: s
    });
  }
  for (let s = o.pop(); s; s = o.pop()) {
    const { ruleScanner: l, findOptions: c } = gl(s.rule, e, s.stack.endRule, n, u === a), d = l.findNextMatchSync(t, u, c);
    if (d) {
      if (d.ruleId !== Cr) {
        r = s.stack.pop();
        break;
      }
      d.captureIndices && d.captureIndices.length && (i.produce(s.stack, d.captureIndices[0].start), Be(e, t, n, s.stack, i, s.rule.whileCaptures, d.captureIndices), i.produce(s.stack, d.captureIndices[0].end), a = d.captureIndices[0].end, d.captureIndices[0].end > u && (u = d.captureIndices[0].end, n = !1));
    } else {
      r = s.stack.pop();
      break;
    }
  }
  return { stack: r, linePos: u, anchorPosition: a, isFirstLine: n };
}
function hl(e, t, n, u, r, i) {
  const a = pl(e, t, n, u, r, i), o = e.getInjections();
  if (o.length === 0)
    return a;
  const s = ml(o, e, t, n, u, r, i);
  if (!s)
    return a;
  if (!a)
    return s;
  const l = a.captureIndices[0].start, c = s.captureIndices[0].start;
  return c < l || s.priorityMatch && c === l ? s : a;
}
function pl(e, t, n, u, r, i) {
  const a = r.getRule(e), { ruleScanner: o, findOptions: s } = Sr(a, e, r.endRule, n, u === i), l = o.findNextMatchSync(t, u, s);
  return l ? {
    captureIndices: l.captureIndices,
    matchedRuleId: l.ruleId
  } : null;
}
function ml(e, t, n, u, r, i, a) {
  let o = Number.MAX_VALUE, s = null, l, c = 0;
  const d = i.contentNameScopesList.getScopeNames();
  for (let f = 0, p = e.length; f < p; f++) {
    const h = e[f];
    if (!h.matcher(d))
      continue;
    const g = t.getRule(h.ruleId), { ruleScanner: m, findOptions: b } = Sr(g, t, null, u, r === a), _ = m.findNextMatchSync(n, r, b);
    if (!_)
      continue;
    const y = _.captureIndices[0].start;
    if (!(y >= o) && (o = y, s = _.captureIndices, l = _.ruleId, c = h.priority, o === r))
      break;
  }
  return s ? {
    priorityMatch: c === -1,
    captureIndices: s,
    matchedRuleId: l
  } : null;
}
function Sr(e, t, n, u, r) {
  return {
    ruleScanner: e.compileAG(t, n, u, r),
    findOptions: 0
    /* None */
  };
}
function gl(e, t, n, u, r) {
  return {
    ruleScanner: e.compileWhileAG(t, n, u, r),
    findOptions: 0
    /* None */
  };
}
function Be(e, t, n, u, r, i, a) {
  if (i.length === 0)
    return;
  const o = t.content, s = Math.min(i.length, a.length), l = [], c = a[0].end;
  for (let d = 0; d < s; d++) {
    const f = i[d];
    if (f === null)
      continue;
    const p = a[d];
    if (p.length === 0)
      continue;
    if (p.start > c)
      break;
    for (; l.length > 0 && l[l.length - 1].endPos <= p.start; )
      r.produceFromScopes(l[l.length - 1].scopes, l[l.length - 1].endPos), l.pop();
    if (l.length > 0 ? r.produceFromScopes(l[l.length - 1].scopes, p.start) : r.produce(u, p.start), f.retokenizeCapturedWithRuleId) {
      const g = f.getName(o, a), m = u.contentNameScopesList.pushAttributed(g, e), b = f.getContentName(o, a), _ = m.pushAttributed(b, e), y = u.push(f.retokenizeCapturedWithRuleId, p.start, -1, !1, null, m, _), x = e.createOnigString(o.substring(0, p.end));
      Er(
        e,
        x,
        n && p.start === 0,
        p.start,
        y,
        r,
        !1,
        /* no time limit */
        0
      ), xr(x);
      continue;
    }
    const h = f.getName(o, a);
    if (h !== null) {
      const m = (l.length > 0 ? l[l.length - 1].scopes : u.contentNameScopesList).pushAttributed(h, e);
      l.push(new _l(m, p.end));
    }
  }
  for (; l.length > 0; )
    r.produceFromScopes(l[l.length - 1].scopes, l[l.length - 1].endPos), l.pop();
}
var _l = class {
  constructor(e, t) {
    k(this, "scopes");
    k(this, "endPos");
    this.scopes = e, this.endPos = t;
  }
};
function bl(e, t, n, u, r, i, a, o) {
  return new kl(
    e,
    t,
    n,
    u,
    r,
    i,
    a,
    o
  );
}
function yu(e, t, n, u, r) {
  const i = gt(t, yt), a = vr.getCompiledRuleId(n, u, r.repository);
  for (const o of i)
    e.push({
      debugSelector: t,
      matcher: o.matcher,
      ruleId: a,
      grammar: r,
      priority: o.priority
    });
}
function yt(e, t) {
  if (t.length < e.length)
    return !1;
  let n = 0;
  return e.every((u) => {
    for (let r = n; r < t.length; r++)
      if (yl(t[r], u))
        return n = r + 1, !0;
    return !1;
  });
}
function yl(e, t) {
  if (!e)
    return !1;
  if (e === t)
    return !0;
  const n = t.length;
  return e.length > n && e.substr(0, n) === t && e[n] === ".";
}
var kl = class {
  constructor(e, t, n, u, r, i, a, o) {
    k(this, "_rootId");
    k(this, "_lastRuleId");
    k(this, "_ruleId2desc");
    k(this, "_includedGrammars");
    k(this, "_grammarRepository");
    k(this, "_grammar");
    k(this, "_injections");
    k(this, "_basicScopeAttributesProvider");
    k(this, "_tokenTypeMatchers");
    if (this._rootScopeName = e, this.balancedBracketSelectors = i, this._onigLib = o, this._basicScopeAttributesProvider = new cl(
      n,
      u
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = a, this._grammar = ku(t, null), this._injections = null, this._tokenTypeMatchers = [], r)
      for (const s of Object.keys(r)) {
        const l = gt(s, yt);
        for (const c of l)
          this._tokenTypeMatchers.push({
            matcher: c.matcher,
            type: r[s]
          });
      }
  }
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const e of this._ruleId2desc)
      e && e.dispose();
  }
  createOnigScanner(e) {
    return this._onigLib.createOnigScanner(e);
  }
  createOnigString(e) {
    return this._onigLib.createOnigString(e);
  }
  getMetadataForScope(e) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(e);
  }
  _collectInjections() {
    const e = {
      lookup: (r) => r === this._rootScopeName ? this._grammar : this.getExternalGrammar(r),
      injections: (r) => this._grammarRepository.injections(r)
    }, t = [], n = this._rootScopeName, u = e.lookup(n);
    if (u) {
      const r = u.injections;
      if (r)
        for (let a in r)
          yu(
            t,
            a,
            r[a],
            this,
            u
          );
      const i = this._grammarRepository.injections(n);
      i && i.forEach((a) => {
        const o = this.getExternalGrammar(a);
        if (o) {
          const s = o.injectionSelector;
          s && yu(
            t,
            s,
            o,
            this,
            o
          );
        }
      });
    }
    return t.sort((r, i) => r.priority - i.priority), t;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(e) {
    const t = ++this._lastRuleId, n = e(t);
    return this._ruleId2desc[t] = n, n;
  }
  getRule(e) {
    return this._ruleId2desc[e];
  }
  getExternalGrammar(e, t) {
    if (this._includedGrammars[e])
      return this._includedGrammars[e];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(e);
      if (n)
        return this._includedGrammars[e] = ku(
          n,
          t && t.$base
        ), this._includedGrammars[e];
    }
  }
  tokenizeLine(e, t, n = 0) {
    const u = this._tokenize(e, t, !1, n);
    return {
      tokens: u.lineTokens.getResult(u.ruleStack, u.lineLength),
      ruleStack: u.ruleStack,
      stoppedEarly: u.stoppedEarly
    };
  }
  tokenizeLine2(e, t, n = 0) {
    const u = this._tokenize(e, t, !0, n);
    return {
      tokens: u.lineTokens.getBinaryResult(u.ruleStack, u.lineLength),
      ruleStack: u.ruleStack,
      stoppedEarly: u.stoppedEarly
    };
  }
  _tokenize(e, t, n, u) {
    this._rootId === -1 && (this._rootId = vr.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let r;
    if (!t || t === pn.NULL) {
      r = !0;
      const l = this._basicScopeAttributesProvider.getDefaultAttributes(), c = this.themeProvider.getDefaults(), d = Re.set(
        0,
        l.languageId,
        l.tokenType,
        null,
        c.fontStyle,
        c.foregroundId,
        c.backgroundId
      ), f = this.getRule(this._rootId).getName(
        null,
        null
      );
      let p;
      f ? p = je.createRootAndLookUpScopeName(
        f,
        d,
        this
      ) : p = je.createRoot(
        "unknown",
        d
      ), t = new pn(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        p,
        p
      );
    } else
      r = !1, t.reset();
    e = e + `
`;
    const i = this.createOnigString(e), a = i.content.length, o = new wl(
      n,
      e,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), s = Er(
      this,
      i,
      r,
      0,
      t,
      o,
      !0,
      u
    );
    return xr(i), {
      lineLength: a,
      lineTokens: o,
      ruleStack: s.stack,
      stoppedEarly: s.stoppedEarly
    };
  }
};
function ku(e, t) {
  return e = js(e), e.repository = e.repository || {}, e.repository.$self = {
    $vscodeTextmateLocation: e.$vscodeTextmateLocation,
    patterns: e.patterns,
    name: e.scopeName
  }, e.repository.$base = t || e.repository.$self, e;
}
var je = class ee {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, u) {
    this.parent = t, this.scopePath = n, this.tokenAttributes = u;
  }
  static fromExtension(t, n) {
    let u = t, r = (t == null ? void 0 : t.scopePath) ?? null;
    for (const i of n)
      r = Vt.push(r, i.scopeNames), u = new ee(u, r, i.encodedTokenAttributes);
    return u;
  }
  static createRoot(t, n) {
    return new ee(null, new Vt(null, t), n);
  }
  static createRootAndLookUpScopeName(t, n, u) {
    const r = u.getMetadataForScope(t), i = new Vt(null, t), a = u.themeProvider.themeMatch(i), o = ee.mergeAttributes(
      n,
      r,
      a
    );
    return new ee(null, i, o);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(t) {
    return ee.equals(this, t);
  }
  static equals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.scopeName !== n.scopeName || t.tokenAttributes !== n.tokenAttributes)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(t, n, u) {
    let r = -1, i = 0, a = 0;
    return u !== null && (r = u.fontStyle, i = u.foregroundId, a = u.backgroundId), Re.set(
      t,
      n.languageId,
      n.tokenType,
      null,
      r,
      i,
      a
    );
  }
  pushAttributed(t, n) {
    if (t === null)
      return this;
    if (t.indexOf(" ") === -1)
      return ee._pushAttributed(this, t, n);
    const u = t.split(/ /g);
    let r = this;
    for (const i of u)
      r = ee._pushAttributed(r, i, n);
    return r;
  }
  static _pushAttributed(t, n, u) {
    const r = u.getMetadataForScope(n), i = t.scopePath.push(n), a = u.themeProvider.themeMatch(i), o = ee.mergeAttributes(
      t.tokenAttributes,
      r,
      a
    );
    return new ee(t, i, o);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(t) {
    var r;
    const n = [];
    let u = this;
    for (; u && u !== t; )
      n.push({
        encodedTokenAttributes: u.tokenAttributes,
        scopeNames: u.scopePath.getExtensionIfDefined(((r = u.parent) == null ? void 0 : r.scopePath) ?? null)
      }), u = u.parent;
    return u === t ? n.reverse() : void 0;
  }
}, K, pn = (K = class {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, u, r, i, a, o, s) {
    k(this, "_stackElementBrand");
    /**
     * The position on the current line where this state was pushed.
     * This is relevant only while tokenizing a line, to detect endless loops.
     * Its value is meaningless across lines.
     */
    k(this, "_enterPos");
    /**
     * The captured anchor position when this stack element was pushed.
     * This is relevant only while tokenizing a line, to restore the anchor position when popping.
     * Its value is meaningless across lines.
     */
    k(this, "_anchorPos");
    /**
     * The depth of the stack.
     */
    k(this, "depth");
    this.parent = t, this.ruleId = n, this.beginRuleCapturedEOL = i, this.endRule = a, this.nameScopesList = o, this.contentNameScopesList = s, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = u, this._anchorPos = r;
  }
  equals(t) {
    return t === null ? !1 : K._equals(this, t);
  }
  static _equals(t, n) {
    return t === n ? !0 : this._structuralEquals(t, n) ? je.equals(t.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.depth !== n.depth || t.ruleId !== n.ruleId || t.endRule !== n.endRule)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(t) {
    for (; t; )
      t._enterPos = -1, t._anchorPos = -1, t = t.parent;
  }
  reset() {
    K._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(t, n, u, r, i, a, o) {
    return new K(
      this,
      t,
      n,
      u,
      r,
      i,
      a,
      o
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(t) {
    return t.getRule(this.ruleId);
  }
  toString() {
    const t = [];
    return this._writeString(t, 0), "[" + t.join(",") + "]";
  }
  _writeString(t, n) {
    var u, r;
    return this.parent && (n = this.parent._writeString(t, n)), t[n++] = `(${this.ruleId}, ${(u = this.nameScopesList) == null ? void 0 : u.toString()}, ${(r = this.contentNameScopesList) == null ? void 0 : r.toString()})`, n;
  }
  withContentNameScopesList(t) {
    return this.contentNameScopesList === t ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      t
    );
  }
  withEndRule(t) {
    return this.endRule === t ? this : new K(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      t,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(t) {
    let n = this;
    for (; n && n._enterPos === t._enterPos; ) {
      if (n.ruleId === t.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    var t, n, u;
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: ((n = this.nameScopesList) == null ? void 0 : n.getExtensionIfDefined(((t = this.parent) == null ? void 0 : t.nameScopesList) ?? null)) ?? [],
      contentNameScopesList: ((u = this.contentNameScopesList) == null ? void 0 : u.getExtensionIfDefined(this.nameScopesList)) ?? []
    };
  }
  static pushFrame(t, n) {
    const u = je.fromExtension((t == null ? void 0 : t.nameScopesList) ?? null, n.nameScopesList);
    return new K(
      t,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      u,
      je.fromExtension(u, n.contentNameScopesList)
    );
  }
}, // TODO remove me
k(K, "NULL", new K(
  null,
  0,
  0,
  0,
  !1,
  null,
  null,
  null
)), K), xl = class {
  constructor(e, t) {
    k(this, "balancedBracketScopes");
    k(this, "unbalancedBracketScopes");
    k(this, "allowAny", !1);
    this.balancedBracketScopes = e.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : gt(n, yt).map((u) => u.matcher)
    ), this.unbalancedBracketScopes = t.flatMap(
      (n) => gt(n, yt).map((u) => u.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(e) {
    for (const t of this.unbalancedBracketScopes)
      if (t(e))
        return !1;
    for (const t of this.balancedBracketScopes)
      if (t(e))
        return !0;
    return this.allowAny;
  }
}, wl = class {
  constructor(e, t, n, u) {
    k(this, "_emitBinaryTokens");
    /**
     * defined only if `false`.
     */
    k(this, "_lineText");
    /**
     * used only if `_emitBinaryTokens` is false.
     */
    k(this, "_tokens");
    /**
     * used only if `_emitBinaryTokens` is true.
     */
    k(this, "_binaryTokens");
    k(this, "_lastTokenEndIndex");
    k(this, "_tokenTypeOverrides");
    this.balancedBracketSelectors = u, this._emitBinaryTokens = e, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  produce(e, t) {
    this.produceFromScopes(e.contentNameScopesList, t);
  }
  produceFromScopes(e, t) {
    var u;
    if (this._lastTokenEndIndex >= t)
      return;
    if (this._emitBinaryTokens) {
      let r = (e == null ? void 0 : e.tokenAttributes) ?? 0, i = !1;
      if ((u = this.balancedBracketSelectors) != null && u.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const a = (e == null ? void 0 : e.getScopeNames()) ?? [];
        for (const o of this._tokenTypeOverrides)
          o.matcher(a) && (r = Re.set(
            r,
            0,
            o.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(a));
      }
      if (i && (r = Re.set(
        r,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = t;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = t;
      return;
    }
    const n = (e == null ? void 0 : e.getScopeNames()) ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: t,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = t;
  }
  getResult(e, t) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(e, t) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let u = 0, r = this._binaryTokens.length; u < r; u++)
      n[u] = this._binaryTokens[u];
    return n;
  }
}, Cl = class {
  constructor(e, t) {
    k(this, "_grammars", /* @__PURE__ */ new Map());
    k(this, "_rawGrammars", /* @__PURE__ */ new Map());
    k(this, "_injectionGrammars", /* @__PURE__ */ new Map());
    k(this, "_theme");
    this._onigLib = t, this._theme = e;
  }
  dispose() {
    for (const e of this._grammars.values())
      e.dispose();
  }
  setTheme(e) {
    this._theme = e;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(e, t) {
    this._rawGrammars.set(e.scopeName, e), t && this._injectionGrammars.set(e.scopeName, t);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(e) {
    return this._rawGrammars.get(e);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(e) {
    return this._injectionGrammars.get(e);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(e) {
    return this._theme.match(e);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(e, t, n, u, r) {
    if (!this._grammars.has(e)) {
      let i = this._rawGrammars.get(e);
      if (!i)
        return null;
      this._grammars.set(e, bl(
        e,
        i,
        t,
        n,
        u,
        r,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(e);
  }
}, vl = class {
  constructor(t) {
    k(this, "_options");
    k(this, "_syncRegistry");
    k(this, "_ensureGrammarCache");
    this._options = t, this._syncRegistry = new Cl(
      mt.createFromRawTheme(t.theme, t.colorMap),
      t.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(t, n) {
    this._syncRegistry.setTheme(mt.createFromRawTheme(t, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(t, n, u) {
    return this.loadGrammarWithConfiguration(t, n, { embeddedLanguages: u });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(t, n, u) {
    return this._loadGrammar(
      t,
      n,
      u.embeddedLanguages,
      u.tokenTypes,
      new xl(
        u.balancedBracketSelectors || [],
        u.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(t) {
    return this._loadGrammar(t, 0, null, null, null);
  }
  _loadGrammar(t, n, u, r, i) {
    const a = new Ys(this._syncRegistry, t);
    for (; a.Q.length > 0; )
      a.Q.map((o) => this._loadSingleGrammar(o.scopeName)), a.processQueue();
    return this._grammarForScopeName(
      t,
      n,
      u,
      r,
      i
    );
  }
  _loadSingleGrammar(t) {
    this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0));
  }
  _doLoadSingleGrammar(t) {
    const n = this._options.loadGrammar(t);
    if (n) {
      const u = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0;
      this._syncRegistry.addGrammar(n, u);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(t, n = [], u = 0, r = null) {
    return this._syncRegistry.addGrammar(t, n), this._grammarForScopeName(t.scopeName, u, r);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(t, n = 0, u = null, r = null, i = null) {
    return this._syncRegistry.grammarForScopeName(
      t,
      n,
      u,
      r,
      i
    );
  }
}, mn = pn.NULL;
const Al = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
class et {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, u) {
    this.normal = n, this.property = t, u && (this.space = u);
  }
}
et.prototype.normal = {};
et.prototype.property = {};
et.prototype.space = void 0;
function Dr(e, t) {
  const n = {}, u = {};
  for (const r of e)
    Object.assign(n, r.property), Object.assign(u, r.normal);
  return new et(n, u, t);
}
function gn(e) {
  return e.toLowerCase();
}
class U {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
U.prototype.attribute = "";
U.prototype.booleanish = !1;
U.prototype.boolean = !1;
U.prototype.commaOrSpaceSeparated = !1;
U.prototype.commaSeparated = !1;
U.prototype.defined = !1;
U.prototype.mustUseProperty = !1;
U.prototype.number = !1;
U.prototype.overloadedBoolean = !1;
U.prototype.property = "";
U.prototype.spaceSeparated = !1;
U.prototype.space = void 0;
let El = 0;
const E = ke(), R = ke(), Fr = ke(), w = ke(), F = ke(), Ee = ke(), W = ke();
function ke() {
  return 2 ** ++El;
}
const _n = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: E,
  booleanish: R,
  commaOrSpaceSeparated: W,
  commaSeparated: Ee,
  number: w,
  overloadedBoolean: Fr,
  spaceSeparated: F
}, Symbol.toStringTag, { value: "Module" })), Jt = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(_n)
);
class Ln extends U {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, u, r) {
    let i = -1;
    if (super(t, n), xu(this, "space", r), typeof u == "number")
      for (; ++i < Jt.length; ) {
        const a = Jt[i];
        xu(this, Jt[i], (u & _n[a]) === _n[a]);
      }
  }
}
Ln.prototype.defined = !0;
function xu(e, t, n) {
  n && (e[t] = n);
}
function Pe(e) {
  const t = {}, n = {};
  for (const [u, r] of Object.entries(e.properties)) {
    const i = new Ln(
      u,
      e.transform(e.attributes || {}, u),
      r,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(u) && (i.mustUseProperty = !0), t[u] = i, n[gn(u)] = u, n[gn(i.attribute)] = u;
  }
  return new et(t, n, e.space);
}
const Tr = Pe({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: R,
    ariaAutoComplete: null,
    ariaBusy: R,
    ariaChecked: R,
    ariaColCount: w,
    ariaColIndex: w,
    ariaColSpan: w,
    ariaControls: F,
    ariaCurrent: null,
    ariaDescribedBy: F,
    ariaDetails: null,
    ariaDisabled: R,
    ariaDropEffect: F,
    ariaErrorMessage: null,
    ariaExpanded: R,
    ariaFlowTo: F,
    ariaGrabbed: R,
    ariaHasPopup: null,
    ariaHidden: R,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: F,
    ariaLevel: w,
    ariaLive: null,
    ariaModal: R,
    ariaMultiLine: R,
    ariaMultiSelectable: R,
    ariaOrientation: null,
    ariaOwns: F,
    ariaPlaceholder: null,
    ariaPosInSet: w,
    ariaPressed: R,
    ariaReadOnly: R,
    ariaRelevant: null,
    ariaRequired: R,
    ariaRoleDescription: F,
    ariaRowCount: w,
    ariaRowIndex: w,
    ariaRowSpan: w,
    ariaSelected: R,
    ariaSetSize: w,
    ariaSort: null,
    ariaValueMax: w,
    ariaValueMin: w,
    ariaValueNow: w,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function Rr(e, t) {
  return t in e ? e[t] : t;
}
function Lr(e, t) {
  return Rr(e, t.toLowerCase());
}
const Sl = Pe({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ee,
    acceptCharset: F,
    accessKey: F,
    action: null,
    allow: null,
    allowFullScreen: E,
    allowPaymentRequest: E,
    allowUserMedia: E,
    alt: null,
    as: null,
    async: E,
    autoCapitalize: null,
    autoComplete: F,
    autoFocus: E,
    autoPlay: E,
    blocking: F,
    capture: null,
    charSet: null,
    checked: E,
    cite: null,
    className: F,
    cols: w,
    colSpan: null,
    content: null,
    contentEditable: R,
    controls: E,
    controlsList: F,
    coords: w | Ee,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: E,
    defer: E,
    dir: null,
    dirName: null,
    disabled: E,
    download: Fr,
    draggable: R,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: E,
    formTarget: null,
    headers: F,
    height: w,
    hidden: E,
    high: w,
    href: null,
    hrefLang: null,
    htmlFor: F,
    httpEquiv: F,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: E,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: E,
    itemId: null,
    itemProp: F,
    itemRef: F,
    itemScope: E,
    itemType: F,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: E,
    low: w,
    manifest: null,
    max: null,
    maxLength: w,
    media: null,
    method: null,
    min: null,
    minLength: w,
    multiple: E,
    muted: E,
    name: null,
    nonce: null,
    noModule: E,
    noValidate: E,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: E,
    optimum: w,
    pattern: null,
    ping: F,
    placeholder: null,
    playsInline: E,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: E,
    referrerPolicy: null,
    rel: F,
    required: E,
    reversed: E,
    rows: w,
    rowSpan: w,
    sandbox: F,
    scope: null,
    scoped: E,
    seamless: E,
    selected: E,
    shadowRootClonable: E,
    shadowRootDelegatesFocus: E,
    shadowRootMode: null,
    shape: null,
    size: w,
    sizes: null,
    slot: null,
    span: w,
    spellCheck: R,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: w,
    step: null,
    style: null,
    tabIndex: w,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: E,
    useMap: null,
    value: R,
    width: w,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: F,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: w,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: w,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: E,
    // Lists. Use CSS to reduce space between items instead
    declare: E,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: w,
    // `<img>` and `<object>`
    leftMargin: w,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: w,
    // `<body>`
    marginWidth: w,
    // `<body>`
    noResize: E,
    // `<frame>`
    noHref: E,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: E,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: E,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: w,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: R,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: w,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: w,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: E,
    disableRemotePlayback: E,
    prefix: null,
    property: null,
    results: w,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: Lr
}), Dl = Pe({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: W,
    accentHeight: w,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: w,
    amplitude: w,
    arabicForm: null,
    ascent: w,
    attributeName: null,
    attributeType: null,
    azimuth: w,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: w,
    by: null,
    calcMode: null,
    capHeight: w,
    className: F,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: w,
    diffuseConstant: w,
    direction: null,
    display: null,
    dur: null,
    divisor: w,
    dominantBaseline: null,
    download: E,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: w,
    enableBackground: null,
    end: null,
    event: null,
    exponent: w,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: w,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ee,
    g2: Ee,
    glyphName: Ee,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: w,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: w,
    horizOriginX: w,
    horizOriginY: w,
    id: null,
    ideographic: w,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: w,
    k: w,
    k1: w,
    k2: w,
    k3: w,
    k4: w,
    kernelMatrix: W,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: w,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: w,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: w,
    overlineThickness: w,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: w,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: F,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: w,
    pointsAtY: w,
    pointsAtZ: w,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: W,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: W,
    rev: W,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: W,
    requiredFeatures: W,
    requiredFonts: W,
    requiredFormats: W,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: w,
    specularExponent: w,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: w,
    strikethroughThickness: w,
    string: null,
    stroke: null,
    strokeDashArray: W,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: w,
    strokeOpacity: w,
    strokeWidth: null,
    style: null,
    surfaceScale: w,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: W,
    tabIndex: w,
    tableValues: null,
    target: null,
    targetX: w,
    targetY: w,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: W,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: w,
    underlineThickness: w,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: w,
    values: null,
    vAlphabetic: w,
    vMathematical: w,
    vectorEffect: null,
    vHanging: w,
    vIdeographic: w,
    version: null,
    vertAdvY: w,
    vertOriginX: w,
    vertOriginY: w,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: w,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: Rr
}), Pr = Pe({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), Nr = Pe({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: Lr
}), Ir = Pe({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), Fl = /[A-Z]/g, wu = /-[a-z]/g, Tl = /^data[-\w.:]+$/i;
function Rl(e, t) {
  const n = gn(t);
  let u = t, r = U;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Tl.test(t)) {
    if (t.charAt(4) === "-") {
      const i = t.slice(5).replace(wu, Pl);
      u = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = t.slice(4);
      if (!wu.test(i)) {
        let a = i.replace(Fl, Ll);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    r = Ln;
  }
  return new r(u, t);
}
function Ll(e) {
  return "-" + e.toLowerCase();
}
function Pl(e) {
  return e.charAt(1).toUpperCase();
}
const Nl = Dr([Tr, Sl, Pr, Nr, Ir], "html"), Mr = Dr([Tr, Dl, Pr, Nr, Ir], "svg"), Cu = {}.hasOwnProperty;
function Il(e, t) {
  const n = t || {};
  function u(r, ...i) {
    let a = u.invalid;
    const o = u.handlers;
    if (r && Cu.call(r, e)) {
      const s = String(r[e]);
      a = Cu.call(o, s) ? o[s] : u.unknown;
    }
    if (a)
      return a.call(this, r, ...i);
  }
  return u.handlers = n.handlers || {}, u.invalid = n.invalid, u.unknown = n.unknown, u;
}
const Ml = /["&'<>`]/g, Ol = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Bl = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), jl = /[|\\{}()[\]^$+*?.]/g, vu = /* @__PURE__ */ new WeakMap();
function zl(e, t) {
  if (e = e.replace(
    t.subset ? $l(t.subset) : Ml,
    u
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(Ol, n).replace(Bl, u);
  function n(r, i, a) {
    return t.format(
      (r.charCodeAt(0) - 55296) * 1024 + r.charCodeAt(1) - 56320 + 65536,
      a.charCodeAt(i + 2),
      t
    );
  }
  function u(r, i, a) {
    return t.format(
      r.charCodeAt(0),
      a.charCodeAt(i + 1),
      t
    );
  }
}
function $l(e) {
  let t = vu.get(e);
  return t || (t = ql(e), vu.set(e, t)), t;
}
function ql(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t.push(e[n].replace(jl, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
const Gl = /[\dA-Fa-f]/;
function Hl(e, t, n) {
  const u = "&#x" + e.toString(16).toUpperCase();
  return n && t && !Gl.test(String.fromCharCode(t)) ? u : u + ";";
}
const Ul = /\d/;
function Wl(e, t, n) {
  const u = "&#" + String(e);
  return n && t && !Ul.test(String.fromCharCode(t)) ? u : u + ";";
}
const Vl = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], Kt = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
}, Zl = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], Or = {}.hasOwnProperty, bn = {};
let rt;
for (rt in Kt)
  Or.call(Kt, rt) && (bn[Kt[rt]] = rt);
const Jl = /[^\dA-Za-z]/;
function Kl(e, t, n, u) {
  const r = String.fromCharCode(e);
  if (Or.call(bn, r)) {
    const i = bn[r], a = "&" + i;
    return n && Vl.includes(i) && !Zl.includes(i) && (!u || t && t !== 61 && Jl.test(String.fromCharCode(t))) ? a : a + ";";
  }
  return "";
}
function Ql(e, t, n) {
  let u = Hl(e, t, n.omitOptionalSemicolons), r;
  if ((n.useNamedReferences || n.useShortestReferences) && (r = Kl(
    e,
    t,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !r) && n.useShortestReferences) {
    const i = Wl(e, t, n.omitOptionalSemicolons);
    i.length < u.length && (u = i);
  }
  return r && (!n.useShortestReferences || r.length < u.length) ? r : u;
}
function Se(e, t) {
  return zl(e, Object.assign({ format: Ql }, t));
}
const Xl = /^>|^->|<!--|-->|--!>|<!-$/g, Yl = [">"], ec = ["<", ">"];
function tc(e, t, n, u) {
  return u.settings.bogusComments ? "<?" + Se(
    e.value,
    Object.assign({}, u.settings.characterReferences, {
      subset: Yl
    })
  ) + ">" : "<!--" + e.value.replace(Xl, r) + "-->";
  function r(i) {
    return Se(
      i,
      Object.assign({}, u.settings.characterReferences, {
        subset: ec
      })
    );
  }
}
function nc(e, t, n, u) {
  return "<!" + (u.settings.upperDoctype ? "DOCTYPE" : "doctype") + (u.settings.tightDoctype ? "" : " ") + "html>";
}
function Au(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let u = 0, r = n.indexOf(t);
  for (; r !== -1; )
    u++, r = n.indexOf(t, r + t.length);
  return u;
}
function uc(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
function rc(e) {
  return e.join(" ").trim();
}
const ic = /[ \t\n\f\r]/g;
function Pn(e) {
  return typeof e == "object" ? e.type === "text" ? Eu(e.value) : !1 : Eu(e);
}
function Eu(e) {
  return e.replace(ic, "") === "";
}
const I = jr(1), Br = jr(-1), ac = [];
function jr(e) {
  return t;
  function t(n, u, r) {
    const i = n ? n.children : ac;
    let a = (u || 0) + e, o = i[a];
    if (!r)
      for (; o && Pn(o); )
        a += e, o = i[a];
    return o;
  }
}
const oc = {}.hasOwnProperty;
function zr(e) {
  return t;
  function t(n, u, r) {
    return oc.call(e, n.tagName) && e[n.tagName](n, u, r);
  }
}
const Nn = zr({
  body: lc,
  caption: Qt,
  colgroup: Qt,
  dd: hc,
  dt: fc,
  head: Qt,
  html: sc,
  li: dc,
  optgroup: pc,
  option: mc,
  p: cc,
  rp: Su,
  rt: Su,
  tbody: _c,
  td: Du,
  tfoot: bc,
  th: Du,
  thead: gc,
  tr: yc
});
function Qt(e, t, n) {
  const u = I(n, t, !0);
  return !u || u.type !== "comment" && !(u.type === "text" && Pn(u.value.charAt(0)));
}
function sc(e, t, n) {
  const u = I(n, t);
  return !u || u.type !== "comment";
}
function lc(e, t, n) {
  const u = I(n, t);
  return !u || u.type !== "comment";
}
function cc(e, t, n) {
  const u = I(n, t);
  return u ? u.type === "element" && (u.tagName === "address" || u.tagName === "article" || u.tagName === "aside" || u.tagName === "blockquote" || u.tagName === "details" || u.tagName === "div" || u.tagName === "dl" || u.tagName === "fieldset" || u.tagName === "figcaption" || u.tagName === "figure" || u.tagName === "footer" || u.tagName === "form" || u.tagName === "h1" || u.tagName === "h2" || u.tagName === "h3" || u.tagName === "h4" || u.tagName === "h5" || u.tagName === "h6" || u.tagName === "header" || u.tagName === "hgroup" || u.tagName === "hr" || u.tagName === "main" || u.tagName === "menu" || u.tagName === "nav" || u.tagName === "ol" || u.tagName === "p" || u.tagName === "pre" || u.tagName === "section" || u.tagName === "table" || u.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function dc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && u.tagName === "li";
}
function fc(e, t, n) {
  const u = I(n, t);
  return !!(u && u.type === "element" && (u.tagName === "dt" || u.tagName === "dd"));
}
function hc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "dt" || u.tagName === "dd");
}
function Su(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "rp" || u.tagName === "rt");
}
function pc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && u.tagName === "optgroup";
}
function mc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "option" || u.tagName === "optgroup");
}
function gc(e, t, n) {
  const u = I(n, t);
  return !!(u && u.type === "element" && (u.tagName === "tbody" || u.tagName === "tfoot"));
}
function _c(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "tbody" || u.tagName === "tfoot");
}
function bc(e, t, n) {
  return !I(n, t);
}
function yc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && u.tagName === "tr";
}
function Du(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "td" || u.tagName === "th");
}
const kc = zr({
  body: Cc,
  colgroup: vc,
  head: wc,
  html: xc,
  tbody: Ac
});
function xc(e) {
  const t = I(e, -1);
  return !t || t.type !== "comment";
}
function wc(e) {
  const t = /* @__PURE__ */ new Set();
  for (const u of e.children)
    if (u.type === "element" && (u.tagName === "base" || u.tagName === "title")) {
      if (t.has(u.tagName)) return !1;
      t.add(u.tagName);
    }
  const n = e.children[0];
  return !n || n.type === "element";
}
function Cc(e) {
  const t = I(e, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && Pn(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function vc(e, t, n) {
  const u = Br(n, t), r = I(e, -1, !0);
  return n && u && u.type === "element" && u.tagName === "colgroup" && Nn(u, n.children.indexOf(u), n) ? !1 : !!(r && r.type === "element" && r.tagName === "col");
}
function Ac(e, t, n) {
  const u = Br(n, t), r = I(e, -1);
  return n && u && u.type === "element" && (u.tagName === "thead" || u.tagName === "tbody") && Nn(u, n.children.indexOf(u), n) ? !1 : !!(r && r.type === "element" && r.tagName === "tr");
}
const it = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Ec(e, t, n, u) {
  const r = u.schema, i = r.space === "svg" ? !1 : u.settings.omitOptionalTags;
  let a = r.space === "svg" ? u.settings.closeEmptyElements : u.settings.voids.includes(e.tagName.toLowerCase());
  const o = [];
  let s;
  r.space === "html" && e.tagName === "svg" && (u.schema = Mr);
  const l = Sc(u, e.properties), c = u.all(
    r.space === "html" && e.tagName === "template" ? e.content : e
  );
  return u.schema = r, c && (a = !1), (l || !i || !kc(e, t, n)) && (o.push("<", e.tagName, l ? " " + l : ""), a && (r.space === "svg" || u.settings.closeSelfClosing) && (s = l.charAt(l.length - 1), (!u.settings.tightSelfClosing || s === "/" || s && s !== '"' && s !== "'") && o.push(" "), o.push("/")), o.push(">")), o.push(c), !a && (!i || !Nn(e, t, n)) && o.push("</" + e.tagName + ">"), o.join("");
}
function Sc(e, t) {
  const n = [];
  let u = -1, r;
  if (t) {
    for (r in t)
      if (t[r] !== null && t[r] !== void 0) {
        const i = Dc(e, r, t[r]);
        i && n.push(i);
      }
  }
  for (; ++u < n.length; ) {
    const i = e.settings.tightAttributes ? n[u].charAt(n[u].length - 1) : void 0;
    u !== n.length - 1 && i !== '"' && i !== "'" && (n[u] += " ");
  }
  return n.join("");
}
function Dc(e, t, n) {
  const u = Rl(e.schema, t), r = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1, i = e.settings.allowDangerousCharacters ? 0 : 1;
  let a = e.quote, o;
  if (u.overloadedBoolean && (n === u.attribute || n === "") ? n = !0 : (u.boolean || u.overloadedBoolean) && (typeof n != "string" || n === u.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const s = Se(
    u.attribute,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: it.name[r][i]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (u.commaSeparated ? uc : rc)(n, {
    padLeft: !e.settings.tightCommaSeparatedLists
  }) : String(n), e.settings.collapseEmptyAttributes && !n) ? s : (e.settings.preferUnquoted && (o = Se(
    n,
    Object.assign({}, e.settings.characterReferences, {
      attribute: !0,
      subset: it.unquoted[r][i]
    })
  )), o !== n && (e.settings.quoteSmart && Au(n, a) > Au(n, e.alternative) && (a = e.alternative), o = a + Se(
    n,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (a === "'" ? it.single : it.double)[r][i],
      attribute: !0
    })
  ) + a), s + (o && "=" + o));
}
const Fc = ["<", "&"];
function $r(e, t, n, u) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? e.value : Se(
    e.value,
    Object.assign({}, u.settings.characterReferences, {
      subset: Fc
    })
  );
}
function Tc(e, t, n, u) {
  return u.settings.allowDangerousHtml ? e.value : $r(e, t, n, u);
}
function Rc(e, t, n, u) {
  return u.all(e);
}
const Lc = Il("type", {
  invalid: Pc,
  unknown: Nc,
  handlers: { comment: tc, doctype: nc, element: Ec, raw: Tc, root: Rc, text: $r }
});
function Pc(e) {
  throw new Error("Expected node, not `" + e + "`");
}
function Nc(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
const Ic = {}, Mc = {}, Oc = [];
function Bc(e, t) {
  const n = t || Ic, u = n.quote || '"', r = u === '"' ? "'" : '"';
  if (u !== '"' && u !== "'")
    throw new Error("Invalid quote `" + u + "`, expected `'` or `\"`");
  return {
    one: jc,
    all: zc,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || Al,
      characterReferences: n.characterReferences || Mc,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? Mr : Nl,
    quote: u,
    alternative: r
  }.one(
    Array.isArray(e) ? { type: "root", children: e } : e,
    void 0,
    void 0
  );
}
function jc(e, t, n) {
  return Lc(e, t, n, this);
}
function zc(e) {
  const t = [], n = e && e.children || Oc;
  let u = -1;
  for (; ++u < n.length; )
    t[u] = this.one(n[u], u, e);
  return t.join("");
}
function kt(e, t) {
  const n = typeof e == "string" ? {} : { ...e.colorReplacements }, u = typeof e == "string" ? e : e.name;
  for (const [r, i] of Object.entries((t == null ? void 0 : t.colorReplacements) || {}))
    typeof i == "string" ? n[r] = i : r === u && Object.assign(n, i);
  return n;
}
function be(e, t) {
  return e && ((t == null ? void 0 : t[e == null ? void 0 : e.toLowerCase()]) || e);
}
function $c(e) {
  return Array.isArray(e) ? e : [e];
}
async function qr(e) {
  return Promise.resolve(typeof e == "function" ? e() : e).then((t) => t.default || t);
}
function In(e) {
  return !e || ["plaintext", "txt", "text", "plain"].includes(e);
}
function Gr(e) {
  return e === "ansi" || In(e);
}
function Mn(e) {
  return e === "none";
}
function Hr(e) {
  return Mn(e);
}
function Ur(e, t) {
  var u;
  if (!t)
    return e;
  e.properties || (e.properties = {}), (u = e.properties).class || (u.class = []), typeof e.properties.class == "string" && (e.properties.class = e.properties.class.split(/\s+/g)), Array.isArray(e.properties.class) || (e.properties.class = []);
  const n = Array.isArray(t) ? t : t.split(/\s+/g);
  for (const r of n)
    r && !e.properties.class.includes(r) && e.properties.class.push(r);
  return e;
}
function Lt(e, t = !1) {
  var i;
  const n = e.split(/(\r?\n)/g);
  let u = 0;
  const r = [];
  for (let a = 0; a < n.length; a += 2) {
    const o = t ? n[a] + (n[a + 1] || "") : n[a];
    r.push([o, u]), u += n[a].length, u += ((i = n[a + 1]) == null ? void 0 : i.length) || 0;
  }
  return r;
}
function qc(e) {
  const t = Lt(e, !0).map(([r]) => r);
  function n(r) {
    if (r === e.length)
      return {
        line: t.length - 1,
        character: t[t.length - 1].length
      };
    let i = r, a = 0;
    for (const o of t) {
      if (i < o.length)
        break;
      i -= o.length, a++;
    }
    return { line: a, character: i };
  }
  function u(r, i) {
    let a = 0;
    for (let o = 0; o < r; o++)
      a += t[o].length;
    return a += i, a;
  }
  return {
    lines: t,
    indexToPos: n,
    posToIndex: u
  };
}
function Gc(e, t) {
  let n = 0;
  const u = [];
  for (const r of t)
    r > n && u.push({
      ...e,
      content: e.content.slice(n, r),
      offset: e.offset + n
    }), n = r;
  return n < e.content.length && u.push({
    ...e,
    content: e.content.slice(n),
    offset: e.offset + n
  }), u;
}
function Hc(e, t) {
  const n = Array.from(t instanceof Set ? t : new Set(t)).sort((u, r) => u - r);
  return n.length ? e.map((u) => u.flatMap((r) => {
    const i = n.filter((a) => r.offset < a && a < r.offset + r.content.length).map((a) => a - r.offset).sort((a, o) => a - o);
    return i.length ? Gc(r, i) : r;
  })) : e;
}
function Uc(e, t, n, u) {
  const r = {
    content: e.content,
    explanation: e.explanation,
    offset: e.offset
  }, i = t.map((s) => Wr(e.variants[s])), a = new Set(i.flatMap((s) => Object.keys(s))), o = {};
  return i.forEach((s, l) => {
    for (const c of a) {
      const d = s[c] || "inherit";
      if (l === 0 && u)
        o[c] = d;
      else {
        const f = c === "color" ? "" : c === "background-color" ? "-bg" : `-${c}`, p = n + t[l] + (c === "color" ? "" : f);
        o[p] = d;
      }
    }
  }), r.htmlStyle = o, r;
}
function Wr(e) {
  const t = {};
  return e.color && (t.color = e.color), e.bgColor && (t["background-color"] = e.bgColor), e.fontStyle && (e.fontStyle & ce.Italic && (t["font-style"] = "italic"), e.fontStyle & ce.Bold && (t["font-weight"] = "bold"), e.fontStyle & ce.Underline && (t["text-decoration"] = "underline")), t;
}
function Wc(e) {
  return typeof e == "string" ? e : Object.entries(e).map(([t, n]) => `${t}:${n}`).join(";");
}
const Vr = /* @__PURE__ */ new WeakMap();
function Pt(e, t) {
  Vr.set(e, t);
}
function Ze(e) {
  return Vr.get(e);
}
class Ne {
  constructor(...t) {
    /**
     * Theme to Stack mapping
     */
    k(this, "_stacks", {});
    k(this, "lang");
    if (t.length === 2) {
      const [n, u] = t;
      this.lang = u, this._stacks = n;
    } else {
      const [n, u, r] = t;
      this.lang = u, this._stacks = { [r]: n };
    }
  }
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(t, n) {
    return new Ne(
      Object.fromEntries($c(n).map((u) => [u, mn])),
      t
    );
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(t = this.theme) {
    return this._stacks[t];
  }
  getScopes(t = this.theme) {
    return Vc(this._stacks[t]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
}
function Vc(e) {
  const t = [], n = /* @__PURE__ */ new Set();
  function u(r) {
    var a;
    if (n.has(r))
      return;
    n.add(r);
    const i = (a = r == null ? void 0 : r.nameScopesList) == null ? void 0 : a.scopeName;
    i && t.push(i), r.parent && u(r.parent);
  }
  return u(e), t;
}
function Zc(e, t) {
  if (!(e instanceof Ne))
    throw new j("Invalid grammar state");
  return e.getInternalStack(t);
}
function Jc() {
  const e = /* @__PURE__ */ new WeakMap();
  function t(n) {
    if (!e.has(n.meta)) {
      let u = function(a) {
        if (typeof a == "number") {
          if (a < 0 || a > n.source.length)
            throw new j(`Invalid decoration offset: ${a}. Code length: ${n.source.length}`);
          return {
            ...r.indexToPos(a),
            offset: a
          };
        } else {
          const o = r.lines[a.line];
          if (o === void 0)
            throw new j(`Invalid decoration position ${JSON.stringify(a)}. Lines length: ${r.lines.length}`);
          if (a.character < 0 || a.character > o.length)
            throw new j(`Invalid decoration position ${JSON.stringify(a)}. Line ${a.line} length: ${o.length}`);
          return {
            ...a,
            offset: r.posToIndex(a.line, a.character)
          };
        }
      };
      const r = qc(n.source), i = (n.options.decorations || []).map((a) => ({
        ...a,
        start: u(a.start),
        end: u(a.end)
      }));
      Kc(i), e.set(n.meta, {
        decorations: i,
        converter: r,
        source: n.source
      });
    }
    return e.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      var a;
      if (!((a = this.options.decorations) != null && a.length))
        return;
      const r = t(this).decorations.flatMap((o) => [o.start.offset, o.end.offset]);
      return Hc(n, r);
    },
    code(n) {
      var c;
      if (!((c = this.options.decorations) != null && c.length))
        return;
      const u = t(this), r = Array.from(n.children).filter((d) => d.type === "element" && d.tagName === "span");
      if (r.length !== u.converter.lines.length)
        throw new j(`Number of lines in code element (${r.length}) does not match the number of lines in the source (${u.converter.lines.length}). Failed to apply decorations.`);
      function i(d, f, p, h) {
        const g = r[d];
        let m = "", b = -1, _ = -1;
        if (f === 0 && (b = 0), p === 0 && (_ = 0), p === Number.POSITIVE_INFINITY && (_ = g.children.length), b === -1 || _ === -1)
          for (let x = 0; x < g.children.length; x++)
            m += Zr(g.children[x]), b === -1 && m.length === f && (b = x + 1), _ === -1 && m.length === p && (_ = x + 1);
        if (b === -1)
          throw new j(`Failed to find start index for decoration ${JSON.stringify(h.start)}`);
        if (_ === -1)
          throw new j(`Failed to find end index for decoration ${JSON.stringify(h.end)}`);
        const y = g.children.slice(b, _);
        if (!h.alwaysWrap && y.length === g.children.length)
          o(g, h, "line");
        else if (!h.alwaysWrap && y.length === 1 && y[0].type === "element")
          o(y[0], h, "token");
        else {
          const x = {
            type: "element",
            tagName: "span",
            properties: {},
            children: y
          };
          o(x, h, "wrapper"), g.children.splice(b, y.length, x);
        }
      }
      function a(d, f) {
        r[d] = o(r[d], f, "line");
      }
      function o(d, f, p) {
        var m;
        const h = f.properties || {}, g = f.transform || ((b) => b);
        return d.tagName = f.tagName || "span", d.properties = {
          ...d.properties,
          ...h,
          class: d.properties.class
        }, (m = f.properties) != null && m.class && Ur(d, f.properties.class), d = g(d, p) || d, d;
      }
      const s = [], l = u.decorations.sort((d, f) => f.start.offset - d.start.offset || d.end.offset - f.end.offset);
      for (const d of l) {
        const { start: f, end: p } = d;
        if (f.line === p.line)
          i(f.line, f.character, p.character, d);
        else if (f.line < p.line) {
          i(f.line, f.character, Number.POSITIVE_INFINITY, d);
          for (let h = f.line + 1; h < p.line; h++)
            s.unshift(() => a(h, d));
          i(p.line, 0, p.character, d);
        }
      }
      s.forEach((d) => d());
    }
  };
}
function Kc(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (n.start.offset > n.end.offset)
      throw new j(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let u = t + 1; u < e.length; u++) {
      const r = e[u], i = n.start.offset <= r.start.offset && r.start.offset < n.end.offset, a = n.start.offset < r.end.offset && r.end.offset <= n.end.offset, o = r.start.offset <= n.start.offset && n.start.offset < r.end.offset, s = r.start.offset < n.end.offset && n.end.offset <= r.end.offset;
      if (i || a || o || s) {
        if (i && a || o && s)
          continue;
        throw new j(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(r.start)} intersect.`);
      }
    }
  }
}
function Zr(e) {
  return e.type === "text" ? e.value : e.type === "element" ? e.children.map(Zr).join("") : "";
}
const Qc = [
  /* @__PURE__ */ Jc()
];
function xt(e) {
  return [
    ...e.transformers || [],
    ...Qc
  ];
}
var ye = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], Xt = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function Xc(e, t) {
  const n = e.indexOf("\x1B", t);
  if (n !== -1 && e[n + 1] === "[") {
    const u = e.indexOf("m", n);
    if (u !== -1)
      return {
        sequence: e.substring(n + 2, u).split(";"),
        startPosition: n,
        position: u + 1
      };
  }
  return {
    position: e.length
  };
}
function Fu(e) {
  const t = e.shift();
  if (t === "2") {
    const n = e.splice(0, 3).map((u) => Number.parseInt(u));
    return n.length !== 3 || n.some((u) => Number.isNaN(u)) ? void 0 : {
      type: "rgb",
      rgb: n
    };
  } else if (t === "5") {
    const n = e.shift();
    if (n)
      return { type: "table", index: Number(n) };
  }
}
function Yc(e) {
  const t = [];
  for (; e.length > 0; ) {
    const n = e.shift();
    if (!n)
      continue;
    const u = Number.parseInt(n);
    if (!Number.isNaN(u))
      if (u === 0)
        t.push({ type: "resetAll" });
      else if (u <= 9)
        Xt[u] && t.push({
          type: "setDecoration",
          value: Xt[u]
        });
      else if (u <= 29) {
        const r = Xt[u - 20];
        r && (t.push({
          type: "resetDecoration",
          value: r
        }), r === "dim" && t.push({
          type: "resetDecoration",
          value: "bold"
        }));
      } else if (u <= 37)
        t.push({
          type: "setForegroundColor",
          value: { type: "named", name: ye[u - 30] }
        });
      else if (u === 38) {
        const r = Fu(e);
        r && t.push({
          type: "setForegroundColor",
          value: r
        });
      } else if (u === 39)
        t.push({
          type: "resetForegroundColor"
        });
      else if (u <= 47)
        t.push({
          type: "setBackgroundColor",
          value: { type: "named", name: ye[u - 40] }
        });
      else if (u === 48) {
        const r = Fu(e);
        r && t.push({
          type: "setBackgroundColor",
          value: r
        });
      } else u === 49 ? t.push({
        type: "resetBackgroundColor"
      }) : u === 53 ? t.push({
        type: "setDecoration",
        value: "overline"
      }) : u === 55 ? t.push({
        type: "resetDecoration",
        value: "overline"
      }) : u >= 90 && u <= 97 ? t.push({
        type: "setForegroundColor",
        value: { type: "named", name: ye[u - 90 + 8] }
      }) : u >= 100 && u <= 107 && t.push({
        type: "setBackgroundColor",
        value: { type: "named", name: ye[u - 100 + 8] }
      });
  }
  return t;
}
function e0() {
  let e = null, t = null, n = /* @__PURE__ */ new Set();
  return {
    parse(u) {
      const r = [];
      let i = 0;
      do {
        const a = Xc(u, i), o = a.sequence ? u.substring(i, a.startPosition) : u.substring(i);
        if (o.length > 0 && r.push({
          value: o,
          foreground: e,
          background: t,
          decorations: new Set(n)
        }), a.sequence) {
          const s = Yc(a.sequence);
          for (const l of s)
            l.type === "resetAll" ? (e = null, t = null, n.clear()) : l.type === "resetForegroundColor" ? e = null : l.type === "resetBackgroundColor" ? t = null : l.type === "resetDecoration" && n.delete(l.value);
          for (const l of s)
            l.type === "setForegroundColor" ? e = l.value : l.type === "setBackgroundColor" ? t = l.value : l.type === "setDecoration" && n.add(l.value);
        }
        i = a.position;
      } while (i < u.length);
      return r;
    }
  };
}
var t0 = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function n0(e = t0) {
  function t(o) {
    return e[o];
  }
  function n(o) {
    return `#${o.map((s) => Math.max(0, Math.min(s, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let u;
  function r() {
    if (u)
      return u;
    u = [];
    for (let l = 0; l < ye.length; l++)
      u.push(t(ye[l]));
    let o = [0, 95, 135, 175, 215, 255];
    for (let l = 0; l < 6; l++)
      for (let c = 0; c < 6; c++)
        for (let d = 0; d < 6; d++)
          u.push(n([o[l], o[c], o[d]]));
    let s = 8;
    for (let l = 0; l < 24; l++, s += 10)
      u.push(n([s, s, s]));
    return u;
  }
  function i(o) {
    return r()[o];
  }
  function a(o) {
    switch (o.type) {
      case "named":
        return t(o.name);
      case "rgb":
        return n(o.rgb);
      case "table":
        return i(o.index);
    }
  }
  return {
    value: a
  };
}
function u0(e, t, n) {
  const u = kt(e, n), r = Lt(t), i = n0(
    Object.fromEntries(
      ye.map((o) => {
        var s;
        return [
          o,
          (s = e.colors) == null ? void 0 : s[`terminal.ansi${o[0].toUpperCase()}${o.substring(1)}`]
        ];
      })
    )
  ), a = e0();
  return r.map(
    (o) => a.parse(o[0]).map((s) => {
      let l, c;
      s.decorations.has("reverse") ? (l = s.background ? i.value(s.background) : e.bg, c = s.foreground ? i.value(s.foreground) : e.fg) : (l = s.foreground ? i.value(s.foreground) : e.fg, c = s.background ? i.value(s.background) : void 0), l = be(l, u), c = be(c, u), s.decorations.has("dim") && (l = r0(l));
      let d = ce.None;
      return s.decorations.has("bold") && (d |= ce.Bold), s.decorations.has("italic") && (d |= ce.Italic), s.decorations.has("underline") && (d |= ce.Underline), {
        content: s.value,
        offset: o[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: l,
        bgColor: c,
        fontStyle: d
      };
    })
  );
}
function r0(e) {
  const t = e.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (t)
    if (t[3]) {
      const u = Math.round(Number.parseInt(t[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${t[1]}${t[2]}${u}`;
    } else return t[2] ? `#${t[1]}${t[2]}80` : `#${Array.from(t[1]).map((u) => `${u}${u}`).join("")}80`;
  const n = e.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : e;
}
function On(e, t, n = {}) {
  const {
    lang: u = "text",
    theme: r = e.getLoadedThemes()[0]
  } = n;
  if (In(u) || Mn(r))
    return Lt(t).map((s) => [{ content: s[0], offset: s[1] }]);
  const { theme: i, colorMap: a } = e.setTheme(r);
  if (u === "ansi")
    return u0(i, t, n);
  const o = e.getLanguage(u);
  if (n.grammarState) {
    if (n.grammarState.lang !== o.name)
      throw new j(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${o.name}"`);
    if (!n.grammarState.themes.includes(i.name))
      throw new j(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${i.name}"`);
  }
  return a0(t, o, i, a, n);
}
function i0(...e) {
  if (e.length === 2)
    return Ze(e[1]);
  const [t, n, u = {}] = e, {
    lang: r = "text",
    theme: i = t.getLoadedThemes()[0]
  } = u;
  if (In(r) || Mn(i))
    throw new j("Plain language does not have grammar state");
  if (r === "ansi")
    throw new j("ANSI language does not have grammar state");
  const { theme: a, colorMap: o } = t.setTheme(i), s = t.getLanguage(r);
  return new Ne(
    wt(n, s, a, o, u).stateStack,
    s.name,
    a.name
  );
}
function a0(e, t, n, u, r) {
  const i = wt(e, t, n, u, r), a = new Ne(
    wt(e, t, n, u, r).stateStack,
    t.name,
    n.name
  );
  return Pt(i.tokens, a), i.tokens;
}
function wt(e, t, n, u, r) {
  const i = kt(n, r), {
    tokenizeMaxLineLength: a = 0,
    tokenizeTimeLimit: o = 500
  } = r, s = Lt(e);
  let l = r.grammarState ? Zc(r.grammarState, n.name) ?? mn : r.grammarContextCode != null ? wt(
    r.grammarContextCode,
    t,
    n,
    u,
    {
      ...r,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : mn, c = [];
  const d = [];
  for (let f = 0, p = s.length; f < p; f++) {
    const [h, g] = s[f];
    if (h === "") {
      c = [], d.push([]);
      continue;
    }
    if (a > 0 && h.length >= a) {
      c = [], d.push([{
        content: h,
        offset: g,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let m, b, _;
    r.includeExplanation && (m = t.tokenizeLine(h, l, o), b = m.tokens, _ = 0);
    const y = t.tokenizeLine2(h, l, o), x = y.tokens.length / 2;
    for (let C = 0; C < x; C++) {
      const v = y.tokens[2 * C], A = C + 1 < x ? y.tokens[2 * C + 2] : h.length;
      if (v === A)
        continue;
      const S = y.tokens[2 * C + 1], L = be(
        u[Re.getForeground(S)],
        i
      ), M = Re.getFontStyle(S), Z = {
        content: h.substring(v, A),
        offset: g + v,
        color: L,
        fontStyle: M
      };
      if (r.includeExplanation) {
        const P = [];
        if (r.includeExplanation !== "scopeName")
          for (const D of n.settings) {
            let G;
            switch (typeof D.scope) {
              case "string":
                G = D.scope.split(/,/).map((Ie) => Ie.trim());
                break;
              case "object":
                G = D.scope;
                break;
              default:
                continue;
            }
            P.push({
              settings: D,
              selectors: G.map((Ie) => Ie.split(/ /))
            });
          }
        Z.explanation = [];
        let $ = 0;
        for (; v + $ < A; ) {
          const D = b[_], G = h.substring(
            D.startIndex,
            D.endIndex
          );
          $ += G.length, Z.explanation.push({
            content: G,
            scopes: r.includeExplanation === "scopeName" ? o0(
              D.scopes
            ) : s0(
              P,
              D.scopes
            )
          }), _ += 1;
        }
      }
      c.push(Z);
    }
    d.push(c), c = [], l = y.ruleStack;
  }
  return {
    tokens: d,
    stateStack: l
  };
}
function o0(e) {
  return e.map((t) => ({ scopeName: t }));
}
function s0(e, t) {
  const n = [];
  for (let u = 0, r = t.length; u < r; u++) {
    const i = t[u];
    n[u] = {
      scopeName: i,
      themeMatches: c0(e, i, t.slice(0, u))
    };
  }
  return n;
}
function Tu(e, t) {
  return e === t || t.substring(0, e.length) === e && t[e.length] === ".";
}
function l0(e, t, n) {
  if (!Tu(e[e.length - 1], t))
    return !1;
  let u = e.length - 2, r = n.length - 1;
  for (; u >= 0 && r >= 0; )
    Tu(e[u], n[r]) && (u -= 1), r -= 1;
  return u === -1;
}
function c0(e, t, n) {
  const u = [];
  for (const { selectors: r, settings: i } of e)
    for (const a of r)
      if (l0(a, t, n)) {
        u.push(i);
        break;
      }
  return u;
}
function Jr(e, t, n) {
  const u = Object.entries(n.themes).filter((s) => s[1]).map((s) => ({ color: s[0], theme: s[1] })), r = u.map((s) => {
    const l = On(e, t, {
      ...n,
      theme: s.theme
    }), c = Ze(l), d = typeof s.theme == "string" ? s.theme : s.theme.name;
    return {
      tokens: l,
      state: c,
      theme: d
    };
  }), i = d0(
    ...r.map((s) => s.tokens)
  ), a = i[0].map(
    (s, l) => s.map((c, d) => {
      const f = {
        content: c.content,
        variants: {},
        offset: c.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (f.explanation = c.explanation), i.forEach((p, h) => {
        const {
          content: g,
          explanation: m,
          offset: b,
          ..._
        } = p[l][d];
        f.variants[u[h].color] = _;
      }), f;
    })
  ), o = r[0].state ? new Ne(
    Object.fromEntries(r.map((s) => {
      var l;
      return [s.theme, (l = s.state) == null ? void 0 : l.getInternalStack(s.theme)];
    })),
    r[0].state.lang
  ) : void 0;
  return o && Pt(a, o), a;
}
function d0(...e) {
  const t = e.map(() => []), n = e.length;
  for (let u = 0; u < e[0].length; u++) {
    const r = e.map((s) => s[u]), i = t.map(() => []);
    t.forEach((s, l) => s.push(i[l]));
    const a = r.map(() => 0), o = r.map((s) => s[0]);
    for (; o.every((s) => s); ) {
      const s = Math.min(...o.map((l) => l.content.length));
      for (let l = 0; l < n; l++) {
        const c = o[l];
        c.content.length === s ? (i[l].push(c), a[l] += 1, o[l] = r[l][a[l]]) : (i[l].push({
          ...c,
          content: c.content.slice(0, s)
        }), o[l] = {
          ...c,
          content: c.content.slice(s),
          offset: c.offset + s
        });
      }
    }
  }
  return t;
}
function Ct(e, t, n) {
  let u, r, i, a, o, s;
  if ("themes" in n) {
    const {
      defaultColor: l = "light",
      cssVariablePrefix: c = "--shiki-"
    } = n, d = Object.entries(n.themes).filter((m) => m[1]).map((m) => ({ color: m[0], theme: m[1] })).sort((m, b) => m.color === l ? -1 : b.color === l ? 1 : 0);
    if (d.length === 0)
      throw new j("`themes` option must not be empty");
    const f = Jr(
      e,
      t,
      n
    );
    if (s = Ze(f), l && !d.find((m) => m.color === l))
      throw new j(`\`themes\` option must contain the defaultColor key \`${l}\``);
    const p = d.map((m) => e.getTheme(m.theme)), h = d.map((m) => m.color);
    i = f.map((m) => m.map((b) => Uc(b, h, c, l))), s && Pt(i, s);
    const g = d.map((m) => kt(m.theme, n));
    r = d.map((m, b) => (b === 0 && l ? "" : `${c + m.color}:`) + (be(p[b].fg, g[b]) || "inherit")).join(";"), u = d.map((m, b) => (b === 0 && l ? "" : `${c + m.color}-bg:`) + (be(p[b].bg, g[b]) || "inherit")).join(";"), a = `shiki-themes ${p.map((m) => m.name).join(" ")}`, o = l ? void 0 : [r, u].join(";");
  } else if ("theme" in n) {
    const l = kt(n.theme, n);
    i = On(
      e,
      t,
      n
    );
    const c = e.getTheme(n.theme);
    u = be(c.bg, l), r = be(c.fg, l), a = c.name, s = Ze(i);
  } else
    throw new j("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: i,
    fg: r,
    bg: u,
    themeName: a,
    rootStyle: o,
    grammarState: s
  };
}
function vt(e, t, n, u = {
  meta: {},
  options: n,
  codeToHast: (r, i) => vt(e, r, i),
  codeToTokens: (r, i) => Ct(e, r, i)
}) {
  var p, h;
  let r = t;
  for (const g of xt(n))
    r = ((p = g.preprocess) == null ? void 0 : p.call(u, r, n)) || r;
  let {
    tokens: i,
    fg: a,
    bg: o,
    themeName: s,
    rootStyle: l,
    grammarState: c
  } = Ct(e, r, n);
  const {
    mergeWhitespaces: d = !0
  } = n;
  d === !0 ? i = h0(i) : d === "never" && (i = p0(i));
  const f = {
    ...u,
    get source() {
      return r;
    }
  };
  for (const g of xt(n))
    i = ((h = g.tokens) == null ? void 0 : h.call(f, i)) || i;
  return f0(
    i,
    {
      ...n,
      fg: a,
      bg: o,
      themeName: s,
      rootStyle: l
    },
    f,
    c
  );
}
function f0(e, t, n, u = Ze(e)) {
  var h, g, m;
  const r = xt(t), i = [], a = {
    type: "root",
    children: []
  }, {
    structure: o = "classic",
    tabindex: s = "0"
  } = t;
  let l = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${t.themeName || ""}`,
      style: t.rootStyle || `background-color:${t.bg};color:${t.fg}`,
      ...s !== !1 && s != null ? {
        tabindex: s.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(t.meta || {})
        ).filter(([b]) => !b.startsWith("_"))
      )
    },
    children: []
  }, c = {
    type: "element",
    tagName: "code",
    properties: {},
    children: i
  };
  const d = [], f = {
    ...n,
    structure: o,
    addClassToHast: Ur,
    get source() {
      return n.source;
    },
    get tokens() {
      return e;
    },
    get options() {
      return t;
    },
    get root() {
      return a;
    },
    get pre() {
      return l;
    },
    get code() {
      return c;
    },
    get lines() {
      return d;
    }
  };
  if (e.forEach((b, _) => {
    var C, v;
    _ && (o === "inline" ? a.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : o === "classic" && i.push({ type: "text", value: `
` }));
    let y = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, x = 0;
    for (const A of b) {
      let S = {
        type: "element",
        tagName: "span",
        properties: {
          ...A.htmlAttrs
        },
        children: [{ type: "text", value: A.content }]
      };
      const L = Wc(A.htmlStyle || Wr(A));
      L && (S.properties.style = L);
      for (const M of r)
        S = ((C = M == null ? void 0 : M.span) == null ? void 0 : C.call(f, S, _ + 1, x, y, A)) || S;
      o === "inline" ? a.children.push(S) : o === "classic" && y.children.push(S), x += A.content.length;
    }
    if (o === "classic") {
      for (const A of r)
        y = ((v = A == null ? void 0 : A.line) == null ? void 0 : v.call(f, y, _ + 1)) || y;
      d.push(y), i.push(y);
    }
  }), o === "classic") {
    for (const b of r)
      c = ((h = b == null ? void 0 : b.code) == null ? void 0 : h.call(f, c)) || c;
    l.children.push(c);
    for (const b of r)
      l = ((g = b == null ? void 0 : b.pre) == null ? void 0 : g.call(f, l)) || l;
    a.children.push(l);
  }
  let p = a;
  for (const b of r)
    p = ((m = b == null ? void 0 : b.root) == null ? void 0 : m.call(f, p)) || p;
  return u && Pt(p, u), p;
}
function h0(e) {
  return e.map((t) => {
    const n = [];
    let u = "", r = 0;
    return t.forEach((i, a) => {
      const s = !(i.fontStyle && i.fontStyle & ce.Underline);
      s && i.content.match(/^\s+$/) && t[a + 1] ? (r || (r = i.offset), u += i.content) : u ? (s ? n.push({
        ...i,
        offset: r,
        content: u + i.content
      }) : n.push(
        {
          content: u,
          offset: r
        },
        i
      ), r = 0, u = "") : n.push(i);
    }), n;
  });
}
function p0(e) {
  return e.map((t) => t.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const u = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!u)
      return n;
    const [, r, i, a] = u;
    if (!r && !a)
      return n;
    const o = [{
      ...n,
      offset: n.offset + r.length,
      content: i
    }];
    return r && o.unshift({
      content: r,
      offset: n.offset
    }), a && o.push({
      content: a,
      offset: n.offset + r.length + i.length
    }), o;
  }));
}
const m0 = Bc;
function g0(e, t, n) {
  var i;
  const u = {
    meta: {},
    options: n,
    codeToHast: (a, o) => vt(e, a, o),
    codeToTokens: (a, o) => Ct(e, a, o)
  };
  let r = m0(vt(e, t, n, u));
  for (const a of xt(n))
    r = ((i = a.postprocess) == null ? void 0 : i.call(u, r, n)) || r;
  return r;
}
const Ru = { light: "#333333", dark: "#bbbbbb" }, Lu = { light: "#fffffe", dark: "#1e1e1e" }, Pu = "__shiki_resolved";
function Bn(e) {
  var o, s, l, c, d;
  if (e != null && e[Pu])
    return e;
  const t = {
    ...e
  };
  t.tokenColors && !t.settings && (t.settings = t.tokenColors, delete t.tokenColors), t.type || (t.type = "dark"), t.colorReplacements = { ...t.colorReplacements }, t.settings || (t.settings = []);
  let { bg: n, fg: u } = t;
  if (!n || !u) {
    const f = t.settings ? t.settings.find((p) => !p.name && !p.scope) : void 0;
    (o = f == null ? void 0 : f.settings) != null && o.foreground && (u = f.settings.foreground), (s = f == null ? void 0 : f.settings) != null && s.background && (n = f.settings.background), !u && ((l = t == null ? void 0 : t.colors) != null && l["editor.foreground"]) && (u = t.colors["editor.foreground"]), !n && ((c = t == null ? void 0 : t.colors) != null && c["editor.background"]) && (n = t.colors["editor.background"]), u || (u = t.type === "light" ? Ru.light : Ru.dark), n || (n = t.type === "light" ? Lu.light : Lu.dark), t.fg = u, t.bg = n;
  }
  t.settings[0] && t.settings[0].settings && !t.settings[0].scope || t.settings.unshift({
    settings: {
      foreground: t.fg,
      background: t.bg
    }
  });
  let r = 0;
  const i = /* @__PURE__ */ new Map();
  function a(f) {
    var h;
    if (i.has(f))
      return i.get(f);
    r += 1;
    const p = `#${r.toString(16).padStart(8, "0").toLowerCase()}`;
    return (h = t.colorReplacements) != null && h[`#${p}`] ? a(f) : (i.set(f, p), p);
  }
  t.settings = t.settings.map((f) => {
    var m, b;
    const p = ((m = f.settings) == null ? void 0 : m.foreground) && !f.settings.foreground.startsWith("#"), h = ((b = f.settings) == null ? void 0 : b.background) && !f.settings.background.startsWith("#");
    if (!p && !h)
      return f;
    const g = {
      ...f,
      settings: {
        ...f.settings
      }
    };
    if (p) {
      const _ = a(f.settings.foreground);
      t.colorReplacements[_] = f.settings.foreground, g.settings.foreground = _;
    }
    if (h) {
      const _ = a(f.settings.background);
      t.colorReplacements[_] = f.settings.background, g.settings.background = _;
    }
    return g;
  });
  for (const f of Object.keys(t.colors || {}))
    if ((f === "editor.foreground" || f === "editor.background" || f.startsWith("terminal.ansi")) && !((d = t.colors[f]) != null && d.startsWith("#"))) {
      const p = a(t.colors[f]);
      t.colorReplacements[p] = t.colors[f], t.colors[f] = p;
    }
  return Object.defineProperty(t, Pu, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), t;
}
async function Kr(e) {
  return Array.from(new Set((await Promise.all(
    e.filter((t) => !Gr(t)).map(async (t) => await qr(t).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function Qr(e) {
  return (await Promise.all(
    e.map(
      async (n) => Hr(n) ? null : Bn(await qr(n))
    )
  )).filter((n) => !!n);
}
let _0 = 3;
function b0(e, t = 3) {
  t > _0 || console.trace(`[SHIKI DEPRECATE]: ${e}`);
}
let Ce = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
class y0 extends vl {
  constructor(n, u, r, i = {}) {
    super(n);
    k(this, "_resolvedThemes", /* @__PURE__ */ new Map());
    k(this, "_resolvedGrammars", /* @__PURE__ */ new Map());
    k(this, "_langMap", /* @__PURE__ */ new Map());
    k(this, "_langGraph", /* @__PURE__ */ new Map());
    k(this, "_textmateThemeCache", /* @__PURE__ */ new WeakMap());
    k(this, "_loadedThemesCache", null);
    k(this, "_loadedLanguagesCache", null);
    this._resolver = n, this._themes = u, this._langs = r, this._alias = i, this._themes.map((a) => this.loadTheme(a)), this.loadLanguages(this._langs);
  }
  getTheme(n) {
    return typeof n == "string" ? this._resolvedThemes.get(n) : this.loadTheme(n);
  }
  loadTheme(n) {
    const u = Bn(n);
    return u.name && (this._resolvedThemes.set(u.name, u), this._loadedThemesCache = null), u;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(n) {
    let u = this._textmateThemeCache.get(n);
    u || (u = mt.createFromRawTheme(n), this._textmateThemeCache.set(n, u)), this._syncRegistry.setTheme(u);
  }
  getGrammar(n) {
    if (this._alias[n]) {
      const u = /* @__PURE__ */ new Set([n]);
      for (; this._alias[n]; ) {
        if (n = this._alias[n], u.has(n))
          throw new Ce(`Circular alias \`${Array.from(u).join(" -> ")} -> ${n}\``);
        u.add(n);
      }
    }
    return this._resolvedGrammars.get(n);
  }
  loadLanguage(n) {
    var a, o, s, l;
    if (this.getGrammar(n.name))
      return;
    const u = new Set(
      [...this._langMap.values()].filter((c) => {
        var d;
        return (d = c.embeddedLangsLazy) == null ? void 0 : d.includes(n.name);
      })
    );
    this._resolver.addLanguage(n);
    const r = {
      balancedBracketSelectors: n.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: n.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(n.scopeName, n);
    const i = this.loadGrammarWithConfiguration(n.scopeName, 1, r);
    if (i.name = n.name, this._resolvedGrammars.set(n.name, i), n.aliases && n.aliases.forEach((c) => {
      this._alias[c] = n.name;
    }), this._loadedLanguagesCache = null, u.size)
      for (const c of u)
        this._resolvedGrammars.delete(c.name), this._loadedLanguagesCache = null, (o = (a = this._syncRegistry) == null ? void 0 : a._injectionGrammars) == null || o.delete(c.scopeName), (l = (s = this._syncRegistry) == null ? void 0 : s._grammars) == null || l.delete(c.scopeName), this.loadLanguage(this._langMap.get(c.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(n) {
    for (const i of n)
      this.resolveEmbeddedLanguages(i);
    const u = Array.from(this._langGraph.entries()), r = u.filter(([i, a]) => !a);
    if (r.length) {
      const i = u.filter(([a, o]) => {
        var s;
        return o && ((s = o.embeddedLangs) == null ? void 0 : s.some((l) => r.map(([c]) => c).includes(l)));
      }).filter((a) => !r.includes(a));
      throw new Ce(`Missing languages ${r.map(([a]) => `\`${a}\``).join(", ")}, required by ${i.map(([a]) => `\`${a}\``).join(", ")}`);
    }
    for (const [i, a] of u)
      this._resolver.addLanguage(a);
    for (const [i, a] of u)
      this.loadLanguage(a);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(n) {
    if (this._langMap.set(n.name, n), this._langGraph.set(n.name, n), n.embeddedLangs)
      for (const u of n.embeddedLangs)
        this._langGraph.set(u, this._langMap.get(u));
  }
}
class k0 {
  constructor(t, n) {
    k(this, "_langs", /* @__PURE__ */ new Map());
    k(this, "_scopeToLang", /* @__PURE__ */ new Map());
    k(this, "_injections", /* @__PURE__ */ new Map());
    k(this, "_onigLib");
    this._onigLib = {
      createOnigScanner: (u) => t.createScanner(u),
      createOnigString: (u) => t.createString(u)
    }, n.forEach((u) => this.addLanguage(u));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(t) {
    return this._langs.get(t);
  }
  loadGrammar(t) {
    return this._scopeToLang.get(t);
  }
  addLanguage(t) {
    this._langs.set(t.name, t), t.aliases && t.aliases.forEach((n) => {
      this._langs.set(n, t);
    }), this._scopeToLang.set(t.scopeName, t), t.injectTo && t.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(t.scopeName);
    });
  }
  getInjections(t) {
    const n = t.split(".");
    let u = [];
    for (let r = 1; r <= n.length; r++) {
      const i = n.slice(0, r).join(".");
      u = [...u, ...this._injections.get(i) || []];
    }
    return u;
  }
}
let Oe = 0;
function x0(e) {
  Oe += 1, e.warnings !== !1 && Oe >= 10 && Oe % 10 === 0 && console.warn(`[Shiki] ${Oe} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let t = !1;
  if (!e.engine)
    throw new Ce("`engine` option is required for synchronous mode");
  const n = (e.langs || []).flat(1), u = (e.themes || []).flat(1).map(Bn), r = new k0(e.engine, n), i = new y0(r, u, n, e.langAlias);
  let a;
  function o(_) {
    m();
    const y = i.getGrammar(typeof _ == "string" ? _ : _.name);
    if (!y)
      throw new Ce(`Language \`${_}\` not found, you may need to load it first`);
    return y;
  }
  function s(_) {
    if (_ === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    m();
    const y = i.getTheme(_);
    if (!y)
      throw new Ce(`Theme \`${_}\` not found, you may need to load it first`);
    return y;
  }
  function l(_) {
    m();
    const y = s(_);
    a !== _ && (i.setTheme(y), a = _);
    const x = i.getColorMap();
    return {
      theme: y,
      colorMap: x
    };
  }
  function c() {
    return m(), i.getLoadedThemes();
  }
  function d() {
    return m(), i.getLoadedLanguages();
  }
  function f(..._) {
    m(), i.loadLanguages(_.flat(1));
  }
  async function p(..._) {
    return f(await Kr(_));
  }
  function h(..._) {
    m();
    for (const y of _.flat(1))
      i.loadTheme(y);
  }
  async function g(..._) {
    return m(), h(await Qr(_));
  }
  function m() {
    if (t)
      throw new Ce("Shiki instance has been disposed");
  }
  function b() {
    t || (t = !0, i.dispose(), Oe -= 1);
  }
  return {
    setTheme: l,
    getTheme: s,
    getLanguage: o,
    getLoadedThemes: c,
    getLoadedLanguages: d,
    loadLanguage: p,
    loadLanguageSync: f,
    loadTheme: g,
    loadThemeSync: h,
    dispose: b,
    [Symbol.dispose]: b
  };
}
async function w0(e) {
  e.engine || b0("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  const [
    t,
    n,
    u
  ] = await Promise.all([
    Qr(e.themes || []),
    Kr(e.langs || []),
    e.engine
  ]);
  return x0({
    ...e,
    themes: t,
    langs: n,
    engine: u
  });
}
async function C0(e) {
  const t = await w0(e);
  return {
    getLastGrammarState: (...n) => i0(t, ...n),
    codeToTokensBase: (n, u) => On(t, n, u),
    codeToTokensWithThemes: (n, u) => Jr(t, n, u),
    codeToTokens: (n, u) => Ct(t, n, u),
    codeToHast: (n, u) => vt(t, n, u),
    codeToHtml: (n, u) => g0(t, n, u),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...t,
    getInternalContext: () => t
  };
}
function v0(e) {
  const t = e.langs, n = e.themes, u = e.engine;
  async function r(i) {
    function a(d) {
      if (typeof d == "string") {
        if (Gr(d))
          return [];
        const f = t[d];
        if (!f)
          throw new j(`Language \`${d}\` is not included in this bundle. You may want to load it from external source.`);
        return f;
      }
      return d;
    }
    function o(d) {
      if (Hr(d))
        return "none";
      if (typeof d == "string") {
        const f = n[d];
        if (!f)
          throw new j(`Theme \`${d}\` is not included in this bundle. You may want to load it from external source.`);
        return f;
      }
      return d;
    }
    const s = (i.themes ?? []).map((d) => o(d)), l = (i.langs ?? []).map((d) => a(d)), c = await C0({
      engine: i.engine ?? u(),
      ...i,
      themes: s,
      langs: l
    });
    return {
      ...c,
      loadLanguage(...d) {
        return c.loadLanguage(...d.map(a));
      },
      loadTheme(...d) {
        return c.loadTheme(...d.map(o));
      },
      getBundledLanguages() {
        return t;
      },
      getBundledThemes() {
        return n;
      }
    };
  }
  return r;
}
const Xr = [
  {
    id: "abap",
    name: "ABAP",
    import: () => import("./abap-BPxeDPn4.mjs")
  },
  {
    id: "actionscript-3",
    name: "ActionScript",
    import: () => import("./actionscript-3-Cjb604Dt.mjs")
  },
  {
    id: "ada",
    name: "Ada",
    import: () => import("./ada-BSgRrxrM.mjs")
  },
  {
    id: "angular-html",
    name: "Angular HTML",
    import: () => import("./angular-html-VH4Q9M3L.mjs").then((e) => e.f)
  },
  {
    id: "angular-ts",
    name: "Angular TypeScript",
    import: () => import("./angular-ts-RFL6RdQE.mjs")
  },
  {
    id: "apache",
    name: "Apache Conf",
    import: () => import("./apache-Cyj7Ib-S.mjs")
  },
  {
    id: "apex",
    name: "Apex",
    import: () => import("./apex-DAAiMqi-.mjs")
  },
  {
    id: "apl",
    name: "APL",
    import: () => import("./apl-Chb7kBJS.mjs")
  },
  {
    id: "applescript",
    name: "AppleScript",
    import: () => import("./applescript-CroEtIVQ.mjs")
  },
  {
    id: "ara",
    name: "Ara",
    import: () => import("./ara-9AczF2vY.mjs")
  },
  {
    id: "asciidoc",
    name: "AsciiDoc",
    aliases: [
      "adoc"
    ],
    import: () => import("./asciidoc-raFNDrGb.mjs")
  },
  {
    id: "asm",
    name: "Assembly",
    import: () => import("./asm-C8ld_M07.mjs")
  },
  {
    id: "astro",
    name: "Astro",
    import: () => import("./astro-C441rmT2.mjs")
  },
  {
    id: "awk",
    name: "AWK",
    import: () => import("./awk-gc4Y_RTq.mjs")
  },
  {
    id: "ballerina",
    name: "Ballerina",
    import: () => import("./ballerina-CML1q4Hw.mjs")
  },
  {
    id: "bat",
    name: "Batch File",
    aliases: [
      "batch"
    ],
    import: () => import("./bat-BVW1L4ug.mjs")
  },
  {
    id: "beancount",
    name: "Beancount",
    import: () => import("./beancount-DYEC72C_.mjs")
  },
  {
    id: "berry",
    name: "Berry",
    aliases: [
      "be"
    ],
    import: () => import("./berry-VTah6p7n.mjs")
  },
  {
    id: "bibtex",
    name: "BibTeX",
    import: () => import("./bibtex-Bqt_3AVI.mjs")
  },
  {
    id: "bicep",
    name: "Bicep",
    import: () => import("./bicep-DGk9_2l4.mjs")
  },
  {
    id: "blade",
    name: "Blade",
    import: () => import("./blade-CtIs8DKJ.mjs")
  },
  {
    id: "bsl",
    name: "1C (Enterprise)",
    aliases: [
      "1c"
    ],
    import: () => import("./bsl-CGvKUPBQ.mjs")
  },
  {
    id: "c",
    name: "C",
    import: () => import("./c-Cb-M0LQR.mjs")
  },
  {
    id: "cadence",
    name: "Cadence",
    aliases: [
      "cdc"
    ],
    import: () => import("./cadence-Di4VMBdJ.mjs")
  },
  {
    id: "cairo",
    name: "Cairo",
    import: () => import("./cairo-CAE0ZH8Z.mjs")
  },
  {
    id: "clarity",
    name: "Clarity",
    import: () => import("./clarity-WOA8trQj.mjs")
  },
  {
    id: "clojure",
    name: "Clojure",
    aliases: [
      "clj"
    ],
    import: () => import("./clojure-r3NcJ8yt.mjs")
  },
  {
    id: "cmake",
    name: "CMake",
    import: () => import("./cmake-CQmEhYbr.mjs")
  },
  {
    id: "cobol",
    name: "COBOL",
    import: () => import("./cobol-ptvo3qSX.mjs")
  },
  {
    id: "codeowners",
    name: "CODEOWNERS",
    import: () => import("./codeowners-Bt9yU6NX.mjs")
  },
  {
    id: "codeql",
    name: "CodeQL",
    aliases: [
      "ql"
    ],
    import: () => import("./codeql-2Dcm6WNF.mjs")
  },
  {
    id: "coffee",
    name: "CoffeeScript",
    aliases: [
      "coffeescript"
    ],
    import: () => import("./coffee-BaUVgbKr.mjs")
  },
  {
    id: "common-lisp",
    name: "Common Lisp",
    aliases: [
      "lisp"
    ],
    import: () => import("./common-lisp-DuX5KqId.mjs")
  },
  {
    id: "coq",
    name: "Coq",
    import: () => import("./coq-DboLktjX.mjs")
  },
  {
    id: "cpp",
    name: "C++",
    aliases: [
      "c++"
    ],
    import: () => import("./cpp-yY_3eVTX.mjs")
  },
  {
    id: "crystal",
    name: "Crystal",
    import: () => import("./crystal-DGmreRZE.mjs")
  },
  {
    id: "csharp",
    name: "C#",
    aliases: [
      "c#",
      "cs"
    ],
    import: () => import("./csharp-xQvxkZxj.mjs")
  },
  {
    id: "css",
    name: "CSS",
    import: () => import("./css-BnL1064W.mjs")
  },
  {
    id: "csv",
    name: "CSV",
    import: () => import("./csv-CmYOceLb.mjs")
  },
  {
    id: "cue",
    name: "CUE",
    import: () => import("./cue-ByErcpN2.mjs")
  },
  {
    id: "cypher",
    name: "Cypher",
    aliases: [
      "cql"
    ],
    import: () => import("./cypher-DEVyrV5b.mjs")
  },
  {
    id: "d",
    name: "D",
    import: () => import("./d-CBVqdj3C.mjs")
  },
  {
    id: "dart",
    name: "Dart",
    import: () => import("./dart-u2fD-sKr.mjs")
  },
  {
    id: "dax",
    name: "DAX",
    import: () => import("./dax-Crz9Wv4y.mjs")
  },
  {
    id: "desktop",
    name: "Desktop",
    import: () => import("./desktop-DNXSD5qJ.mjs")
  },
  {
    id: "diff",
    name: "Diff",
    import: () => import("./diff-DOdUfPSR.mjs")
  },
  {
    id: "docker",
    name: "Dockerfile",
    aliases: [
      "dockerfile"
    ],
    import: () => import("./docker-CsHqm9tx.mjs")
  },
  {
    id: "dotenv",
    name: "dotEnv",
    import: () => import("./dotenv-BYL4tpZA.mjs")
  },
  {
    id: "dream-maker",
    name: "Dream Maker",
    import: () => import("./dream-maker-kevRUHRs.mjs")
  },
  {
    id: "edge",
    name: "Edge",
    import: () => import("./edge-BCt2E0q_.mjs")
  },
  {
    id: "elixir",
    name: "Elixir",
    import: () => import("./elixir-BHm2glEy.mjs")
  },
  {
    id: "elm",
    name: "Elm",
    import: () => import("./elm-CTcFORmv.mjs")
  },
  {
    id: "emacs-lisp",
    name: "Emacs Lisp",
    aliases: [
      "elisp"
    ],
    import: () => import("./emacs-lisp-Bwasiep6.mjs")
  },
  {
    id: "erb",
    name: "ERB",
    import: () => import("./erb-XhwKqDS8.mjs")
  },
  {
    id: "erlang",
    name: "Erlang",
    aliases: [
      "erl"
    ],
    import: () => import("./erlang-CxpbZUOc.mjs")
  },
  {
    id: "fennel",
    name: "Fennel",
    import: () => import("./fennel-B1x5pKr1.mjs")
  },
  {
    id: "fish",
    name: "Fish",
    import: () => import("./fish-BjbXctXH.mjs")
  },
  {
    id: "fluent",
    name: "Fluent",
    aliases: [
      "ftl"
    ],
    import: () => import("./fluent-DCuHrNR-.mjs")
  },
  {
    id: "fortran-fixed-form",
    name: "Fortran (Fixed Form)",
    aliases: [
      "f",
      "for",
      "f77"
    ],
    import: () => import("./fortran-fixed-form-CeyvVuTY.mjs")
  },
  {
    id: "fortran-free-form",
    name: "Fortran (Free Form)",
    aliases: [
      "f90",
      "f95",
      "f03",
      "f08",
      "f18"
    ],
    import: () => import("./fortran-free-form-Db8k5H7x.mjs")
  },
  {
    id: "fsharp",
    name: "F#",
    aliases: [
      "f#",
      "fs"
    ],
    import: () => import("./fsharp-DEQhJMqK.mjs")
  },
  {
    id: "gdresource",
    name: "GDResource",
    import: () => import("./gdresource-BLJkA_Aj.mjs")
  },
  {
    id: "gdscript",
    name: "GDScript",
    import: () => import("./gdscript-C-C99PjI.mjs")
  },
  {
    id: "gdshader",
    name: "GDShader",
    import: () => import("./gdshader-0TihrSQl.mjs")
  },
  {
    id: "genie",
    name: "Genie",
    import: () => import("./genie-MtKmcmPo.mjs")
  },
  {
    id: "gherkin",
    name: "Gherkin",
    import: () => import("./gherkin-AzJBtK0J.mjs")
  },
  {
    id: "git-commit",
    name: "Git Commit Message",
    import: () => import("./git-commit-BrFRQx8-.mjs")
  },
  {
    id: "git-rebase",
    name: "Git Rebase Message",
    import: () => import("./git-rebase-wXBGezpo.mjs")
  },
  {
    id: "gleam",
    name: "Gleam",
    import: () => import("./gleam-BoJB89vF.mjs")
  },
  {
    id: "glimmer-js",
    name: "Glimmer JS",
    aliases: [
      "gjs"
    ],
    import: () => import("./glimmer-js-Dt04jn-S.mjs")
  },
  {
    id: "glimmer-ts",
    name: "Glimmer TS",
    aliases: [
      "gts"
    ],
    import: () => import("./glimmer-ts-CxE3Gx7t.mjs")
  },
  {
    id: "glsl",
    name: "GLSL",
    import: () => import("./glsl-DJI4XIlW.mjs")
  },
  {
    id: "gnuplot",
    name: "Gnuplot",
    import: () => import("./gnuplot-DgGnPAp8.mjs")
  },
  {
    id: "go",
    name: "Go",
    import: () => import("./go-Cw0OOp5U.mjs")
  },
  {
    id: "graphql",
    name: "GraphQL",
    aliases: [
      "gql"
    ],
    import: () => import("./graphql-BsgHRvna.mjs")
  },
  {
    id: "groovy",
    name: "Groovy",
    import: () => import("./groovy-45PuQEhl.mjs")
  },
  {
    id: "hack",
    name: "Hack",
    import: () => import("./hack-DqV8KpWq.mjs")
  },
  {
    id: "haml",
    name: "Ruby Haml",
    import: () => import("./haml-Az-UVpCq.mjs")
  },
  {
    id: "handlebars",
    name: "Handlebars",
    aliases: [
      "hbs"
    ],
    import: () => import("./handlebars-DZHTG-pY.mjs")
  },
  {
    id: "haskell",
    name: "Haskell",
    aliases: [
      "hs"
    ],
    import: () => import("./haskell-ClRE648j.mjs")
  },
  {
    id: "haxe",
    name: "Haxe",
    import: () => import("./haxe-CClgwBXY.mjs")
  },
  {
    id: "hcl",
    name: "HashiCorp HCL",
    import: () => import("./hcl-JJeBEFYE.mjs")
  },
  {
    id: "hjson",
    name: "Hjson",
    import: () => import("./hjson-BollGKL_.mjs")
  },
  {
    id: "hlsl",
    name: "HLSL",
    import: () => import("./hlsl-b3kI2reZ.mjs")
  },
  {
    id: "html",
    name: "HTML",
    import: () => import("./html-BVzRMMwO.mjs")
  },
  {
    id: "html-derivative",
    name: "HTML (Derivative)",
    import: () => import("./html-derivative-Bs5LtfVt.mjs")
  },
  {
    id: "http",
    name: "HTTP",
    import: () => import("./http-CmSPSQ8m.mjs")
  },
  {
    id: "hxml",
    name: "HXML",
    import: () => import("./hxml-CbNM5L_f.mjs")
  },
  {
    id: "hy",
    name: "Hy",
    import: () => import("./hy-S8dYOqS_.mjs")
  },
  {
    id: "imba",
    name: "Imba",
    import: () => import("./imba-DzSSVziz.mjs")
  },
  {
    id: "ini",
    name: "INI",
    aliases: [
      "properties"
    ],
    import: () => import("./ini-Cw62c0sR.mjs")
  },
  {
    id: "java",
    name: "Java",
    import: () => import("./java-DNw9zkk2.mjs")
  },
  {
    id: "javascript",
    name: "JavaScript",
    aliases: [
      "js"
    ],
    import: () => import("./javascript-CXHlxgtu.mjs")
  },
  {
    id: "jinja",
    name: "Jinja",
    import: () => import("./jinja-Cz5ys3c2.mjs")
  },
  {
    id: "jison",
    name: "Jison",
    import: () => import("./jison-vf0Z0jXp.mjs")
  },
  {
    id: "json",
    name: "JSON",
    import: () => import("./json-D4cXEhM0.mjs")
  },
  {
    id: "json5",
    name: "JSON5",
    import: () => import("./json5-QDX9y-Y9.mjs")
  },
  {
    id: "jsonc",
    name: "JSON with Comments",
    import: () => import("./jsonc-Bph7GQf8.mjs")
  },
  {
    id: "jsonl",
    name: "JSON Lines",
    import: () => import("./jsonl-CCrMgdQc.mjs")
  },
  {
    id: "jsonnet",
    name: "Jsonnet",
    import: () => import("./jsonnet-SAcLllmN.mjs")
  },
  {
    id: "jssm",
    name: "JSSM",
    aliases: [
      "fsl"
    ],
    import: () => import("./jssm-f8vsTkbr.mjs")
  },
  {
    id: "jsx",
    name: "JSX",
    import: () => import("./jsx-BYrS51r7.mjs")
  },
  {
    id: "julia",
    name: "Julia",
    aliases: [
      "jl"
    ],
    import: () => import("./julia-BFBGsm6d.mjs")
  },
  {
    id: "kotlin",
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    import: () => import("./kotlin-DZs3CUXT.mjs")
  },
  {
    id: "kusto",
    name: "Kusto",
    aliases: [
      "kql"
    ],
    import: () => import("./kusto-gqgW0Ct6.mjs")
  },
  {
    id: "latex",
    name: "LaTeX",
    import: () => import("./latex-CovCzr27.mjs")
  },
  {
    id: "lean",
    name: "Lean 4",
    aliases: [
      "lean4"
    ],
    import: () => import("./lean-DM2VgJqL.mjs")
  },
  {
    id: "less",
    name: "Less",
    import: () => import("./less-I_XXVOZl.mjs")
  },
  {
    id: "liquid",
    name: "Liquid",
    import: () => import("./liquid-B0utSgK4.mjs")
  },
  {
    id: "llvm",
    name: "LLVM IR",
    import: () => import("./llvm-D3Vjgx0u.mjs")
  },
  {
    id: "log",
    name: "Log file",
    import: () => import("./log-D-MzYv1Z.mjs")
  },
  {
    id: "logo",
    name: "Logo",
    import: () => import("./logo-D1k-IeHX.mjs")
  },
  {
    id: "lua",
    name: "Lua",
    import: () => import("./lua-6kxZcjr7.mjs")
  },
  {
    id: "luau",
    name: "Luau",
    import: () => import("./luau-B3dL2bb0.mjs")
  },
  {
    id: "make",
    name: "Makefile",
    aliases: [
      "makefile"
    ],
    import: () => import("./make-CR9bkdqJ.mjs")
  },
  {
    id: "markdown",
    name: "Markdown",
    aliases: [
      "md"
    ],
    import: () => import("./markdown-w3MmBOPg.mjs")
  },
  {
    id: "marko",
    name: "Marko",
    import: () => import("./marko-B-mS4lxx.mjs")
  },
  {
    id: "matlab",
    name: "MATLAB",
    import: () => import("./matlab-Dj6qX5si.mjs")
  },
  {
    id: "mdc",
    name: "MDC",
    import: () => import("./mdc-CKFBgyBp.mjs")
  },
  {
    id: "mdx",
    name: "MDX",
    import: () => import("./mdx-COYqLMfv.mjs")
  },
  {
    id: "mermaid",
    name: "Mermaid",
    aliases: [
      "mmd"
    ],
    import: () => import("./mermaid-qIAHIJes.mjs")
  },
  {
    id: "mipsasm",
    name: "MIPS Assembly",
    aliases: [
      "mips"
    ],
    import: () => import("./mipsasm-BJbuoeDX.mjs")
  },
  {
    id: "mojo",
    name: "Mojo",
    import: () => import("./mojo-BFkEE7I6.mjs")
  },
  {
    id: "move",
    name: "Move",
    import: () => import("./move-DhZIVzw9.mjs")
  },
  {
    id: "narrat",
    name: "Narrat Language",
    aliases: [
      "nar"
    ],
    import: () => import("./narrat-Cru3p5ML.mjs")
  },
  {
    id: "nextflow",
    name: "Nextflow",
    aliases: [
      "nf"
    ],
    import: () => import("./nextflow-JJGGygxI.mjs")
  },
  {
    id: "nginx",
    name: "Nginx",
    import: () => import("./nginx-DMJTzGU3.mjs")
  },
  {
    id: "nim",
    name: "Nim",
    import: () => import("./nim-tEo-v-ne.mjs")
  },
  {
    id: "nix",
    name: "Nix",
    import: () => import("./nix-DeKhqLCs.mjs")
  },
  {
    id: "nushell",
    name: "nushell",
    aliases: [
      "nu"
    ],
    import: () => import("./nushell-vZ0whCpp.mjs")
  },
  {
    id: "objective-c",
    name: "Objective-C",
    aliases: [
      "objc"
    ],
    import: () => import("./objective-c-DLUrAoO7.mjs")
  },
  {
    id: "objective-cpp",
    name: "Objective-C++",
    import: () => import("./objective-cpp-BR9pz3Y7.mjs")
  },
  {
    id: "ocaml",
    name: "OCaml",
    import: () => import("./ocaml-JmaGD6hS.mjs")
  },
  {
    id: "pascal",
    name: "Pascal",
    import: () => import("./pascal-NVmycfDo.mjs")
  },
  {
    id: "perl",
    name: "Perl",
    import: () => import("./perl-BuRaBk1L.mjs")
  },
  {
    id: "php",
    name: "PHP",
    import: () => import("./php-oHOrbTjZ.mjs")
  },
  {
    id: "plsql",
    name: "PL/SQL",
    import: () => import("./plsql-DMWd0imC.mjs")
  },
  {
    id: "po",
    name: "Gettext PO",
    aliases: [
      "pot",
      "potx"
    ],
    import: () => import("./po-GS6uwG3N.mjs")
  },
  {
    id: "polar",
    name: "Polar",
    import: () => import("./polar-kLOnm3TU.mjs")
  },
  {
    id: "postcss",
    name: "PostCSS",
    import: () => import("./postcss-BHhGrjb8.mjs")
  },
  {
    id: "powerquery",
    name: "PowerQuery",
    import: () => import("./powerquery-CMfeLaGU.mjs")
  },
  {
    id: "powershell",
    name: "PowerShell",
    aliases: [
      "ps",
      "ps1"
    ],
    import: () => import("./powershell-D1mvJxDs.mjs")
  },
  {
    id: "prisma",
    name: "Prisma",
    import: () => import("./prisma-pUoUFT3i.mjs")
  },
  {
    id: "prolog",
    name: "Prolog",
    import: () => import("./prolog-DY7WzwMi.mjs")
  },
  {
    id: "proto",
    name: "Protocol Buffer 3",
    aliases: [
      "protobuf"
    ],
    import: () => import("./proto-CNCp3VWu.mjs")
  },
  {
    id: "pug",
    name: "Pug",
    aliases: [
      "jade"
    ],
    import: () => import("./pug-CAVXGuhX.mjs")
  },
  {
    id: "puppet",
    name: "Puppet",
    import: () => import("./puppet-B0mgPBqt.mjs")
  },
  {
    id: "purescript",
    name: "PureScript",
    import: () => import("./purescript-Go548NjJ.mjs")
  },
  {
    id: "python",
    name: "Python",
    aliases: [
      "py"
    ],
    import: () => import("./python-x6NdgKMy.mjs")
  },
  {
    id: "qml",
    name: "QML",
    import: () => import("./qml-_XrKGlow.mjs")
  },
  {
    id: "qmldir",
    name: "QML Directory",
    import: () => import("./qmldir-BInDYbpo.mjs")
  },
  {
    id: "qss",
    name: "Qt Style Sheets",
    import: () => import("./qss-8QkBlVEn.mjs")
  },
  {
    id: "r",
    name: "R",
    import: () => import("./r-HSnR3oil.mjs")
  },
  {
    id: "racket",
    name: "Racket",
    import: () => import("./racket-N6wCNCGC.mjs")
  },
  {
    id: "raku",
    name: "Raku",
    aliases: [
      "perl6"
    ],
    import: () => import("./raku-DIMO1_4D.mjs")
  },
  {
    id: "razor",
    name: "ASP.NET Razor",
    import: () => import("./razor-3IbidmH5.mjs")
  },
  {
    id: "reg",
    name: "Windows Registry Script",
    import: () => import("./reg-6UpU0EA6.mjs")
  },
  {
    id: "regexp",
    name: "RegExp",
    aliases: [
      "regex"
    ],
    import: () => import("./regexp-DHtjPxOp.mjs")
  },
  {
    id: "rel",
    name: "Rel",
    import: () => import("./rel-DBIoUiKW.mjs")
  },
  {
    id: "riscv",
    name: "RISC-V",
    import: () => import("./riscv-DpWk9ieM.mjs")
  },
  {
    id: "rst",
    name: "reStructuredText",
    import: () => import("./rst-CPnjfoUr.mjs")
  },
  {
    id: "ruby",
    name: "Ruby",
    aliases: [
      "rb"
    ],
    import: () => import("./ruby-CnpR89Yz.mjs")
  },
  {
    id: "rust",
    name: "Rust",
    aliases: [
      "rs"
    ],
    import: () => import("./rust-B-KPd2nT.mjs")
  },
  {
    id: "sas",
    name: "SAS",
    import: () => import("./sas-CYKhWn_m.mjs")
  },
  {
    id: "sass",
    name: "Sass",
    import: () => import("./sass-Zos2Blmo.mjs")
  },
  {
    id: "scala",
    name: "Scala",
    import: () => import("./scala-7cAMYIqn.mjs")
  },
  {
    id: "scheme",
    name: "Scheme",
    import: () => import("./scheme-BQZQETGI.mjs")
  },
  {
    id: "scss",
    name: "SCSS",
    import: () => import("./scss-DKWoiR-u.mjs")
  },
  {
    id: "sdbl",
    name: "1C (Query)",
    aliases: [
      "1c-query"
    ],
    import: () => import("./sdbl-67k1U2sQ.mjs")
  },
  {
    id: "shaderlab",
    name: "ShaderLab",
    aliases: [
      "shader"
    ],
    import: () => import("./shaderlab-B4H_j9nc.mjs")
  },
  {
    id: "shellscript",
    name: "Shell",
    aliases: [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    import: () => import("./shellscript-DmhSIIKI.mjs")
  },
  {
    id: "shellsession",
    name: "Shell Session",
    aliases: [
      "console"
    ],
    import: () => import("./shellsession-fTmnZnY-.mjs")
  },
  {
    id: "smalltalk",
    name: "Smalltalk",
    import: () => import("./smalltalk-WltKgyq1.mjs")
  },
  {
    id: "solidity",
    name: "Solidity",
    import: () => import("./solidity-C04s0Yy3.mjs")
  },
  {
    id: "soy",
    name: "Closure Templates",
    aliases: [
      "closure-templates"
    ],
    import: () => import("./soy-758-DfbO.mjs")
  },
  {
    id: "sparql",
    name: "SPARQL",
    import: () => import("./sparql-P6C2Je34.mjs")
  },
  {
    id: "splunk",
    name: "Splunk Query Language",
    aliases: [
      "spl"
    ],
    import: () => import("./splunk-SGh_QiTm.mjs")
  },
  {
    id: "sql",
    name: "SQL",
    import: () => import("./sql-CsvhJWkt.mjs")
  },
  {
    id: "ssh-config",
    name: "SSH Config",
    import: () => import("./ssh-config-D4I637-k.mjs")
  },
  {
    id: "stata",
    name: "Stata",
    import: () => import("./stata-CqUrtzqQ.mjs")
  },
  {
    id: "stylus",
    name: "Stylus",
    aliases: [
      "styl"
    ],
    import: () => import("./stylus-C0YS3cII.mjs")
  },
  {
    id: "svelte",
    name: "Svelte",
    import: () => import("./svelte-PT4fUUDt.mjs")
  },
  {
    id: "swift",
    name: "Swift",
    import: () => import("./swift-DvTgPjC_.mjs")
  },
  {
    id: "system-verilog",
    name: "SystemVerilog",
    import: () => import("./system-verilog-NDUJ-OOt.mjs")
  },
  {
    id: "systemd",
    name: "Systemd Units",
    import: () => import("./systemd-WbxZvB8q.mjs")
  },
  {
    id: "talonscript",
    name: "TalonScript",
    aliases: [
      "talon"
    ],
    import: () => import("./talonscript-CL368eRB.mjs")
  },
  {
    id: "tasl",
    name: "Tasl",
    import: () => import("./tasl-Dz-WwaLH.mjs")
  },
  {
    id: "tcl",
    name: "Tcl",
    import: () => import("./tcl-DlZIgGJq.mjs")
  },
  {
    id: "templ",
    name: "Templ",
    import: () => import("./templ-pbaOT3fH.mjs")
  },
  {
    id: "terraform",
    name: "Terraform",
    aliases: [
      "tf",
      "tfvars"
    ],
    import: () => import("./terraform-BlQVOgpk.mjs")
  },
  {
    id: "tex",
    name: "TeX",
    import: () => import("./tex-BJDXdWDL.mjs")
  },
  {
    id: "toml",
    name: "TOML",
    import: () => import("./toml-DMRYbshZ.mjs")
  },
  {
    id: "ts-tags",
    name: "TypeScript with Tags",
    aliases: [
      "lit"
    ],
    import: () => import("./ts-tags-DLLASl57.mjs")
  },
  {
    id: "tsv",
    name: "TSV",
    import: () => import("./tsv-BtvSkaG0.mjs")
  },
  {
    id: "tsx",
    name: "TSX",
    import: () => import("./tsx-D0IYuDPS.mjs")
  },
  {
    id: "turtle",
    name: "Turtle",
    import: () => import("./turtle-p-VV8DEc.mjs")
  },
  {
    id: "twig",
    name: "Twig",
    import: () => import("./twig-qIHzdBZb.mjs")
  },
  {
    id: "typescript",
    name: "TypeScript",
    aliases: [
      "ts"
    ],
    import: () => import("./typescript-DKfvlBCw.mjs")
  },
  {
    id: "typespec",
    name: "TypeSpec",
    aliases: [
      "tsp"
    ],
    import: () => import("./typespec-CTme0-JL.mjs")
  },
  {
    id: "typst",
    name: "Typst",
    aliases: [
      "typ"
    ],
    import: () => import("./typst-Dn4vyooU.mjs")
  },
  {
    id: "v",
    name: "V",
    import: () => import("./v-D7ebitkb.mjs")
  },
  {
    id: "vala",
    name: "Vala",
    import: () => import("./vala-TRtLMDHC.mjs")
  },
  {
    id: "vb",
    name: "Visual Basic",
    aliases: [
      "cmd"
    ],
    import: () => import("./vb-B47FrOmA.mjs")
  },
  {
    id: "verilog",
    name: "Verilog",
    import: () => import("./verilog-B2TLsC4I.mjs")
  },
  {
    id: "vhdl",
    name: "VHDL",
    import: () => import("./vhdl-CU5AEtCN.mjs")
  },
  {
    id: "viml",
    name: "Vim Script",
    aliases: [
      "vim",
      "vimscript"
    ],
    import: () => import("./viml-D-fUhqVn.mjs")
  },
  {
    id: "vue",
    name: "Vue",
    import: () => import("./vue-DbAfZKRm.mjs")
  },
  {
    id: "vue-html",
    name: "Vue HTML",
    import: () => import("./vue-html-Bv98KUW6.mjs")
  },
  {
    id: "vyper",
    name: "Vyper",
    aliases: [
      "vy"
    ],
    import: () => import("./vyper-C03y8CZF.mjs")
  },
  {
    id: "wasm",
    name: "WebAssembly",
    import: () => import("./wasm-Bq8UuFo1.mjs")
  },
  {
    id: "wenyan",
    name: "Wenyan",
    aliases: [
      "文言"
    ],
    import: () => import("./wenyan-DZPWEYbu.mjs")
  },
  {
    id: "wgsl",
    name: "WGSL",
    import: () => import("./wgsl-De1GPYf9.mjs")
  },
  {
    id: "wikitext",
    name: "Wikitext",
    aliases: [
      "mediawiki",
      "wiki"
    ],
    import: () => import("./wikitext-C-THcCj2.mjs")
  },
  {
    id: "wit",
    name: "WebAssembly Interface Types",
    import: () => import("./wit-BanP67gl.mjs")
  },
  {
    id: "wolfram",
    name: "Wolfram",
    aliases: [
      "wl"
    ],
    import: () => import("./wolfram-CUT_U39K.mjs")
  },
  {
    id: "xml",
    name: "XML",
    import: () => import("./xml-DQsl7x7X.mjs")
  },
  {
    id: "xsl",
    name: "XSL",
    import: () => import("./xsl-Bi8eHqC2.mjs")
  },
  {
    id: "yaml",
    name: "YAML",
    aliases: [
      "yml"
    ],
    import: () => import("./yaml-DcQhbMrL.mjs")
  },
  {
    id: "zenscript",
    name: "ZenScript",
    import: () => import("./zenscript-8JCzLCTe.mjs")
  },
  {
    id: "zig",
    name: "Zig",
    import: () => import("./zig-DhdgDxkm.mjs")
  }
], A0 = Object.fromEntries(Xr.map((e) => [e.id, e.import])), E0 = Object.fromEntries(Xr.flatMap((e) => {
  var t;
  return ((t = e.aliases) == null ? void 0 : t.map((n) => [n, e.import])) || [];
})), S0 = {
  ...A0,
  ...E0
}, D0 = [
  {
    id: "andromeeda",
    displayName: "Andromeeda",
    type: "dark",
    import: () => import("./andromeeda-uXNdzNpk.mjs")
  },
  {
    id: "aurora-x",
    displayName: "Aurora X",
    type: "dark",
    import: () => import("./aurora-x-BwoVEUWZ.mjs")
  },
  {
    id: "ayu-dark",
    displayName: "Ayu Dark",
    type: "dark",
    import: () => import("./ayu-dark-CxPZkpb2.mjs")
  },
  {
    id: "catppuccin-frappe",
    displayName: "Catppuccin Frappé",
    type: "dark",
    import: () => import("./catppuccin-frappe-MQ6irQtC.mjs")
  },
  {
    id: "catppuccin-latte",
    displayName: "Catppuccin Latte",
    type: "light",
    import: () => import("./catppuccin-latte-UMitw0Sv.mjs")
  },
  {
    id: "catppuccin-macchiato",
    displayName: "Catppuccin Macchiato",
    type: "dark",
    import: () => import("./catppuccin-macchiato-CpTwm6bY.mjs")
  },
  {
    id: "catppuccin-mocha",
    displayName: "Catppuccin Mocha",
    type: "dark",
    import: () => import("./catppuccin-mocha-DAcVHoH1.mjs")
  },
  {
    id: "dark-plus",
    displayName: "Dark Plus",
    type: "dark",
    import: () => import("./dark-plus-pUHDTVV0.mjs")
  },
  {
    id: "dracula",
    displayName: "Dracula Theme",
    type: "dark",
    import: () => import("./dracula-BtZx2Kac.mjs")
  },
  {
    id: "dracula-soft",
    displayName: "Dracula Theme Soft",
    type: "dark",
    import: () => import("./dracula-soft-BKa-aqBv.mjs")
  },
  {
    id: "everforest-dark",
    displayName: "Everforest Dark",
    type: "dark",
    import: () => import("./everforest-dark-DMCBqXCK.mjs")
  },
  {
    id: "everforest-light",
    displayName: "Everforest Light",
    type: "light",
    import: () => import("./everforest-light-BbXl82Em.mjs")
  },
  {
    id: "github-dark",
    displayName: "GitHub Dark",
    type: "dark",
    import: () => import("./github-dark-DenFmJkN.mjs")
  },
  {
    id: "github-dark-default",
    displayName: "GitHub Dark Default",
    type: "dark",
    import: () => import("./github-dark-default-BJPUVz4H.mjs")
  },
  {
    id: "github-dark-dimmed",
    displayName: "GitHub Dark Dimmed",
    type: "dark",
    import: () => import("./github-dark-dimmed-DUshB20C.mjs")
  },
  {
    id: "github-dark-high-contrast",
    displayName: "GitHub Dark High Contrast",
    type: "dark",
    import: () => import("./github-dark-high-contrast-D3aGCnF8.mjs")
  },
  {
    id: "github-light",
    displayName: "GitHub Light",
    type: "light",
    import: () => import("./github-light-JYsPkUQd.mjs")
  },
  {
    id: "github-light-default",
    displayName: "GitHub Light Default",
    type: "light",
    import: () => import("./github-light-default-D99KPAby.mjs")
  },
  {
    id: "github-light-high-contrast",
    displayName: "GitHub Light High Contrast",
    type: "light",
    import: () => import("./github-light-high-contrast-BbmZE-Mp.mjs")
  },
  {
    id: "gruvbox-dark-hard",
    displayName: "Gruvbox Dark Hard",
    type: "dark",
    import: () => import("./gruvbox-dark-hard-BDGmrmYl.mjs")
  },
  {
    id: "gruvbox-dark-medium",
    displayName: "Gruvbox Dark Medium",
    type: "dark",
    import: () => import("./gruvbox-dark-medium-D7OrvcL5.mjs")
  },
  {
    id: "gruvbox-dark-soft",
    displayName: "Gruvbox Dark Soft",
    type: "dark",
    import: () => import("./gruvbox-dark-soft-D_75PUdg.mjs")
  },
  {
    id: "gruvbox-light-hard",
    displayName: "Gruvbox Light Hard",
    type: "light",
    import: () => import("./gruvbox-light-hard-DhQt1gbs.mjs")
  },
  {
    id: "gruvbox-light-medium",
    displayName: "Gruvbox Light Medium",
    type: "light",
    import: () => import("./gruvbox-light-medium-DNXV_Sw8.mjs")
  },
  {
    id: "gruvbox-light-soft",
    displayName: "Gruvbox Light Soft",
    type: "light",
    import: () => import("./gruvbox-light-soft-C7ZspGxH.mjs")
  },
  {
    id: "houston",
    displayName: "Houston",
    type: "dark",
    import: () => import("./houston-BDYrDoDW.mjs")
  },
  {
    id: "kanagawa-dragon",
    displayName: "Kanagawa Dragon",
    type: "dark",
    import: () => import("./kanagawa-dragon-CiKur4Hl.mjs")
  },
  {
    id: "kanagawa-lotus",
    displayName: "Kanagawa Lotus",
    type: "light",
    import: () => import("./kanagawa-lotus-BKu-smKu.mjs")
  },
  {
    id: "kanagawa-wave",
    displayName: "Kanagawa Wave",
    type: "dark",
    import: () => import("./kanagawa-wave-CQwozSzG.mjs")
  },
  {
    id: "laserwave",
    displayName: "LaserWave",
    type: "dark",
    import: () => import("./laserwave-6a00oqik.mjs")
  },
  {
    id: "light-plus",
    displayName: "Light Plus",
    type: "light",
    import: () => import("./light-plus-CZuVqSLX.mjs")
  },
  {
    id: "material-theme",
    displayName: "Material Theme",
    type: "dark",
    import: () => import("./material-theme-D6KBX41T.mjs")
  },
  {
    id: "material-theme-darker",
    displayName: "Material Theme Darker",
    type: "dark",
    import: () => import("./material-theme-darker-CkRroheE.mjs")
  },
  {
    id: "material-theme-lighter",
    displayName: "Material Theme Lighter",
    type: "light",
    import: () => import("./material-theme-lighter-BUBw43Yz.mjs")
  },
  {
    id: "material-theme-ocean",
    displayName: "Material Theme Ocean",
    type: "dark",
    import: () => import("./material-theme-ocean-ClGX14Ja.mjs")
  },
  {
    id: "material-theme-palenight",
    displayName: "Material Theme Palenight",
    type: "dark",
    import: () => import("./material-theme-palenight-C1RVm8K1.mjs")
  },
  {
    id: "min-dark",
    displayName: "Min Dark",
    type: "dark",
    import: () => import("./min-dark-C7ak0t6c.mjs")
  },
  {
    id: "min-light",
    displayName: "Min Light",
    type: "light",
    import: () => import("./min-light-CKFxVcPp.mjs")
  },
  {
    id: "monokai",
    displayName: "Monokai",
    type: "dark",
    import: () => import("./monokai-C1KBYcO0.mjs")
  },
  {
    id: "night-owl",
    displayName: "Night Owl",
    type: "dark",
    import: () => import("./night-owl-Bm2rzalh.mjs")
  },
  {
    id: "nord",
    displayName: "Nord",
    type: "dark",
    import: () => import("./nord-CC5OiUXg.mjs")
  },
  {
    id: "one-dark-pro",
    displayName: "One Dark Pro",
    type: "dark",
    import: () => import("./one-dark-pro-DTA3VF0_.mjs")
  },
  {
    id: "one-light",
    displayName: "One Light",
    type: "light",
    import: () => import("./one-light-D9sNaUtq.mjs")
  },
  {
    id: "plastic",
    displayName: "Plastic",
    type: "dark",
    import: () => import("./plastic-CSTz3KZp.mjs")
  },
  {
    id: "poimandres",
    displayName: "Poimandres",
    type: "dark",
    import: () => import("./poimandres-C-VADXHD.mjs")
  },
  {
    id: "red",
    displayName: "Red",
    type: "dark",
    import: () => import("./red-7y8PH7HH.mjs")
  },
  {
    id: "rose-pine",
    displayName: "Rosé Pine",
    type: "dark",
    import: () => import("./rose-pine-4uTOzEpE.mjs")
  },
  {
    id: "rose-pine-dawn",
    displayName: "Rosé Pine Dawn",
    type: "light",
    import: () => import("./rose-pine-dawn-GMd81k-m.mjs")
  },
  {
    id: "rose-pine-moon",
    displayName: "Rosé Pine Moon",
    type: "dark",
    import: () => import("./rose-pine-moon-CIFp_3PJ.mjs")
  },
  {
    id: "slack-dark",
    displayName: "Slack Dark",
    type: "dark",
    import: () => import("./slack-dark-i7wN4OET.mjs")
  },
  {
    id: "slack-ochin",
    displayName: "Slack Ochin",
    type: "light",
    import: () => import("./slack-ochin-ndHf0LoP.mjs")
  },
  {
    id: "snazzy-light",
    displayName: "Snazzy Light",
    type: "light",
    import: () => import("./snazzy-light-BlSJXAu4.mjs")
  },
  {
    id: "solarized-dark",
    displayName: "Solarized Dark",
    type: "dark",
    import: () => import("./solarized-dark-UTmkh7lw.mjs")
  },
  {
    id: "solarized-light",
    displayName: "Solarized Light",
    type: "light",
    import: () => import("./solarized-light-BheCkDPT.mjs")
  },
  {
    id: "synthwave-84",
    displayName: "Synthwave '84",
    type: "dark",
    import: () => import("./synthwave-84-NU3C_KFZ.mjs")
  },
  {
    id: "tokyo-night",
    displayName: "Tokyo Night",
    type: "dark",
    import: () => import("./tokyo-night-DP4TmcQl.mjs")
  },
  {
    id: "vesper",
    displayName: "Vesper",
    type: "dark",
    import: () => import("./vesper-BckBta1U.mjs")
  },
  {
    id: "vitesse-black",
    displayName: "Vitesse Black",
    type: "dark",
    import: () => import("./vitesse-black-BoGvW84i.mjs")
  },
  {
    id: "vitesse-dark",
    displayName: "Vitesse Dark",
    type: "dark",
    import: () => import("./vitesse-dark-Cym-eLtO.mjs")
  },
  {
    id: "vitesse-light",
    displayName: "Vitesse Light",
    type: "light",
    import: () => import("./vitesse-light-CcmG315c.mjs")
  }
], F0 = Object.fromEntries(D0.map((e) => [e.id, e.import]));
class jn extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
}
function T0() {
  return 2147483648;
}
function R0() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const L0 = (e, t) => e + (t - e % t) % t;
async function P0(e) {
  let t, n;
  const u = {};
  function r(p) {
    n = p, u.HEAPU8 = new Uint8Array(p), u.HEAPU32 = new Uint32Array(p);
  }
  function i(p, h, g) {
    u.HEAPU8.copyWithin(p, h, h + g);
  }
  function a(p) {
    try {
      return t.grow(p - n.byteLength + 65535 >>> 16), r(t.buffer), 1;
    } catch {
    }
  }
  function o(p) {
    const h = u.HEAPU8.length;
    p = p >>> 0;
    const g = T0();
    if (p > g)
      return !1;
    for (let m = 1; m <= 4; m *= 2) {
      let b = h * (1 + 0.2 / m);
      b = Math.min(b, p + 100663296);
      const _ = Math.min(g, L0(Math.max(p, b), 65536));
      if (a(_))
        return !0;
    }
    return !1;
  }
  const s = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function l(p, h, g = 1024) {
    const m = h + g;
    let b = h;
    for (; p[b] && !(b >= m); ) ++b;
    if (b - h > 16 && p.buffer && s)
      return s.decode(p.subarray(h, b));
    let _ = "";
    for (; h < b; ) {
      let y = p[h++];
      if (!(y & 128)) {
        _ += String.fromCharCode(y);
        continue;
      }
      const x = p[h++] & 63;
      if ((y & 224) === 192) {
        _ += String.fromCharCode((y & 31) << 6 | x);
        continue;
      }
      const C = p[h++] & 63;
      if ((y & 240) === 224 ? y = (y & 15) << 12 | x << 6 | C : y = (y & 7) << 18 | x << 12 | C << 6 | p[h++] & 63, y < 65536)
        _ += String.fromCharCode(y);
      else {
        const v = y - 65536;
        _ += String.fromCharCode(55296 | v >> 10, 56320 | v & 1023);
      }
    }
    return _;
  }
  function c(p, h) {
    return p ? l(u.HEAPU8, p, h) : "";
  }
  const d = {
    emscripten_get_now: R0,
    emscripten_memcpy_big: i,
    emscripten_resize_heap: o,
    fd_write: () => 0
  };
  async function f() {
    const h = await e({
      env: d,
      wasi_snapshot_preview1: d
    });
    t = h.memory, r(t.buffer), Object.assign(u, h), u.UTF8ToString = c;
  }
  return await f(), u;
}
var N0 = Object.defineProperty, I0 = (e, t, n) => t in e ? N0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, N = (e, t, n) => I0(e, typeof t != "symbol" ? t + "" : t, n);
let B = null;
function M0(e) {
  throw new jn(e.UTF8ToString(e.getLastOnigError()));
}
class Nt {
  constructor(t) {
    N(this, "utf16Length"), N(this, "utf8Length"), N(this, "utf16Value"), N(this, "utf8Value"), N(this, "utf16OffsetToUtf8"), N(this, "utf8OffsetToUtf16");
    const n = t.length, u = Nt._utf8ByteLength(t), r = u !== n, i = r ? new Uint32Array(n + 1) : null;
    r && (i[n] = u);
    const a = r ? new Uint32Array(u + 1) : null;
    r && (a[u] = n);
    const o = new Uint8Array(u);
    let s = 0;
    for (let l = 0; l < n; l++) {
      const c = t.charCodeAt(l);
      let d = c, f = !1;
      if (c >= 55296 && c <= 56319 && l + 1 < n) {
        const p = t.charCodeAt(l + 1);
        p >= 56320 && p <= 57343 && (d = (c - 55296 << 10) + 65536 | p - 56320, f = !0);
      }
      r && (i[l] = s, f && (i[l + 1] = s), d <= 127 ? a[s + 0] = l : d <= 2047 ? (a[s + 0] = l, a[s + 1] = l) : d <= 65535 ? (a[s + 0] = l, a[s + 1] = l, a[s + 2] = l) : (a[s + 0] = l, a[s + 1] = l, a[s + 2] = l, a[s + 3] = l)), d <= 127 ? o[s++] = d : d <= 2047 ? (o[s++] = 192 | (d & 1984) >>> 6, o[s++] = 128 | (d & 63) >>> 0) : d <= 65535 ? (o[s++] = 224 | (d & 61440) >>> 12, o[s++] = 128 | (d & 4032) >>> 6, o[s++] = 128 | (d & 63) >>> 0) : (o[s++] = 240 | (d & 1835008) >>> 18, o[s++] = 128 | (d & 258048) >>> 12, o[s++] = 128 | (d & 4032) >>> 6, o[s++] = 128 | (d & 63) >>> 0), f && l++;
    }
    this.utf16Length = n, this.utf8Length = u, this.utf16Value = t, this.utf8Value = o, this.utf16OffsetToUtf8 = i, this.utf8OffsetToUtf16 = a;
  }
  static _utf8ByteLength(t) {
    let n = 0;
    for (let u = 0, r = t.length; u < r; u++) {
      const i = t.charCodeAt(u);
      let a = i, o = !1;
      if (i >= 55296 && i <= 56319 && u + 1 < r) {
        const s = t.charCodeAt(u + 1);
        s >= 56320 && s <= 57343 && (a = (i - 55296 << 10) + 65536 | s - 56320, o = !0);
      }
      a <= 127 ? n += 1 : a <= 2047 ? n += 2 : a <= 65535 ? n += 3 : n += 4, o && u++;
    }
    return n;
  }
  createString(t) {
    const n = t.omalloc(this.utf8Length);
    return t.HEAPU8.set(this.utf8Value, n), n;
  }
}
const It = class te {
  constructor(t) {
    if (N(this, "id", ++te.LAST_ID), N(this, "_onigBinding"), N(this, "content"), N(this, "utf16Length"), N(this, "utf8Length"), N(this, "utf16OffsetToUtf8"), N(this, "utf8OffsetToUtf16"), N(this, "ptr"), !B)
      throw new jn("Must invoke loadWasm first.");
    this._onigBinding = B, this.content = t;
    const n = new Nt(t);
    this.utf16Length = n.utf16Length, this.utf8Length = n.utf8Length, this.utf16OffsetToUtf8 = n.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n.utf8OffsetToUtf16, this.utf8Length < 1e4 && !te._sharedPtrInUse ? (te._sharedPtr || (te._sharedPtr = B.omalloc(1e4)), te._sharedPtrInUse = !0, B.HEAPU8.set(n.utf8Value, te._sharedPtr), this.ptr = te._sharedPtr) : this.ptr = n.createString(B);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === te._sharedPtr ? te._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
N(It, "LAST_ID", 0);
N(It, "_sharedPtr", 0);
N(It, "_sharedPtrInUse", !1);
let Yr = It;
class O0 {
  constructor(t) {
    if (N(this, "_onigBinding"), N(this, "_ptr"), !B)
      throw new jn("Must invoke loadWasm first.");
    const n = [], u = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const l = new Nt(t[o]);
      n[o] = l.createString(B), u[o] = l.utf8Length;
    }
    const r = B.omalloc(4 * t.length);
    B.HEAPU32.set(n, r / 4);
    const i = B.omalloc(4 * t.length);
    B.HEAPU32.set(u, i / 4);
    const a = B.createOnigScanner(r, i, t.length);
    for (let o = 0, s = t.length; o < s; o++)
      B.ofree(n[o]);
    B.ofree(i), B.ofree(r), a === 0 && M0(B), this._onigBinding = B, this._ptr = a;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(t, n, u) {
    let r = 0;
    if (typeof u == "number" && (r = u), typeof t == "string") {
      t = new Yr(t);
      const i = this._findNextMatchSync(t, n, !1, r);
      return t.dispose(), i;
    }
    return this._findNextMatchSync(t, n, !1, r);
  }
  _findNextMatchSync(t, n, u, r) {
    const i = this._onigBinding, a = i.findNextOnigScannerMatch(this._ptr, t.id, t.ptr, t.utf8Length, t.convertUtf16OffsetToUtf8(n), r);
    if (a === 0)
      return null;
    const o = i.HEAPU32;
    let s = a / 4;
    const l = o[s++], c = o[s++], d = [];
    for (let f = 0; f < c; f++) {
      const p = t.convertUtf8OffsetToUtf16(o[s++]), h = t.convertUtf8OffsetToUtf16(o[s++]);
      d[f] = {
        start: p,
        end: h,
        length: h - p
      };
    }
    return {
      index: l,
      captureIndices: d
    };
  }
}
function B0(e) {
  return typeof e.instantiator == "function";
}
function j0(e) {
  return typeof e.default == "function";
}
function z0(e) {
  return typeof e.data < "u";
}
function $0(e) {
  return typeof Response < "u" && e instanceof Response;
}
function q0(e) {
  var t;
  return typeof ArrayBuffer < "u" && (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) || typeof Buffer < "u" && ((t = Buffer.isBuffer) == null ? void 0 : t.call(Buffer, e)) || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer || typeof Uint32Array < "u" && e instanceof Uint32Array;
}
let at;
function G0(e) {
  if (at)
    return at;
  async function t() {
    B = await P0(async (n) => {
      let u = e;
      return u = await u, typeof u == "function" && (u = await u(n)), typeof u == "function" && (u = await u(n)), B0(u) ? u = await u.instantiator(n) : j0(u) ? u = await u.default(n) : (z0(u) && (u = u.data), $0(u) ? typeof WebAssembly.instantiateStreaming == "function" ? u = await H0(u)(n) : u = await U0(u)(n) : q0(u) ? u = await Yt(u)(n) : u instanceof WebAssembly.Module ? u = await Yt(u)(n) : "default" in u && u.default instanceof WebAssembly.Module && (u = await Yt(u.default)(n))), "instance" in u && (u = u.instance), "exports" in u && (u = u.exports), u;
    });
  }
  return at = t(), at;
}
function Yt(e) {
  return (t) => WebAssembly.instantiate(e, t);
}
function H0(e) {
  return (t) => WebAssembly.instantiateStreaming(e, t);
}
function U0(e) {
  return async (t) => {
    const n = await e.arrayBuffer();
    return WebAssembly.instantiate(n, t);
  };
}
async function W0(e) {
  return e && await G0(e), {
    createScanner(t) {
      return new O0(t.map((n) => typeof n == "string" ? n : n.source));
    },
    createString(t) {
      return new Yr(t);
    }
  };
}
const V0 = /* @__PURE__ */ v0({
  langs: S0,
  themes: F0,
  engine: () => W0(import("./wasm-DQxwEHae.mjs"))
});
async function Z0(e = {}) {
  const t = Array.isArray(e.themes) ? e.themes : e.themes ? [e.themes] : ["github-dark"], n = await V0({
    // @ts-ignore - 类型兼容问题
    themes: t,
    // @ts-ignore - 类型兼容问题
    langs: e.langs || []
  }), u = e.processors || [];
  return {
    ...n,
    codeToHtml(i, a) {
      const o = typeof a == "string" ? a : a.lang || "text", { code: s } = Os(u, i, o), l = typeof a == "object" && a.theme ? a.theme : t[0];
      let c = n.codeToHtml(s, {
        lang: o,
        // @ts-ignore - 类型兼容问题
        theme: l
      });
      return c = Bs(u, c, o), c;
    },
    // 直接透传原始方法
    loadLanguage: (i) => n.loadLanguage(i),
    getLoadedLanguages: () => n.getLoadedLanguages(),
    getLoadedThemes: () => n.getLoadedThemes()
  };
}
const J0 = Ss("abcdefghijklmnopqrstuvwxyz", 10), K0 = {
  name: "error-level",
  handler: Rt()
};
async function Q0(e = "github-dark", t = [], n = "", u = console) {
  const r = typeof e == "string" || "name" in e, i = (m) => typeof m == "string" ? m : m.name || "github-dark", a = [
    Is(),
    Ms({ hasHighlightClass: "highlighted" }),
    Ns(),
    K0
  ], o = {
    langs: ["css", ...t],
    processors: a
  };
  r ? o.themes = [e] : o.themes = [e.dark, e.light];
  const s = await Z0(o), l = async (m) => {
    m && !s.getLoadedLanguages().includes(m) && await s.loadLanguage(m);
  };
  n && await l(n);
  const c = /<pre[^>]*(style=".*?")/, d = /^<pre(.*?)>/, f = /-vue$/, p = /:(no-)?line-numbers$/, h = /\{\{.*?\}\}/g;
  return { plugin: (m, b, _) => {
    const y = f.test(b) ? "" : "v-pre";
    b = b.replace(p, "").replace(f, "").toLowerCase() || n, b && !s.getLoadedLanguages().includes(b) && b !== "ansi" && b !== "txt" && u.warn(`
The language '${b}' is not loaded, falling back to '${n || "txt"}' for syntax highlighting.`);
    const x = (P) => P.replace(d, ($, D) => `<pre ${y}${D.replace(' tabindex="0"', "")}>`).replace(c, ($, D) => $.replace(D, "")), C = /* @__PURE__ */ new Map(), v = (P) => y ? P : P.replace(h, ($) => {
      let D = C.get($);
      return D || (D = J0(), C.set($, D)), D;
    }), A = (P) => (C.forEach(($, D) => {
      P = P.replace(new RegExp($, "gi"), D);
    }), P), S = (P) => P.replace(/(<span class="line highlighted">)(<\/span>)/g, "$1<wbr>$2");
    m = v(m);
    const L = (P) => {
      let $;
      try {
        const D = i(P);
        $ = b === "ansi" ? s.codeToHtml(m, {
          lang: "ansi",
          theme: D
        }) : s.codeToHtml(m, {
          lang: b,
          theme: D
        });
      } catch {
        const G = i(P);
        $ = s.codeToHtml(m, {
          lang: "ansi",
          theme: G
        });
      }
      return S(x(A($)));
    };
    if (r) return L(e);
    const M = He(L(e.dark), "vp-code-dark", "pre"), Z = He(L(e.light), "vp-code-light", "pre");
    return M + Z;
  }, highlighter: s, loadLang: l };
}
const en = /{([\d,-]+)}/, X0 = (e) => {
  const t = e.renderer.rules.fence;
  e.renderer.rules.fence = (...n) => {
    const [u, r] = n, i = u[r], a = i.attrs && i.attrs[0];
    let o = null;
    if (!a) {
      const s = i.info;
      if (!s || !en.test(s))
        return t(...n);
      const l = s.replace(en, "").trim();
      i.info = l, o = en.exec(s)[1];
    }
    return !o && (o = a[0], !o || !/[\d,-]+/.test(o)) ? t(...n) : (i.info += " " + o, t(...n));
  };
}, Y0 = (e) => {
  const t = e.renderer.rules.image;
  e.renderer.rules.image = (n, u, r, i, a) => {
    const o = n[u];
    let s = o.attrGet("src");
    return s && !ln.test(s) && (/^\.?\//.test(s) || (s = "./" + s), o.attrSet("src", decodeURIComponent(s))), t(n, u, r, i, a);
  };
}, ed = (e, t = !1) => {
  const n = e.renderer.rules.fence;
  e.renderer.rules.fence = (...u) => {
    const r = n(...u), [i, a] = u, o = i[a].info;
    if (!t && !/:line-numbers($| )/.test(o) || t && /:no-line-numbers($| )/.test(o))
      return r;
    const l = r.slice(
      r.indexOf("<code>"),
      r.indexOf("</code>")
    ).split(`
`), d = `<div class="line-numbers-wrapper" aria-hidden="true">${[
      ...Array(
        l.length - (l[l.length - 1] === '<span class="line"></span>' ? 1 : 0)
      )
    ].map((p, h) => `<span class="line-number">${h + 1}</span><br>`).join("")}</div>`;
    return r.replace(/<\/div>$/, `${d}</div>`).replace(/"(language-[^"]*?)"/, '"$1 line-numbers-mode"');
  };
}, td = /(^|.*\/)index.md(#?.*)$/i, nd = (e, t, n) => {
  e.renderer.rules.link_open = (i, a, o, s, l) => {
    const c = i[a], d = c.attrIndex("href");
    if (d >= 0) {
      const f = c.attrs[d], p = f[1];
      ln.test(p) ? (Object.entries(t).forEach(([g, m]) => {
        c.attrSet(g, m);
      }), p.replace(ln, "").startsWith("//localhost:") && r(p, s), f[1] = p.replace(Ds, "")) : (// internal anchor links
      !p.startsWith("#") && // mail links
      !p.startsWith("mailto:") && // links to files (other than html/md)
      !/\.(?!html|md)\w+($|\?)/i.test(p) ? u(f, s) : p.startsWith("#") && (f[1] = decodeURI(f[1])), f[1].startsWith("/") && (f[1] = `${n}${f[1]}`.replace(/\/+/g, "/"))), f[1] = f[1].replace(/\bimport\.meta/g, "import%2Emeta").replace(/\bprocess\.env/g, "process%2Eenv");
    }
    return l.renderToken(i, a, o);
  };
  function u(i, a) {
    let o = i[1];
    const s = o.match(td);
    if (s) {
      const [, l, c] = s;
      o = l + c;
    } else {
      let l = o.replace(/[?#].*$/, "");
      l.endsWith(".md") && (l = l.replace(/\.md$/, a.cleanUrls ? "" : ".html")), !a.cleanUrls && !l.endsWith(".html") && !l.endsWith("/") && (l += ".html");
      const c = new URL(o, "http://a.com");
      o = l + c.search + c.hash;
    }
    !o.startsWith("/") && !/^\.\//.test(o) && (o = "./" + o), r(o.replace(/\.html$/, ""), a), i[1] = decodeURI(o);
  }
  function r(i, a) {
    (a.links || (a.links = [])).push(i);
  }
}, ei = async (e = {}, t = "/", n = console) => {
  var o;
  const { plugin: u, highlighter: r, loadLang: i } = await Q0(e.theme, e.languages, e.defaultHighlightLang, n), a = X({
    html: !0,
    linkify: !0,
    highlight: e.highlight || u,
    ...e
  });
  return a.linkify.set({ fuzzyLink: !1 }), a.use(X0).use(Ts).use(Ls).use(Y0).use(nd, { target: "_blank", rel: "noreferrer", ...e.externalLinks }, t).use(ed, e.lineNumbers), (o = e.attrs) != null && o.disable || a.use(gs, e.attrs), a.use(vs), a.use(_e, {
    slugify: lt,
    permalink: _e.permalink.linkInsideHeader({
      symbol: "&ZeroWidthSpace;",
      renderAttrs: (s, l) => {
        const c = l.tokens.findIndex((f) => {
          const p = f.attrs, h = p == null ? void 0 : p.find((g) => g[0] === "id");
          return h && s === h[1];
        });
        return {
          "aria-label": `Permalink to "${l.tokens[c + 1].content}"`
        };
      }
    }),
    ...e.anchor
  }), e.headers && a.use(yi, {
    level: [2, 3, 4, 5, 6],
    slugify: lt,
    ...typeof e.headers == "boolean" ? void 0 : e.headers
  }), a.use(ki).use(Ci, {
    ...e.toc
  }), e.config && e.config(a), { md: a, highlighter: r, loadLang: i };
}, ud = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function rd(e, t) {
  return Q(), ne("svg", ud, t[0] || (t[0] = [
    ue("path", {
      fill: "none",
      stroke: "currentColor",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5l5-5m-5-7v12"
    }, null, -1)
  ]));
}
const id = kn({ name: "tabler-download", render: rd }), ad = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function od(e, t) {
  return Q(), ne("svg", ad, t[0] || (t[0] = [
    ue("path", {
      fill: "none",
      stroke: "currentColor",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "m5 12l5 5L20 7"
    }, null, -1)
  ]));
}
const sd = kn({ name: "tabler-check", render: od }), ld = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function cd(e, t) {
  return Q(), ne("svg", ld, t[0] || (t[0] = [
    ue("g", {
      fill: "none",
      stroke: "currentColor",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2"
    }, [
      ue("path", { d: "M7 9.667A2.667 2.667 0 0 1 9.667 7h8.666A2.667 2.667 0 0 1 21 9.667v8.666A2.667 2.667 0 0 1 18.333 21H9.667A2.667 2.667 0 0 1 7 18.333z" }),
      ue("path", { d: "M4.012 16.737A2 2 0 0 1 3 15V5c0-1.1.9-2 2-2h10c.75 0 1.158.385 1.5 1" })
    ], -1)
  ]));
}
const dd = kn({ name: "tabler-copy", render: cd });
async function fd(e) {
  try {
    return navigator.clipboard.writeText(e);
  } catch {
    const t = document.createElement("textarea"), n = document.activeElement;
    t.value = e, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt";
    const u = document.getSelection(), r = u ? u.rangeCount > 0 && u.getRangeAt(0) : null;
    document.body.appendChild(t), t.select(), t.selectionStart = 0, t.selectionEnd = e.length, document.execCommand("copy"), document.body.removeChild(t), r && (u.removeAllRanges(), u.addRange(r)), n && n.focus();
  }
}
const hd = (e, t = !1) => {
  const n = "ABCDEFGHJKLMNPQRSTUVWXY3456789";
  let u = "";
  for (let r = 0; r < e.valueOf(); r++)
    u += n.charAt(Math.floor(Math.random() * n.length));
  return t ? u.toLowerCase() : u;
}, pd = {
  javascript: ".js",
  python: ".py",
  java: ".java",
  c: ".c",
  cpp: ".cpp",
  "c++": ".cpp",
  "c#": ".cs",
  ruby: ".rb",
  php: ".php",
  swift: ".swift",
  "objective-c": ".m",
  kotlin: ".kt",
  typescript: ".ts",
  go: ".go",
  perl: ".pl",
  rust: ".rs",
  scala: ".scala",
  haskell: ".hs",
  lua: ".lua",
  shell: ".sh",
  sql: ".sql",
  html: ".html",
  css: ".css"
}, md = (e, t, n = "Enter file name") => {
  const u = pd[e] || ".file", r = `file-${hd(3, !0)}${u}`, i = window.prompt(n || "", r);
  if (!i)
    return;
  const a = new Blob([t], { type: "text/plain" }), o = URL.createObjectURL(a), s = document.createElement("a");
  s.download = i, s.href = o, s.style.display = "none", document.body.appendChild(s), s.click(), document.body.removeChild(s), URL.revokeObjectURL(o);
}, gd = { class: "vp-header" }, _d = { class: "ctrl" }, yn = /* @__PURE__ */ At({
  __name: "VueMarkDownHeader",
  props: {
    lang: {
      type: String,
      default: "txt"
    },
    copyTxt: {
      type: String,
      default: "Copy"
    },
    copiedTxt: {
      type: String,
      default: "Copied"
    },
    item: {
      type: String,
      default: ""
    },
    downloadTxt: {
      type: String,
      default: "Enter file name"
    }
  },
  setup(e) {
    const t = e, n = ve(!1), u = ve(null), r = tn(() => n.value ? t.copiedTxt : t.copyTxt);
    function i() {
      const o = /* @__PURE__ */ new Map();
      fd(t.item).then(() => {
        n.value = !0, clearTimeout(o.get(u.value));
        const s = setTimeout(() => {
          n.value = !1, o.delete(u.value);
        }, 2e3);
        o.set(u.value, s);
      });
    }
    function a() {
      md(t.lang, t.item, t.downloadTxt);
    }
    return (o, s) => {
      const l = dd, c = sd, d = id;
      return Q(), ne("div", gd, [
        Nu(o.$slots, "default", {}, () => [
          ue("div", null, nn(e.lang), 1)
        ]),
        ue("div", _d, [
          ue("div", {
            class: "copyRef ctrl",
            onClick: i,
            ref_key: "copyRef",
            ref: u
          }, [
            n.value ? (Q(), zn(c, { key: 1 })) : (Q(), zn(l, { key: 0 })),
            ue("span", null, nn(r.value), 1)
          ], 512),
          de(d, {
            class: "copyRef",
            onClick: a
          })
        ])
      ]);
    };
  }
}), bd = { class: "tabs" }, yd = ["onClick"], kd = ["innerHTML"], xd = /* @__PURE__ */ At({
  __name: "VueGroupCode",
  props: {
    names: {
      type: Object,
      required: !0
    },
    blocks: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = ve(0);
    function n(u) {
      t.value = u;
    }
    return (u, r) => (Q(), ne(Mt, null, [
      de(yn, null, {
        default: ui(() => [
          ue("div", bd, [
            (Q(!0), ne(Mt, null, $n(e.names, (i, a) => (Q(), ne("span", {
              key: a,
              onClick: () => n(a),
              class: un({ active: t.value === a })
            }, nn(i), 11, yd))), 128))
          ])
        ]),
        _: 1
      }),
      (Q(!0), ne(Mt, null, $n(e.blocks, (i, a) => ri((Q(), ne("div", {
        innerHTML: i.innerHTML,
        class: un(i.className),
        key: a
      }, null, 10, kd)), [
        [ii, t.value === a]
      ])), 128))
    ], 64));
  }
});
function wd(e) {
  let t = e;
  const n = /以下是(.+)续写的代码：\n\n/, u = t.match(n);
  if (u) {
    const i = u[1];
    t = t.replace(n, `以下是${i}续写的代码：

\`\`\`${i.toLocaleLowerCase()}

`);
  }
  const r = /\n```\n/g;
  return t = t.replace(r, "\n``` \n"), t;
}
const Dd = /* @__PURE__ */ At({
  components: {
    VueMarkDownHeader: yn
  },
  props: {
    content: {
      type: String,
      required: !0
    },
    style: {
      type: Object,
      default: () => {
      }
    },
    class: {
      type: String,
      default: ""
    },
    stream: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, {
    expose: t
  }) {
    const n = ve(""), u = ve(), r = ve();
    t({
      render: n,
      md: u,
      loadLangFn: r
    });
    const i = new RegExp("(?<=```)\\S+", "g"), {
      stream: a,
      class: o,
      style: s
    } = ai(e), l = tn(() => ["vp-doc", o.value]);
    function c(g, m = "") {
      let b = "";
      const y = new DOMParser().parseFromString(g, "text/html"), x = /shellscript|shell|bash|sh|zsh/.test(m);
      return y.querySelectorAll("span.line:not(.diff.remove)").forEach((C) => b += (C.textContent || "") + `
`), x && (b = b.replace(/^ *(\$|>) /gm, "").trim()), b.slice(0, -1);
    }
    const d = tn(() => wd(e.content || ""));
    function f(g) {
      if (g.nodeType === Node.TEXT_NODE)
        return g.textContent;
      if (g.nodeType === Node.ELEMENT_NODE) {
        const m = g, b = /^language-/, _ = Array.from(m.classList).some((C) => b.test(C)), y = /vp-code-group/;
        if (Array.from(m.classList).some((C) => y.test(C))) {
          const v = Array.from(m.querySelectorAll(".tabs label")).map((S) => S.innerText), A = m.querySelectorAll(".blocks div");
          return de(xd, {
            names: v,
            blocks: A
          }, null);
        } else if (_) {
          const C = m.className.match(/language-([\w+]+)/), v = C ? C[1] : "plain", A = c(m.innerHTML, v), S = m.innerHTML;
          return de("div", {
            class: l.value,
            style: {
              ...s
            }
          }, [de(ci("slot"), {
            name: "code",
            item: A,
            html: A,
            lang: v
          }, {
            default: () => [de(yn, {
              lang: v,
              item: A
            }, null)]
          }), de("div", {
            class: m.className,
            innerHTML: S
          }, null)]);
        } else {
          const C = Array.from(m.childNodes).map(f).flat(), v = {};
          for (let A = 0; A < m.attributes.length; A++) {
            const S = m.attributes[A];
            v[S.name] = S.value;
          }
          return di(m.tagName, {
            ...v
          }, C);
        }
      }
    }
    async function p() {
      var m;
      const g = Array.from(d.value.matchAll(i)).map((b) => b[0]);
      if (g && r.value)
        for (let b = 0; b < g.length; b++) {
          const _ = g[b];
          try {
            const y = dr[_.toLocaleLowerCase()] || _;
            await r.value(y);
          } catch {
            continue;
          }
        }
      n.value = ((m = u.value) == null ? void 0 : m.render(d.value)) || "";
    }
    oi(d, async () => await p()), si(async () => {
      const {
        md: g,
        loadLang: m
      } = await li(Tn);
      u.value = g, r.value = m, await p();
    });
    function h() {
      const m = new DOMParser().parseFromString(n.value, "text/html"), b = f(m.body);
      return de("div", {
        class: [l.value, {
          "result-streaming": a.value
        }],
        style: {
          ...s.value
        }
      }, [b]);
    }
    return () => h();
  }
}), Fd = /* @__PURE__ */ At({
  __name: "VueMarkdownItProvider",
  props: {
    options: {
      type: Object,
      default: {
        theme: "dracula-soft",
        defaultHighlightLang: "javascript"
      }
    },
    class: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e, n = t.class, u = ei({
      ...t.options
    });
    return fi(Tn, u), (r, i) => (Q(), ne("div", {
      class: un(hi(n))
    }, [
      Nu(r.$slots, "default")
    ], 2));
  }
}), Td = {
  install(e, t = {
    theme: "dracula-soft",
    defaultHighlightLang: "javascript"
  }) {
    const n = ei({
      ...t
    });
    e.provide(Tn, n);
  }
};
export {
  yn as VueMarkDownHeader,
  Dd as VueMarkdownIt,
  Fd as VueMarkdownItProvider,
  Td as default
};
