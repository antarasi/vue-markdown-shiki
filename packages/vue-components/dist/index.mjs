import { openBlock as de, createElementBlock as Te, createElementVNode as ae, defineComponent as io, ref as We, computed as $n, toDisplayString as it, createBlock as lt, unref as lo, createVNode as uo, watch as Zo, onBeforeMount as Jo, inject as Qo, normalizeClass as Yo, normalizeStyle as Xo, Fragment as ut, renderList as Ko, renderSlot as es, createCommentVNode as ns } from "vue";
const ts = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
}, os = /[&<>'"]/g, Oe = (n) => n.replace(
  os,
  (e) => ts[e]
), po = (n, { shouldAllowHtml: e, shouldEscapeText: t }) => {
  const o = n.children ?? [], r = ["text", "emoji", "code_inline"];
  return e && r.push("html_inline"), o.filter(
    (a) => {
      var c;
      return r.includes(a.type) && // filter permalink symbol that generated by markdown-it-anchor
      !((c = a.meta) != null && c.isPermalinkSymbol);
    }
  ).reduce((a, c) => t && (c.type === "code_inline" || c.type === "text") ? `${a}${Oe(c.content)}` : `${a}${c.content}`, "").trim();
}, ho = (n, {
  level: e,
  shouldAllowHtml: t,
  shouldAllowNested: o,
  shouldEscapeText: r,
  slugify: s,
  format: a
}) => {
  const c = [], l = [], i = (p) => {
    for (; l.length !== 0 && p.level <= l[0].level; )
      l.shift();
    l.length === 0 ? (c.push(p), l.push(p)) : (l[0].children.push(p), l.unshift(p));
  };
  for (let p = 0; p < n.length; p += 1) {
    const h = n[p];
    if ((h == null ? void 0 : h.type) !== "heading_open" || (h == null ? void 0 : h.level) !== 0 && !o)
      continue;
    const d = Number.parseInt(h.tag.slice(1), 10);
    if (!e.includes(d))
      continue;
    const f = n[p + 1];
    if (!f)
      continue;
    const m = po(f, {
      shouldAllowHtml: t,
      shouldEscapeText: r
    }), S = h.attrGet("id") ?? s(m);
    i({
      level: d,
      title: (a == null ? void 0 : a(m)) ?? m,
      slug: S,
      link: `#${S}`,
      children: []
    });
  }
  return c;
}, ss = /[\u0000-\u001f]/g, rs = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'“”‘’<>,.?/]+/g, cs = /[\u0300-\u036F]/g, on = (n) => n.normalize("NFKD").replace(cs, "").replace(ss, "").replace(rs, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/^(\d)/, "_$1").toLowerCase(), as = (n, {
  level: e = [2, 3],
  shouldAllowNested: t = !1,
  slugify: o = on,
  format: r
} = {}) => {
  const s = n.renderer.render.bind(n.renderer);
  n.renderer.render = (a, c, l) => (l.headers = ho(a, {
    level: e,
    shouldAllowHtml: !1,
    shouldAllowNested: t,
    shouldEscapeText: !1,
    slugify: o,
    format: r
  }), s(a, c, l));
}, is = (n) => {
  const e = n.renderer.render.bind(n.renderer);
  n.renderer.render = (t, o, r) => {
    const s = t.findIndex((a) => a.tag === "h1");
    return r.title = s > -1 ? po(t[s + 1], {
      shouldAllowHtml: !1,
      shouldEscapeText: !1
    }) : "", e(t, o, r);
  };
}, ls = ({
  listTag: n,
  listClass: e,
  itemClass: t,
  linkTag: o,
  linkClass: r
}) => {
  const s = Oe(n), a = e ? ` class="${Oe(e)}"` : "", c = "li", l = t ? ` class="${Oe(t)}"` : "", i = Oe(o), p = r ? ` class="${Oe(r)}"` : "", h = (f) => o === "router-link" ? ` to="${f}"` : ` href="${f}"`, d = (f) => `<${s}${a}>${f.map(
    (m) => `<${c}${l}${l}><${i}${p}${h(m.link)}>${m.title}</${i}>${m.children.length > 0 ? d(m.children) : ""}</${c}>`
  ).join("")}</${s}>`;
  return d;
}, us = ({
  pattern: n,
  containerTag: e,
  containerClass: t
}) => (o, r, s, a) => {
  if (o.sCount[r] - o.blkIndent >= 4)
    return !1;
  const c = o.bMarks[r] + o.tShift[r], l = o.eMarks[r], i = o.src.slice(c, l).split(" ")[0];
  if (!n.test(i))
    return !1;
  if (a)
    return !0;
  o.line = r + 1;
  const p = o.push("toc_open", e, 1);
  p.markup = "", p.map = [r, o.line], t && p.attrSet("class", t);
  const h = o.push("toc_body", "", 0);
  h.markup = i, h.map = [r, o.line], h.hidden = !0;
  const d = o.push("toc_close", e, -1);
  return d.markup = "", h.map = [r, o.line], !0;
}, ps = (n, {
  pattern: e = /^\[\[toc\]\]$/i,
  slugify: t = on,
  format: o,
  level: r = [2, 3],
  shouldAllowNested: s = !1,
  containerTag: a = "nav",
  containerClass: c = "table-of-contents",
  listTag: l = "ul",
  listClass: i = "",
  itemClass: p = "",
  linkTag: h = "a",
  linkClass: d = ""
} = {}) => {
  n.block.ruler.before(
    "heading",
    "toc",
    us({
      pattern: e,
      containerTag: a,
      containerClass: c
    }),
    {
      alt: ["paragraph", "reference", "blockquote"]
    }
  );
  const f = ls({
    listTag: l,
    listClass: i,
    itemClass: p,
    linkTag: h,
    linkClass: d
  });
  n.renderer.rules.toc_body = (m) => f(
    ho(m, {
      level: r,
      shouldAllowHtml: !0,
      shouldAllowNested: s,
      shouldEscapeText: !0,
      slugify: t,
      format: o
    })
  );
};
var fo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hs(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function ds(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function o() {
      if (this instanceof o) {
        var r = [null];
        r.push.apply(r, arguments);
        var s = Function.bind.apply(e, r);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(o) {
    var r = Object.getOwnPropertyDescriptor(n, o);
    Object.defineProperty(t, o, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[o];
      }
    });
  }), t;
}
var Gn = {}, fs = {
  get exports() {
    return Gn;
  },
  set exports(n) {
    Gn = n;
  }
}, B = {}, sn = {}, ms = {
  get exports() {
    return sn;
  },
  set exports(n) {
    sn = n;
  }
};
const gs = "Á", _s = "á", bs = "Ă", ks = "ă", ws = "∾", ys = "∿", vs = "∾̳", xs = "Â", As = "â", Ss = "´", Ls = "А", Es = "а", Cs = "Æ", Ts = "æ", Ds = "⁡", qs = "𝔄", js = "𝔞", Rs = "À", Ns = "à", Ps = "ℵ", Is = "ℵ", Os = "Α", Fs = "α", Ms = "Ā", Bs = "ā", zs = "⨿", $s = "&", Gs = "&", Us = "⩕", Hs = "⩓", Vs = "∧", Ws = "⩜", Zs = "⩘", Js = "⩚", Qs = "∠", Ys = "⦤", Xs = "∠", Ks = "⦨", er = "⦩", nr = "⦪", tr = "⦫", or = "⦬", sr = "⦭", rr = "⦮", cr = "⦯", ar = "∡", ir = "∟", lr = "⊾", ur = "⦝", pr = "∢", hr = "Å", dr = "⍼", fr = "Ą", mr = "ą", gr = "𝔸", _r = "𝕒", br = "⩯", kr = "≈", wr = "⩰", yr = "≊", vr = "≋", xr = "'", Ar = "⁡", Sr = "≈", Lr = "≊", Er = "Å", Cr = "å", Tr = "𝒜", Dr = "𝒶", qr = "≔", jr = "*", Rr = "≈", Nr = "≍", Pr = "Ã", Ir = "ã", Or = "Ä", Fr = "ä", Mr = "∳", Br = "⨑", zr = "≌", $r = "϶", Gr = "‵", Ur = "∽", Hr = "⋍", Vr = "∖", Wr = "⫧", Zr = "⊽", Jr = "⌅", Qr = "⌆", Yr = "⌅", Xr = "⎵", Kr = "⎶", ec = "≌", nc = "Б", tc = "б", oc = "„", sc = "∵", rc = "∵", cc = "∵", ac = "⦰", ic = "϶", lc = "ℬ", uc = "ℬ", pc = "Β", hc = "β", dc = "ℶ", fc = "≬", mc = "𝔅", gc = "𝔟", _c = "⋂", bc = "◯", kc = "⋃", wc = "⨀", yc = "⨁", vc = "⨂", xc = "⨆", Ac = "★", Sc = "▽", Lc = "△", Ec = "⨄", Cc = "⋁", Tc = "⋀", Dc = "⤍", qc = "⧫", jc = "▪", Rc = "▴", Nc = "▾", Pc = "◂", Ic = "▸", Oc = "␣", Fc = "▒", Mc = "░", Bc = "▓", zc = "█", $c = "=⃥", Gc = "≡⃥", Uc = "⫭", Hc = "⌐", Vc = "𝔹", Wc = "𝕓", Zc = "⊥", Jc = "⊥", Qc = "⋈", Yc = "⧉", Xc = "┐", Kc = "╕", ea = "╖", na = "╗", ta = "┌", oa = "╒", sa = "╓", ra = "╔", ca = "─", aa = "═", ia = "┬", la = "╤", ua = "╥", pa = "╦", ha = "┴", da = "╧", fa = "╨", ma = "╩", ga = "⊟", _a = "⊞", ba = "⊠", ka = "┘", wa = "╛", ya = "╜", va = "╝", xa = "└", Aa = "╘", Sa = "╙", La = "╚", Ea = "│", Ca = "║", Ta = "┼", Da = "╪", qa = "╫", ja = "╬", Ra = "┤", Na = "╡", Pa = "╢", Ia = "╣", Oa = "├", Fa = "╞", Ma = "╟", Ba = "╠", za = "‵", $a = "˘", Ga = "˘", Ua = "¦", Ha = "𝒷", Va = "ℬ", Wa = "⁏", Za = "∽", Ja = "⋍", Qa = "⧅", Ya = "\\", Xa = "⟈", Ka = "•", ei = "•", ni = "≎", ti = "⪮", oi = "≏", si = "≎", ri = "≏", ci = "Ć", ai = "ć", ii = "⩄", li = "⩉", ui = "⩋", pi = "∩", hi = "⋒", di = "⩇", fi = "⩀", mi = "ⅅ", gi = "∩︀", _i = "⁁", bi = "ˇ", ki = "ℭ", wi = "⩍", yi = "Č", vi = "č", xi = "Ç", Ai = "ç", Si = "Ĉ", Li = "ĉ", Ei = "∰", Ci = "⩌", Ti = "⩐", Di = "Ċ", qi = "ċ", ji = "¸", Ri = "¸", Ni = "⦲", Pi = "¢", Ii = "·", Oi = "·", Fi = "𝔠", Mi = "ℭ", Bi = "Ч", zi = "ч", $i = "✓", Gi = "✓", Ui = "Χ", Hi = "χ", Vi = "ˆ", Wi = "≗", Zi = "↺", Ji = "↻", Qi = "⊛", Yi = "⊚", Xi = "⊝", Ki = "⊙", el = "®", nl = "Ⓢ", tl = "⊖", ol = "⊕", sl = "⊗", rl = "○", cl = "⧃", al = "≗", il = "⨐", ll = "⫯", ul = "⧂", pl = "∲", hl = "”", dl = "’", fl = "♣", ml = "♣", gl = ":", _l = "∷", bl = "⩴", kl = "≔", wl = "≔", yl = ",", vl = "@", xl = "∁", Al = "∘", Sl = "∁", Ll = "ℂ", El = "≅", Cl = "⩭", Tl = "≡", Dl = "∮", ql = "∯", jl = "∮", Rl = "𝕔", Nl = "ℂ", Pl = "∐", Il = "∐", Ol = "©", Fl = "©", Ml = "℗", Bl = "∳", zl = "↵", $l = "✗", Gl = "⨯", Ul = "𝒞", Hl = "𝒸", Vl = "⫏", Wl = "⫑", Zl = "⫐", Jl = "⫒", Ql = "⋯", Yl = "⤸", Xl = "⤵", Kl = "⋞", eu = "⋟", nu = "↶", tu = "⤽", ou = "⩈", su = "⩆", ru = "≍", cu = "∪", au = "⋓", iu = "⩊", lu = "⊍", uu = "⩅", pu = "∪︀", hu = "↷", du = "⤼", fu = "⋞", mu = "⋟", gu = "⋎", _u = "⋏", bu = "¤", ku = "↶", wu = "↷", yu = "⋎", vu = "⋏", xu = "∲", Au = "∱", Su = "⌭", Lu = "†", Eu = "‡", Cu = "ℸ", Tu = "↓", Du = "↡", qu = "⇓", ju = "‐", Ru = "⫤", Nu = "⊣", Pu = "⤏", Iu = "˝", Ou = "Ď", Fu = "ď", Mu = "Д", Bu = "д", zu = "‡", $u = "⇊", Gu = "ⅅ", Uu = "ⅆ", Hu = "⤑", Vu = "⩷", Wu = "°", Zu = "∇", Ju = "Δ", Qu = "δ", Yu = "⦱", Xu = "⥿", Ku = "𝔇", ep = "𝔡", np = "⥥", tp = "⇃", op = "⇂", sp = "´", rp = "˙", cp = "˝", ap = "`", ip = "˜", lp = "⋄", up = "⋄", pp = "⋄", hp = "♦", dp = "♦", fp = "¨", mp = "ⅆ", gp = "ϝ", _p = "⋲", bp = "÷", kp = "÷", wp = "⋇", yp = "⋇", vp = "Ђ", xp = "ђ", Ap = "⌞", Sp = "⌍", Lp = "$", Ep = "𝔻", Cp = "𝕕", Tp = "¨", Dp = "˙", qp = "⃜", jp = "≐", Rp = "≑", Np = "≐", Pp = "∸", Ip = "∔", Op = "⊡", Fp = "⌆", Mp = "∯", Bp = "¨", zp = "⇓", $p = "⇐", Gp = "⇔", Up = "⫤", Hp = "⟸", Vp = "⟺", Wp = "⟹", Zp = "⇒", Jp = "⊨", Qp = "⇑", Yp = "⇕", Xp = "∥", Kp = "⤓", eh = "↓", nh = "↓", th = "⇓", oh = "⇵", sh = "̑", rh = "⇊", ch = "⇃", ah = "⇂", ih = "⥐", lh = "⥞", uh = "⥖", ph = "↽", hh = "⥟", dh = "⥗", fh = "⇁", mh = "↧", gh = "⊤", _h = "⤐", bh = "⌟", kh = "⌌", wh = "𝒟", yh = "𝒹", vh = "Ѕ", xh = "ѕ", Ah = "⧶", Sh = "Đ", Lh = "đ", Eh = "⋱", Ch = "▿", Th = "▾", Dh = "⇵", qh = "⥯", jh = "⦦", Rh = "Џ", Nh = "џ", Ph = "⟿", Ih = "É", Oh = "é", Fh = "⩮", Mh = "Ě", Bh = "ě", zh = "Ê", $h = "ê", Gh = "≖", Uh = "≕", Hh = "Э", Vh = "э", Wh = "⩷", Zh = "Ė", Jh = "ė", Qh = "≑", Yh = "ⅇ", Xh = "≒", Kh = "𝔈", ed = "𝔢", nd = "⪚", td = "È", od = "è", sd = "⪖", rd = "⪘", cd = "⪙", ad = "∈", id = "⏧", ld = "ℓ", ud = "⪕", pd = "⪗", hd = "Ē", dd = "ē", fd = "∅", md = "∅", gd = "◻", _d = "∅", bd = "▫", kd = " ", wd = " ", yd = " ", vd = "Ŋ", xd = "ŋ", Ad = " ", Sd = "Ę", Ld = "ę", Ed = "𝔼", Cd = "𝕖", Td = "⋕", Dd = "⧣", qd = "⩱", jd = "ε", Rd = "Ε", Nd = "ε", Pd = "ϵ", Id = "≖", Od = "≕", Fd = "≂", Md = "⪖", Bd = "⪕", zd = "⩵", $d = "=", Gd = "≂", Ud = "≟", Hd = "⇌", Vd = "≡", Wd = "⩸", Zd = "⧥", Jd = "⥱", Qd = "≓", Yd = "ℯ", Xd = "ℰ", Kd = "≐", ef = "⩳", nf = "≂", tf = "Η", of = "η", sf = "Ð", rf = "ð", cf = "Ë", af = "ë", lf = "€", uf = "!", pf = "∃", hf = "∃", df = "ℰ", ff = "ⅇ", mf = "ⅇ", gf = "≒", _f = "Ф", bf = "ф", kf = "♀", wf = "ﬃ", yf = "ﬀ", vf = "ﬄ", xf = "𝔉", Af = "𝔣", Sf = "ﬁ", Lf = "◼", Ef = "▪", Cf = "fj", Tf = "♭", Df = "ﬂ", qf = "▱", jf = "ƒ", Rf = "𝔽", Nf = "𝕗", Pf = "∀", If = "∀", Of = "⋔", Ff = "⫙", Mf = "ℱ", Bf = "⨍", zf = "½", $f = "⅓", Gf = "¼", Uf = "⅕", Hf = "⅙", Vf = "⅛", Wf = "⅔", Zf = "⅖", Jf = "¾", Qf = "⅗", Yf = "⅜", Xf = "⅘", Kf = "⅚", em = "⅝", nm = "⅞", tm = "⁄", om = "⌢", sm = "𝒻", rm = "ℱ", cm = "ǵ", am = "Γ", im = "γ", lm = "Ϝ", um = "ϝ", pm = "⪆", hm = "Ğ", dm = "ğ", fm = "Ģ", mm = "Ĝ", gm = "ĝ", _m = "Г", bm = "г", km = "Ġ", wm = "ġ", ym = "≥", vm = "≧", xm = "⪌", Am = "⋛", Sm = "≥", Lm = "≧", Em = "⩾", Cm = "⪩", Tm = "⩾", Dm = "⪀", qm = "⪂", jm = "⪄", Rm = "⋛︀", Nm = "⪔", Pm = "𝔊", Im = "𝔤", Om = "≫", Fm = "⋙", Mm = "⋙", Bm = "ℷ", zm = "Ѓ", $m = "ѓ", Gm = "⪥", Um = "≷", Hm = "⪒", Vm = "⪤", Wm = "⪊", Zm = "⪊", Jm = "⪈", Qm = "≩", Ym = "⪈", Xm = "≩", Km = "⋧", eg = "𝔾", ng = "𝕘", tg = "`", og = "≥", sg = "⋛", rg = "≧", cg = "⪢", ag = "≷", ig = "⩾", lg = "≳", ug = "𝒢", pg = "ℊ", hg = "≳", dg = "⪎", fg = "⪐", mg = "⪧", gg = "⩺", _g = ">", bg = ">", kg = "≫", wg = "⋗", yg = "⦕", vg = "⩼", xg = "⪆", Ag = "⥸", Sg = "⋗", Lg = "⋛", Eg = "⪌", Cg = "≷", Tg = "≳", Dg = "≩︀", qg = "≩︀", jg = "ˇ", Rg = " ", Ng = "½", Pg = "ℋ", Ig = "Ъ", Og = "ъ", Fg = "⥈", Mg = "↔", Bg = "⇔", zg = "↭", $g = "^", Gg = "ℏ", Ug = "Ĥ", Hg = "ĥ", Vg = "♥", Wg = "♥", Zg = "…", Jg = "⊹", Qg = "𝔥", Yg = "ℌ", Xg = "ℋ", Kg = "⤥", e_ = "⤦", n_ = "⇿", t_ = "∻", o_ = "↩", s_ = "↪", r_ = "𝕙", c_ = "ℍ", a_ = "―", i_ = "─", l_ = "𝒽", u_ = "ℋ", p_ = "ℏ", h_ = "Ħ", d_ = "ħ", f_ = "≎", m_ = "≏", g_ = "⁃", __ = "‐", b_ = "Í", k_ = "í", w_ = "⁣", y_ = "Î", v_ = "î", x_ = "И", A_ = "и", S_ = "İ", L_ = "Е", E_ = "е", C_ = "¡", T_ = "⇔", D_ = "𝔦", q_ = "ℑ", j_ = "Ì", R_ = "ì", N_ = "ⅈ", P_ = "⨌", I_ = "∭", O_ = "⧜", F_ = "℩", M_ = "Ĳ", B_ = "ĳ", z_ = "Ī", $_ = "ī", G_ = "ℑ", U_ = "ⅈ", H_ = "ℐ", V_ = "ℑ", W_ = "ı", Z_ = "ℑ", J_ = "⊷", Q_ = "Ƶ", Y_ = "⇒", X_ = "℅", K_ = "∞", eb = "⧝", nb = "ı", tb = "⊺", ob = "∫", sb = "∬", rb = "ℤ", cb = "∫", ab = "⊺", ib = "⋂", lb = "⨗", ub = "⨼", pb = "⁣", hb = "⁢", db = "Ё", fb = "ё", mb = "Į", gb = "į", _b = "𝕀", bb = "𝕚", kb = "Ι", wb = "ι", yb = "⨼", vb = "¿", xb = "𝒾", Ab = "ℐ", Sb = "∈", Lb = "⋵", Eb = "⋹", Cb = "⋴", Tb = "⋳", Db = "∈", qb = "⁢", jb = "Ĩ", Rb = "ĩ", Nb = "І", Pb = "і", Ib = "Ï", Ob = "ï", Fb = "Ĵ", Mb = "ĵ", Bb = "Й", zb = "й", $b = "𝔍", Gb = "𝔧", Ub = "ȷ", Hb = "𝕁", Vb = "𝕛", Wb = "𝒥", Zb = "𝒿", Jb = "Ј", Qb = "ј", Yb = "Є", Xb = "є", Kb = "Κ", ek = "κ", nk = "ϰ", tk = "Ķ", ok = "ķ", sk = "К", rk = "к", ck = "𝔎", ak = "𝔨", ik = "ĸ", lk = "Х", uk = "х", pk = "Ќ", hk = "ќ", dk = "𝕂", fk = "𝕜", mk = "𝒦", gk = "𝓀", _k = "⇚", bk = "Ĺ", kk = "ĺ", wk = "⦴", yk = "ℒ", vk = "Λ", xk = "λ", Ak = "⟨", Sk = "⟪", Lk = "⦑", Ek = "⟨", Ck = "⪅", Tk = "ℒ", Dk = "«", qk = "⇤", jk = "⤟", Rk = "←", Nk = "↞", Pk = "⇐", Ik = "⤝", Ok = "↩", Fk = "↫", Mk = "⤹", Bk = "⥳", zk = "↢", $k = "⤙", Gk = "⤛", Uk = "⪫", Hk = "⪭", Vk = "⪭︀", Wk = "⤌", Zk = "⤎", Jk = "❲", Qk = "{", Yk = "[", Xk = "⦋", Kk = "⦏", ew = "⦍", nw = "Ľ", tw = "ľ", ow = "Ļ", sw = "ļ", rw = "⌈", cw = "{", aw = "Л", iw = "л", lw = "⤶", uw = "“", pw = "„", hw = "⥧", dw = "⥋", fw = "↲", mw = "≤", gw = "≦", _w = "⟨", bw = "⇤", kw = "←", ww = "←", yw = "⇐", vw = "⇆", xw = "↢", Aw = "⌈", Sw = "⟦", Lw = "⥡", Ew = "⥙", Cw = "⇃", Tw = "⌊", Dw = "↽", qw = "↼", jw = "⇇", Rw = "↔", Nw = "↔", Pw = "⇔", Iw = "⇆", Ow = "⇋", Fw = "↭", Mw = "⥎", Bw = "↤", zw = "⊣", $w = "⥚", Gw = "⋋", Uw = "⧏", Hw = "⊲", Vw = "⊴", Ww = "⥑", Zw = "⥠", Jw = "⥘", Qw = "↿", Yw = "⥒", Xw = "↼", Kw = "⪋", ey = "⋚", ny = "≤", ty = "≦", oy = "⩽", sy = "⪨", ry = "⩽", cy = "⩿", ay = "⪁", iy = "⪃", ly = "⋚︀", uy = "⪓", py = "⪅", hy = "⋖", dy = "⋚", fy = "⪋", my = "⋚", gy = "≦", _y = "≶", by = "≶", ky = "⪡", wy = "≲", yy = "⩽", vy = "≲", xy = "⥼", Ay = "⌊", Sy = "𝔏", Ly = "𝔩", Ey = "≶", Cy = "⪑", Ty = "⥢", Dy = "↽", qy = "↼", jy = "⥪", Ry = "▄", Ny = "Љ", Py = "љ", Iy = "⇇", Oy = "≪", Fy = "⋘", My = "⌞", By = "⇚", zy = "⥫", $y = "◺", Gy = "Ŀ", Uy = "ŀ", Hy = "⎰", Vy = "⎰", Wy = "⪉", Zy = "⪉", Jy = "⪇", Qy = "≨", Yy = "⪇", Xy = "≨", Ky = "⋦", e0 = "⟬", n0 = "⇽", t0 = "⟦", o0 = "⟵", s0 = "⟵", r0 = "⟸", c0 = "⟷", a0 = "⟷", i0 = "⟺", l0 = "⟼", u0 = "⟶", p0 = "⟶", h0 = "⟹", d0 = "↫", f0 = "↬", m0 = "⦅", g0 = "𝕃", _0 = "𝕝", b0 = "⨭", k0 = "⨴", w0 = "∗", y0 = "_", v0 = "↙", x0 = "↘", A0 = "◊", S0 = "◊", L0 = "⧫", E0 = "(", C0 = "⦓", T0 = "⇆", D0 = "⌟", q0 = "⇋", j0 = "⥭", R0 = "‎", N0 = "⊿", P0 = "‹", I0 = "𝓁", O0 = "ℒ", F0 = "↰", M0 = "↰", B0 = "≲", z0 = "⪍", $0 = "⪏", G0 = "[", U0 = "‘", H0 = "‚", V0 = "Ł", W0 = "ł", Z0 = "⪦", J0 = "⩹", Q0 = "<", Y0 = "<", X0 = "≪", K0 = "⋖", ev = "⋋", nv = "⋉", tv = "⥶", ov = "⩻", sv = "◃", rv = "⊴", cv = "◂", av = "⦖", iv = "⥊", lv = "⥦", uv = "≨︀", pv = "≨︀", hv = "¯", dv = "♂", fv = "✠", mv = "✠", gv = "↦", _v = "↦", bv = "↧", kv = "↤", wv = "↥", yv = "▮", vv = "⨩", xv = "М", Av = "м", Sv = "—", Lv = "∺", Ev = "∡", Cv = " ", Tv = "ℳ", Dv = "𝔐", qv = "𝔪", jv = "℧", Rv = "µ", Nv = "*", Pv = "⫰", Iv = "∣", Ov = "·", Fv = "⊟", Mv = "−", Bv = "∸", zv = "⨪", $v = "∓", Gv = "⫛", Uv = "…", Hv = "∓", Vv = "⊧", Wv = "𝕄", Zv = "𝕞", Jv = "∓", Qv = "𝓂", Yv = "ℳ", Xv = "∾", Kv = "Μ", e1 = "μ", n1 = "⊸", t1 = "⊸", o1 = "∇", s1 = "Ń", r1 = "ń", c1 = "∠⃒", a1 = "≉", i1 = "⩰̸", l1 = "≋̸", u1 = "ŉ", p1 = "≉", h1 = "♮", d1 = "ℕ", f1 = "♮", m1 = " ", g1 = "≎̸", _1 = "≏̸", b1 = "⩃", k1 = "Ň", w1 = "ň", y1 = "Ņ", v1 = "ņ", x1 = "≇", A1 = "⩭̸", S1 = "⩂", L1 = "Н", E1 = "н", C1 = "–", T1 = "⤤", D1 = "↗", q1 = "⇗", j1 = "↗", R1 = "≠", N1 = "≐̸", P1 = "​", I1 = "​", O1 = "​", F1 = "​", M1 = "≢", B1 = "⤨", z1 = "≂̸", $1 = "≫", G1 = "≪", U1 = `
`, H1 = "∄", V1 = "∄", W1 = "𝔑", Z1 = "𝔫", J1 = "≧̸", Q1 = "≱", Y1 = "≱", X1 = "≧̸", K1 = "⩾̸", ex = "⩾̸", nx = "⋙̸", tx = "≵", ox = "≫⃒", sx = "≯", rx = "≯", cx = "≫̸", ax = "↮", ix = "⇎", lx = "⫲", ux = "∋", px = "⋼", hx = "⋺", dx = "∋", fx = "Њ", mx = "њ", gx = "↚", _x = "⇍", bx = "‥", kx = "≦̸", wx = "≰", yx = "↚", vx = "⇍", xx = "↮", Ax = "⇎", Sx = "≰", Lx = "≦̸", Ex = "⩽̸", Cx = "⩽̸", Tx = "≮", Dx = "⋘̸", qx = "≴", jx = "≪⃒", Rx = "≮", Nx = "⋪", Px = "⋬", Ix = "≪̸", Ox = "∤", Fx = "⁠", Mx = " ", Bx = "𝕟", zx = "ℕ", $x = "⫬", Gx = "¬", Ux = "≢", Hx = "≭", Vx = "∦", Wx = "∉", Zx = "≠", Jx = "≂̸", Qx = "∄", Yx = "≯", Xx = "≱", Kx = "≧̸", eA = "≫̸", nA = "≹", tA = "⩾̸", oA = "≵", sA = "≎̸", rA = "≏̸", cA = "∉", aA = "⋵̸", iA = "⋹̸", lA = "∉", uA = "⋷", pA = "⋶", hA = "⧏̸", dA = "⋪", fA = "⋬", mA = "≮", gA = "≰", _A = "≸", bA = "≪̸", kA = "⩽̸", wA = "≴", yA = "⪢̸", vA = "⪡̸", xA = "∌", AA = "∌", SA = "⋾", LA = "⋽", EA = "⊀", CA = "⪯̸", TA = "⋠", DA = "∌", qA = "⧐̸", jA = "⋫", RA = "⋭", NA = "⊏̸", PA = "⋢", IA = "⊐̸", OA = "⋣", FA = "⊂⃒", MA = "⊈", BA = "⊁", zA = "⪰̸", $A = "⋡", GA = "≿̸", UA = "⊃⃒", HA = "⊉", VA = "≁", WA = "≄", ZA = "≇", JA = "≉", QA = "∤", YA = "∦", XA = "∦", KA = "⫽⃥", eS = "∂̸", nS = "⨔", tS = "⊀", oS = "⋠", sS = "⊀", rS = "⪯̸", cS = "⪯̸", aS = "⤳̸", iS = "↛", lS = "⇏", uS = "↝̸", pS = "↛", hS = "⇏", dS = "⋫", fS = "⋭", mS = "⊁", gS = "⋡", _S = "⪰̸", bS = "𝒩", kS = "𝓃", wS = "∤", yS = "∦", vS = "≁", xS = "≄", AS = "≄", SS = "∤", LS = "∦", ES = "⋢", CS = "⋣", TS = "⊄", DS = "⫅̸", qS = "⊈", jS = "⊂⃒", RS = "⊈", NS = "⫅̸", PS = "⊁", IS = "⪰̸", OS = "⊅", FS = "⫆̸", MS = "⊉", BS = "⊃⃒", zS = "⊉", $S = "⫆̸", GS = "≹", US = "Ñ", HS = "ñ", VS = "≸", WS = "⋪", ZS = "⋬", JS = "⋫", QS = "⋭", YS = "Ν", XS = "ν", KS = "#", eL = "№", nL = " ", tL = "≍⃒", oL = "⊬", sL = "⊭", rL = "⊮", cL = "⊯", aL = "≥⃒", iL = ">⃒", lL = "⤄", uL = "⧞", pL = "⤂", hL = "≤⃒", dL = "<⃒", fL = "⊴⃒", mL = "⤃", gL = "⊵⃒", _L = "∼⃒", bL = "⤣", kL = "↖", wL = "⇖", yL = "↖", vL = "⤧", xL = "Ó", AL = "ó", SL = "⊛", LL = "Ô", EL = "ô", CL = "⊚", TL = "О", DL = "о", qL = "⊝", jL = "Ő", RL = "ő", NL = "⨸", PL = "⊙", IL = "⦼", OL = "Œ", FL = "œ", ML = "⦿", BL = "𝔒", zL = "𝔬", $L = "˛", GL = "Ò", UL = "ò", HL = "⧁", VL = "⦵", WL = "Ω", ZL = "∮", JL = "↺", QL = "⦾", YL = "⦻", XL = "‾", KL = "⧀", eE = "Ō", nE = "ō", tE = "Ω", oE = "ω", sE = "Ο", rE = "ο", cE = "⦶", aE = "⊖", iE = "𝕆", lE = "𝕠", uE = "⦷", pE = "“", hE = "‘", dE = "⦹", fE = "⊕", mE = "↻", gE = "⩔", _E = "∨", bE = "⩝", kE = "ℴ", wE = "ℴ", yE = "ª", vE = "º", xE = "⊶", AE = "⩖", SE = "⩗", LE = "⩛", EE = "Ⓢ", CE = "𝒪", TE = "ℴ", DE = "Ø", qE = "ø", jE = "⊘", RE = "Õ", NE = "õ", PE = "⨶", IE = "⨷", OE = "⊗", FE = "Ö", ME = "ö", BE = "⌽", zE = "‾", $E = "⏞", GE = "⎴", UE = "⏜", HE = "¶", VE = "∥", WE = "∥", ZE = "⫳", JE = "⫽", QE = "∂", YE = "∂", XE = "П", KE = "п", eC = "%", nC = ".", tC = "‰", oC = "⊥", sC = "‱", rC = "𝔓", cC = "𝔭", aC = "Φ", iC = "φ", lC = "ϕ", uC = "ℳ", pC = "☎", hC = "Π", dC = "π", fC = "⋔", mC = "ϖ", gC = "ℏ", _C = "ℎ", bC = "ℏ", kC = "⨣", wC = "⊞", yC = "⨢", vC = "+", xC = "∔", AC = "⨥", SC = "⩲", LC = "±", EC = "±", CC = "⨦", TC = "⨧", DC = "±", qC = "ℌ", jC = "⨕", RC = "𝕡", NC = "ℙ", PC = "£", IC = "⪷", OC = "⪻", FC = "≺", MC = "≼", BC = "⪷", zC = "≺", $C = "≼", GC = "≺", UC = "⪯", HC = "≼", VC = "≾", WC = "⪯", ZC = "⪹", JC = "⪵", QC = "⋨", YC = "⪯", XC = "⪳", KC = "≾", eT = "′", nT = "″", tT = "ℙ", oT = "⪹", sT = "⪵", rT = "⋨", cT = "∏", aT = "∏", iT = "⌮", lT = "⌒", uT = "⌓", pT = "∝", hT = "∝", dT = "∷", fT = "∝", mT = "≾", gT = "⊰", _T = "𝒫", bT = "𝓅", kT = "Ψ", wT = "ψ", yT = " ", vT = "𝔔", xT = "𝔮", AT = "⨌", ST = "𝕢", LT = "ℚ", ET = "⁗", CT = "𝒬", TT = "𝓆", DT = "ℍ", qT = "⨖", jT = "?", RT = "≟", NT = '"', PT = '"', IT = "⇛", OT = "∽̱", FT = "Ŕ", MT = "ŕ", BT = "√", zT = "⦳", $T = "⟩", GT = "⟫", UT = "⦒", HT = "⦥", VT = "⟩", WT = "»", ZT = "⥵", JT = "⇥", QT = "⤠", YT = "⤳", XT = "→", KT = "↠", eD = "⇒", nD = "⤞", tD = "↪", oD = "↬", sD = "⥅", rD = "⥴", cD = "⤖", aD = "↣", iD = "↝", lD = "⤚", uD = "⤜", pD = "∶", hD = "ℚ", dD = "⤍", fD = "⤏", mD = "⤐", gD = "❳", _D = "}", bD = "]", kD = "⦌", wD = "⦎", yD = "⦐", vD = "Ř", xD = "ř", AD = "Ŗ", SD = "ŗ", LD = "⌉", ED = "}", CD = "Р", TD = "р", DD = "⤷", qD = "⥩", jD = "”", RD = "”", ND = "↳", PD = "ℜ", ID = "ℛ", OD = "ℜ", FD = "ℝ", MD = "ℜ", BD = "▭", zD = "®", $D = "®", GD = "∋", UD = "⇋", HD = "⥯", VD = "⥽", WD = "⌋", ZD = "𝔯", JD = "ℜ", QD = "⥤", YD = "⇁", XD = "⇀", KD = "⥬", eq = "Ρ", nq = "ρ", tq = "ϱ", oq = "⟩", sq = "⇥", rq = "→", cq = "→", aq = "⇒", iq = "⇄", lq = "↣", uq = "⌉", pq = "⟧", hq = "⥝", dq = "⥕", fq = "⇂", mq = "⌋", gq = "⇁", _q = "⇀", bq = "⇄", kq = "⇌", wq = "⇉", yq = "↝", vq = "↦", xq = "⊢", Aq = "⥛", Sq = "⋌", Lq = "⧐", Eq = "⊳", Cq = "⊵", Tq = "⥏", Dq = "⥜", qq = "⥔", jq = "↾", Rq = "⥓", Nq = "⇀", Pq = "˚", Iq = "≓", Oq = "⇄", Fq = "⇌", Mq = "‏", Bq = "⎱", zq = "⎱", $q = "⫮", Gq = "⟭", Uq = "⇾", Hq = "⟧", Vq = "⦆", Wq = "𝕣", Zq = "ℝ", Jq = "⨮", Qq = "⨵", Yq = "⥰", Xq = ")", Kq = "⦔", ej = "⨒", nj = "⇉", tj = "⇛", oj = "›", sj = "𝓇", rj = "ℛ", cj = "↱", aj = "↱", ij = "]", lj = "’", uj = "’", pj = "⋌", hj = "⋊", dj = "▹", fj = "⊵", mj = "▸", gj = "⧎", _j = "⧴", bj = "⥨", kj = "℞", wj = "Ś", yj = "ś", vj = "‚", xj = "⪸", Aj = "Š", Sj = "š", Lj = "⪼", Ej = "≻", Cj = "≽", Tj = "⪰", Dj = "⪴", qj = "Ş", jj = "ş", Rj = "Ŝ", Nj = "ŝ", Pj = "⪺", Ij = "⪶", Oj = "⋩", Fj = "⨓", Mj = "≿", Bj = "С", zj = "с", $j = "⊡", Gj = "⋅", Uj = "⩦", Hj = "⤥", Vj = "↘", Wj = "⇘", Zj = "↘", Jj = "§", Qj = ";", Yj = "⤩", Xj = "∖", Kj = "∖", e2 = "✶", n2 = "𝔖", t2 = "𝔰", o2 = "⌢", s2 = "♯", r2 = "Щ", c2 = "щ", a2 = "Ш", i2 = "ш", l2 = "↓", u2 = "←", p2 = "∣", h2 = "∥", d2 = "→", f2 = "↑", m2 = "­", g2 = "Σ", _2 = "σ", b2 = "ς", k2 = "ς", w2 = "∼", y2 = "⩪", v2 = "≃", x2 = "≃", A2 = "⪞", S2 = "⪠", L2 = "⪝", E2 = "⪟", C2 = "≆", T2 = "⨤", D2 = "⥲", q2 = "←", j2 = "∘", R2 = "∖", N2 = "⨳", P2 = "⧤", I2 = "∣", O2 = "⌣", F2 = "⪪", M2 = "⪬", B2 = "⪬︀", z2 = "Ь", $2 = "ь", G2 = "⌿", U2 = "⧄", H2 = "/", V2 = "𝕊", W2 = "𝕤", Z2 = "♠", J2 = "♠", Q2 = "∥", Y2 = "⊓", X2 = "⊓︀", K2 = "⊔", eR = "⊔︀", nR = "√", tR = "⊏", oR = "⊑", sR = "⊏", rR = "⊑", cR = "⊐", aR = "⊒", iR = "⊐", lR = "⊒", uR = "□", pR = "□", hR = "⊓", dR = "⊏", fR = "⊑", mR = "⊐", gR = "⊒", _R = "⊔", bR = "▪", kR = "□", wR = "▪", yR = "→", vR = "𝒮", xR = "𝓈", AR = "∖", SR = "⌣", LR = "⋆", ER = "⋆", CR = "☆", TR = "★", DR = "ϵ", qR = "ϕ", jR = "¯", RR = "⊂", NR = "⋐", PR = "⪽", IR = "⫅", OR = "⊆", FR = "⫃", MR = "⫁", BR = "⫋", zR = "⊊", $R = "⪿", GR = "⥹", UR = "⊂", HR = "⋐", VR = "⊆", WR = "⫅", ZR = "⊆", JR = "⊊", QR = "⫋", YR = "⫇", XR = "⫕", KR = "⫓", eN = "⪸", nN = "≻", tN = "≽", oN = "≻", sN = "⪰", rN = "≽", cN = "≿", aN = "⪰", iN = "⪺", lN = "⪶", uN = "⋩", pN = "≿", hN = "∋", dN = "∑", fN = "∑", mN = "♪", gN = "¹", _N = "²", bN = "³", kN = "⊃", wN = "⋑", yN = "⪾", vN = "⫘", xN = "⫆", AN = "⊇", SN = "⫄", LN = "⊃", EN = "⊇", CN = "⟉", TN = "⫗", DN = "⥻", qN = "⫂", jN = "⫌", RN = "⊋", NN = "⫀", PN = "⊃", IN = "⋑", ON = "⊇", FN = "⫆", MN = "⊋", BN = "⫌", zN = "⫈", $N = "⫔", GN = "⫖", UN = "⤦", HN = "↙", VN = "⇙", WN = "↙", ZN = "⤪", JN = "ß", QN = "	", YN = "⌖", XN = "Τ", KN = "τ", eP = "⎴", nP = "Ť", tP = "ť", oP = "Ţ", sP = "ţ", rP = "Т", cP = "т", aP = "⃛", iP = "⌕", lP = "𝔗", uP = "𝔱", pP = "∴", hP = "∴", dP = "∴", fP = "Θ", mP = "θ", gP = "ϑ", _P = "ϑ", bP = "≈", kP = "∼", wP = "  ", yP = " ", vP = " ", xP = "≈", AP = "∼", SP = "Þ", LP = "þ", EP = "˜", CP = "∼", TP = "≃", DP = "≅", qP = "≈", jP = "⨱", RP = "⊠", NP = "×", PP = "⨰", IP = "∭", OP = "⤨", FP = "⌶", MP = "⫱", BP = "⊤", zP = "𝕋", $P = "𝕥", GP = "⫚", UP = "⤩", HP = "‴", VP = "™", WP = "™", ZP = "▵", JP = "▿", QP = "◃", YP = "⊴", XP = "≜", KP = "▹", eI = "⊵", nI = "◬", tI = "≜", oI = "⨺", sI = "⃛", rI = "⨹", cI = "⧍", aI = "⨻", iI = "⏢", lI = "𝒯", uI = "𝓉", pI = "Ц", hI = "ц", dI = "Ћ", fI = "ћ", mI = "Ŧ", gI = "ŧ", _I = "≬", bI = "↞", kI = "↠", wI = "Ú", yI = "ú", vI = "↑", xI = "↟", AI = "⇑", SI = "⥉", LI = "Ў", EI = "ў", CI = "Ŭ", TI = "ŭ", DI = "Û", qI = "û", jI = "У", RI = "у", NI = "⇅", PI = "Ű", II = "ű", OI = "⥮", FI = "⥾", MI = "𝔘", BI = "𝔲", zI = "Ù", $I = "ù", GI = "⥣", UI = "↿", HI = "↾", VI = "▀", WI = "⌜", ZI = "⌜", JI = "⌏", QI = "◸", YI = "Ū", XI = "ū", KI = "¨", eO = "_", nO = "⏟", tO = "⎵", oO = "⏝", sO = "⋃", rO = "⊎", cO = "Ų", aO = "ų", iO = "𝕌", lO = "𝕦", uO = "⤒", pO = "↑", hO = "↑", dO = "⇑", fO = "⇅", mO = "↕", gO = "↕", _O = "⇕", bO = "⥮", kO = "↿", wO = "↾", yO = "⊎", vO = "↖", xO = "↗", AO = "υ", SO = "ϒ", LO = "ϒ", EO = "Υ", CO = "υ", TO = "↥", DO = "⊥", qO = "⇈", jO = "⌝", RO = "⌝", NO = "⌎", PO = "Ů", IO = "ů", OO = "◹", FO = "𝒰", MO = "𝓊", BO = "⋰", zO = "Ũ", $O = "ũ", GO = "▵", UO = "▴", HO = "⇈", VO = "Ü", WO = "ü", ZO = "⦧", JO = "⦜", QO = "ϵ", YO = "ϰ", XO = "∅", KO = "ϕ", eF = "ϖ", nF = "∝", tF = "↕", oF = "⇕", sF = "ϱ", rF = "ς", cF = "⊊︀", aF = "⫋︀", iF = "⊋︀", lF = "⫌︀", uF = "ϑ", pF = "⊲", hF = "⊳", dF = "⫨", fF = "⫫", mF = "⫩", gF = "В", _F = "в", bF = "⊢", kF = "⊨", wF = "⊩", yF = "⊫", vF = "⫦", xF = "⊻", AF = "∨", SF = "⋁", LF = "≚", EF = "⋮", CF = "|", TF = "‖", DF = "|", qF = "‖", jF = "∣", RF = "|", NF = "❘", PF = "≀", IF = " ", OF = "𝔙", FF = "𝔳", MF = "⊲", BF = "⊂⃒", zF = "⊃⃒", $F = "𝕍", GF = "𝕧", UF = "∝", HF = "⊳", VF = "𝒱", WF = "𝓋", ZF = "⫋︀", JF = "⊊︀", QF = "⫌︀", YF = "⊋︀", XF = "⊪", KF = "⦚", e3 = "Ŵ", n3 = "ŵ", t3 = "⩟", o3 = "∧", s3 = "⋀", r3 = "≙", c3 = "℘", a3 = "𝔚", i3 = "𝔴", l3 = "𝕎", u3 = "𝕨", p3 = "℘", h3 = "≀", d3 = "≀", f3 = "𝒲", m3 = "𝓌", g3 = "⋂", _3 = "◯", b3 = "⋃", k3 = "▽", w3 = "𝔛", y3 = "𝔵", v3 = "⟷", x3 = "⟺", A3 = "Ξ", S3 = "ξ", L3 = "⟵", E3 = "⟸", C3 = "⟼", T3 = "⋻", D3 = "⨀", q3 = "𝕏", j3 = "𝕩", R3 = "⨁", N3 = "⨂", P3 = "⟶", I3 = "⟹", O3 = "𝒳", F3 = "𝓍", M3 = "⨆", B3 = "⨄", z3 = "△", $3 = "⋁", G3 = "⋀", U3 = "Ý", H3 = "ý", V3 = "Я", W3 = "я", Z3 = "Ŷ", J3 = "ŷ", Q3 = "Ы", Y3 = "ы", X3 = "¥", K3 = "𝔜", eM = "𝔶", nM = "Ї", tM = "ї", oM = "𝕐", sM = "𝕪", rM = "𝒴", cM = "𝓎", aM = "Ю", iM = "ю", lM = "ÿ", uM = "Ÿ", pM = "Ź", hM = "ź", dM = "Ž", fM = "ž", mM = "З", gM = "з", _M = "Ż", bM = "ż", kM = "ℨ", wM = "​", yM = "Ζ", vM = "ζ", xM = "𝔷", AM = "ℨ", SM = "Ж", LM = "ж", EM = "⇝", CM = "𝕫", TM = "ℤ", DM = "𝒵", qM = "𝓏", jM = "‍", RM = "‌", NM = {
  Aacute: gs,
  aacute: _s,
  Abreve: bs,
  abreve: ks,
  ac: ws,
  acd: ys,
  acE: vs,
  Acirc: xs,
  acirc: As,
  acute: Ss,
  Acy: Ls,
  acy: Es,
  AElig: Cs,
  aelig: Ts,
  af: Ds,
  Afr: qs,
  afr: js,
  Agrave: Rs,
  agrave: Ns,
  alefsym: Ps,
  aleph: Is,
  Alpha: Os,
  alpha: Fs,
  Amacr: Ms,
  amacr: Bs,
  amalg: zs,
  amp: $s,
  AMP: Gs,
  andand: Us,
  And: Hs,
  and: Vs,
  andd: Ws,
  andslope: Zs,
  andv: Js,
  ang: Qs,
  ange: Ys,
  angle: Xs,
  angmsdaa: Ks,
  angmsdab: er,
  angmsdac: nr,
  angmsdad: tr,
  angmsdae: or,
  angmsdaf: sr,
  angmsdag: rr,
  angmsdah: cr,
  angmsd: ar,
  angrt: ir,
  angrtvb: lr,
  angrtvbd: ur,
  angsph: pr,
  angst: hr,
  angzarr: dr,
  Aogon: fr,
  aogon: mr,
  Aopf: gr,
  aopf: _r,
  apacir: br,
  ap: kr,
  apE: wr,
  ape: yr,
  apid: vr,
  apos: xr,
  ApplyFunction: Ar,
  approx: Sr,
  approxeq: Lr,
  Aring: Er,
  aring: Cr,
  Ascr: Tr,
  ascr: Dr,
  Assign: qr,
  ast: jr,
  asymp: Rr,
  asympeq: Nr,
  Atilde: Pr,
  atilde: Ir,
  Auml: Or,
  auml: Fr,
  awconint: Mr,
  awint: Br,
  backcong: zr,
  backepsilon: $r,
  backprime: Gr,
  backsim: Ur,
  backsimeq: Hr,
  Backslash: Vr,
  Barv: Wr,
  barvee: Zr,
  barwed: Jr,
  Barwed: Qr,
  barwedge: Yr,
  bbrk: Xr,
  bbrktbrk: Kr,
  bcong: ec,
  Bcy: nc,
  bcy: tc,
  bdquo: oc,
  becaus: sc,
  because: rc,
  Because: cc,
  bemptyv: ac,
  bepsi: ic,
  bernou: lc,
  Bernoullis: uc,
  Beta: pc,
  beta: hc,
  beth: dc,
  between: fc,
  Bfr: mc,
  bfr: gc,
  bigcap: _c,
  bigcirc: bc,
  bigcup: kc,
  bigodot: wc,
  bigoplus: yc,
  bigotimes: vc,
  bigsqcup: xc,
  bigstar: Ac,
  bigtriangledown: Sc,
  bigtriangleup: Lc,
  biguplus: Ec,
  bigvee: Cc,
  bigwedge: Tc,
  bkarow: Dc,
  blacklozenge: qc,
  blacksquare: jc,
  blacktriangle: Rc,
  blacktriangledown: Nc,
  blacktriangleleft: Pc,
  blacktriangleright: Ic,
  blank: Oc,
  blk12: Fc,
  blk14: Mc,
  blk34: Bc,
  block: zc,
  bne: $c,
  bnequiv: Gc,
  bNot: Uc,
  bnot: Hc,
  Bopf: Vc,
  bopf: Wc,
  bot: Zc,
  bottom: Jc,
  bowtie: Qc,
  boxbox: Yc,
  boxdl: Xc,
  boxdL: Kc,
  boxDl: ea,
  boxDL: na,
  boxdr: ta,
  boxdR: oa,
  boxDr: sa,
  boxDR: ra,
  boxh: ca,
  boxH: aa,
  boxhd: ia,
  boxHd: la,
  boxhD: ua,
  boxHD: pa,
  boxhu: ha,
  boxHu: da,
  boxhU: fa,
  boxHU: ma,
  boxminus: ga,
  boxplus: _a,
  boxtimes: ba,
  boxul: ka,
  boxuL: wa,
  boxUl: ya,
  boxUL: va,
  boxur: xa,
  boxuR: Aa,
  boxUr: Sa,
  boxUR: La,
  boxv: Ea,
  boxV: Ca,
  boxvh: Ta,
  boxvH: Da,
  boxVh: qa,
  boxVH: ja,
  boxvl: Ra,
  boxvL: Na,
  boxVl: Pa,
  boxVL: Ia,
  boxvr: Oa,
  boxvR: Fa,
  boxVr: Ma,
  boxVR: Ba,
  bprime: za,
  breve: $a,
  Breve: Ga,
  brvbar: Ua,
  bscr: Ha,
  Bscr: Va,
  bsemi: Wa,
  bsim: Za,
  bsime: Ja,
  bsolb: Qa,
  bsol: Ya,
  bsolhsub: Xa,
  bull: Ka,
  bullet: ei,
  bump: ni,
  bumpE: ti,
  bumpe: oi,
  Bumpeq: si,
  bumpeq: ri,
  Cacute: ci,
  cacute: ai,
  capand: ii,
  capbrcup: li,
  capcap: ui,
  cap: pi,
  Cap: hi,
  capcup: di,
  capdot: fi,
  CapitalDifferentialD: mi,
  caps: gi,
  caret: _i,
  caron: bi,
  Cayleys: ki,
  ccaps: wi,
  Ccaron: yi,
  ccaron: vi,
  Ccedil: xi,
  ccedil: Ai,
  Ccirc: Si,
  ccirc: Li,
  Cconint: Ei,
  ccups: Ci,
  ccupssm: Ti,
  Cdot: Di,
  cdot: qi,
  cedil: ji,
  Cedilla: Ri,
  cemptyv: Ni,
  cent: Pi,
  centerdot: Ii,
  CenterDot: Oi,
  cfr: Fi,
  Cfr: Mi,
  CHcy: Bi,
  chcy: zi,
  check: $i,
  checkmark: Gi,
  Chi: Ui,
  chi: Hi,
  circ: Vi,
  circeq: Wi,
  circlearrowleft: Zi,
  circlearrowright: Ji,
  circledast: Qi,
  circledcirc: Yi,
  circleddash: Xi,
  CircleDot: Ki,
  circledR: el,
  circledS: nl,
  CircleMinus: tl,
  CirclePlus: ol,
  CircleTimes: sl,
  cir: rl,
  cirE: cl,
  cire: al,
  cirfnint: il,
  cirmid: ll,
  cirscir: ul,
  ClockwiseContourIntegral: pl,
  CloseCurlyDoubleQuote: hl,
  CloseCurlyQuote: dl,
  clubs: fl,
  clubsuit: ml,
  colon: gl,
  Colon: _l,
  Colone: bl,
  colone: kl,
  coloneq: wl,
  comma: yl,
  commat: vl,
  comp: xl,
  compfn: Al,
  complement: Sl,
  complexes: Ll,
  cong: El,
  congdot: Cl,
  Congruent: Tl,
  conint: Dl,
  Conint: ql,
  ContourIntegral: jl,
  copf: Rl,
  Copf: Nl,
  coprod: Pl,
  Coproduct: Il,
  copy: Ol,
  COPY: Fl,
  copysr: Ml,
  CounterClockwiseContourIntegral: Bl,
  crarr: zl,
  cross: $l,
  Cross: Gl,
  Cscr: Ul,
  cscr: Hl,
  csub: Vl,
  csube: Wl,
  csup: Zl,
  csupe: Jl,
  ctdot: Ql,
  cudarrl: Yl,
  cudarrr: Xl,
  cuepr: Kl,
  cuesc: eu,
  cularr: nu,
  cularrp: tu,
  cupbrcap: ou,
  cupcap: su,
  CupCap: ru,
  cup: cu,
  Cup: au,
  cupcup: iu,
  cupdot: lu,
  cupor: uu,
  cups: pu,
  curarr: hu,
  curarrm: du,
  curlyeqprec: fu,
  curlyeqsucc: mu,
  curlyvee: gu,
  curlywedge: _u,
  curren: bu,
  curvearrowleft: ku,
  curvearrowright: wu,
  cuvee: yu,
  cuwed: vu,
  cwconint: xu,
  cwint: Au,
  cylcty: Su,
  dagger: Lu,
  Dagger: Eu,
  daleth: Cu,
  darr: Tu,
  Darr: Du,
  dArr: qu,
  dash: ju,
  Dashv: Ru,
  dashv: Nu,
  dbkarow: Pu,
  dblac: Iu,
  Dcaron: Ou,
  dcaron: Fu,
  Dcy: Mu,
  dcy: Bu,
  ddagger: zu,
  ddarr: $u,
  DD: Gu,
  dd: Uu,
  DDotrahd: Hu,
  ddotseq: Vu,
  deg: Wu,
  Del: Zu,
  Delta: Ju,
  delta: Qu,
  demptyv: Yu,
  dfisht: Xu,
  Dfr: Ku,
  dfr: ep,
  dHar: np,
  dharl: tp,
  dharr: op,
  DiacriticalAcute: sp,
  DiacriticalDot: rp,
  DiacriticalDoubleAcute: cp,
  DiacriticalGrave: ap,
  DiacriticalTilde: ip,
  diam: lp,
  diamond: up,
  Diamond: pp,
  diamondsuit: hp,
  diams: dp,
  die: fp,
  DifferentialD: mp,
  digamma: gp,
  disin: _p,
  div: bp,
  divide: kp,
  divideontimes: wp,
  divonx: yp,
  DJcy: vp,
  djcy: xp,
  dlcorn: Ap,
  dlcrop: Sp,
  dollar: Lp,
  Dopf: Ep,
  dopf: Cp,
  Dot: Tp,
  dot: Dp,
  DotDot: qp,
  doteq: jp,
  doteqdot: Rp,
  DotEqual: Np,
  dotminus: Pp,
  dotplus: Ip,
  dotsquare: Op,
  doublebarwedge: Fp,
  DoubleContourIntegral: Mp,
  DoubleDot: Bp,
  DoubleDownArrow: zp,
  DoubleLeftArrow: $p,
  DoubleLeftRightArrow: Gp,
  DoubleLeftTee: Up,
  DoubleLongLeftArrow: Hp,
  DoubleLongLeftRightArrow: Vp,
  DoubleLongRightArrow: Wp,
  DoubleRightArrow: Zp,
  DoubleRightTee: Jp,
  DoubleUpArrow: Qp,
  DoubleUpDownArrow: Yp,
  DoubleVerticalBar: Xp,
  DownArrowBar: Kp,
  downarrow: eh,
  DownArrow: nh,
  Downarrow: th,
  DownArrowUpArrow: oh,
  DownBreve: sh,
  downdownarrows: rh,
  downharpoonleft: ch,
  downharpoonright: ah,
  DownLeftRightVector: ih,
  DownLeftTeeVector: lh,
  DownLeftVectorBar: uh,
  DownLeftVector: ph,
  DownRightTeeVector: hh,
  DownRightVectorBar: dh,
  DownRightVector: fh,
  DownTeeArrow: mh,
  DownTee: gh,
  drbkarow: _h,
  drcorn: bh,
  drcrop: kh,
  Dscr: wh,
  dscr: yh,
  DScy: vh,
  dscy: xh,
  dsol: Ah,
  Dstrok: Sh,
  dstrok: Lh,
  dtdot: Eh,
  dtri: Ch,
  dtrif: Th,
  duarr: Dh,
  duhar: qh,
  dwangle: jh,
  DZcy: Rh,
  dzcy: Nh,
  dzigrarr: Ph,
  Eacute: Ih,
  eacute: Oh,
  easter: Fh,
  Ecaron: Mh,
  ecaron: Bh,
  Ecirc: zh,
  ecirc: $h,
  ecir: Gh,
  ecolon: Uh,
  Ecy: Hh,
  ecy: Vh,
  eDDot: Wh,
  Edot: Zh,
  edot: Jh,
  eDot: Qh,
  ee: Yh,
  efDot: Xh,
  Efr: Kh,
  efr: ed,
  eg: nd,
  Egrave: td,
  egrave: od,
  egs: sd,
  egsdot: rd,
  el: cd,
  Element: ad,
  elinters: id,
  ell: ld,
  els: ud,
  elsdot: pd,
  Emacr: hd,
  emacr: dd,
  empty: fd,
  emptyset: md,
  EmptySmallSquare: gd,
  emptyv: _d,
  EmptyVerySmallSquare: bd,
  emsp13: kd,
  emsp14: wd,
  emsp: yd,
  ENG: vd,
  eng: xd,
  ensp: Ad,
  Eogon: Sd,
  eogon: Ld,
  Eopf: Ed,
  eopf: Cd,
  epar: Td,
  eparsl: Dd,
  eplus: qd,
  epsi: jd,
  Epsilon: Rd,
  epsilon: Nd,
  epsiv: Pd,
  eqcirc: Id,
  eqcolon: Od,
  eqsim: Fd,
  eqslantgtr: Md,
  eqslantless: Bd,
  Equal: zd,
  equals: $d,
  EqualTilde: Gd,
  equest: Ud,
  Equilibrium: Hd,
  equiv: Vd,
  equivDD: Wd,
  eqvparsl: Zd,
  erarr: Jd,
  erDot: Qd,
  escr: Yd,
  Escr: Xd,
  esdot: Kd,
  Esim: ef,
  esim: nf,
  Eta: tf,
  eta: of,
  ETH: sf,
  eth: rf,
  Euml: cf,
  euml: af,
  euro: lf,
  excl: uf,
  exist: pf,
  Exists: hf,
  expectation: df,
  exponentiale: ff,
  ExponentialE: mf,
  fallingdotseq: gf,
  Fcy: _f,
  fcy: bf,
  female: kf,
  ffilig: wf,
  fflig: yf,
  ffllig: vf,
  Ffr: xf,
  ffr: Af,
  filig: Sf,
  FilledSmallSquare: Lf,
  FilledVerySmallSquare: Ef,
  fjlig: Cf,
  flat: Tf,
  fllig: Df,
  fltns: qf,
  fnof: jf,
  Fopf: Rf,
  fopf: Nf,
  forall: Pf,
  ForAll: If,
  fork: Of,
  forkv: Ff,
  Fouriertrf: Mf,
  fpartint: Bf,
  frac12: zf,
  frac13: $f,
  frac14: Gf,
  frac15: Uf,
  frac16: Hf,
  frac18: Vf,
  frac23: Wf,
  frac25: Zf,
  frac34: Jf,
  frac35: Qf,
  frac38: Yf,
  frac45: Xf,
  frac56: Kf,
  frac58: em,
  frac78: nm,
  frasl: tm,
  frown: om,
  fscr: sm,
  Fscr: rm,
  gacute: cm,
  Gamma: am,
  gamma: im,
  Gammad: lm,
  gammad: um,
  gap: pm,
  Gbreve: hm,
  gbreve: dm,
  Gcedil: fm,
  Gcirc: mm,
  gcirc: gm,
  Gcy: _m,
  gcy: bm,
  Gdot: km,
  gdot: wm,
  ge: ym,
  gE: vm,
  gEl: xm,
  gel: Am,
  geq: Sm,
  geqq: Lm,
  geqslant: Em,
  gescc: Cm,
  ges: Tm,
  gesdot: Dm,
  gesdoto: qm,
  gesdotol: jm,
  gesl: Rm,
  gesles: Nm,
  Gfr: Pm,
  gfr: Im,
  gg: Om,
  Gg: Fm,
  ggg: Mm,
  gimel: Bm,
  GJcy: zm,
  gjcy: $m,
  gla: Gm,
  gl: Um,
  glE: Hm,
  glj: Vm,
  gnap: Wm,
  gnapprox: Zm,
  gne: Jm,
  gnE: Qm,
  gneq: Ym,
  gneqq: Xm,
  gnsim: Km,
  Gopf: eg,
  gopf: ng,
  grave: tg,
  GreaterEqual: og,
  GreaterEqualLess: sg,
  GreaterFullEqual: rg,
  GreaterGreater: cg,
  GreaterLess: ag,
  GreaterSlantEqual: ig,
  GreaterTilde: lg,
  Gscr: ug,
  gscr: pg,
  gsim: hg,
  gsime: dg,
  gsiml: fg,
  gtcc: mg,
  gtcir: gg,
  gt: _g,
  GT: bg,
  Gt: kg,
  gtdot: wg,
  gtlPar: yg,
  gtquest: vg,
  gtrapprox: xg,
  gtrarr: Ag,
  gtrdot: Sg,
  gtreqless: Lg,
  gtreqqless: Eg,
  gtrless: Cg,
  gtrsim: Tg,
  gvertneqq: Dg,
  gvnE: qg,
  Hacek: jg,
  hairsp: Rg,
  half: Ng,
  hamilt: Pg,
  HARDcy: Ig,
  hardcy: Og,
  harrcir: Fg,
  harr: Mg,
  hArr: Bg,
  harrw: zg,
  Hat: $g,
  hbar: Gg,
  Hcirc: Ug,
  hcirc: Hg,
  hearts: Vg,
  heartsuit: Wg,
  hellip: Zg,
  hercon: Jg,
  hfr: Qg,
  Hfr: Yg,
  HilbertSpace: Xg,
  hksearow: Kg,
  hkswarow: e_,
  hoarr: n_,
  homtht: t_,
  hookleftarrow: o_,
  hookrightarrow: s_,
  hopf: r_,
  Hopf: c_,
  horbar: a_,
  HorizontalLine: i_,
  hscr: l_,
  Hscr: u_,
  hslash: p_,
  Hstrok: h_,
  hstrok: d_,
  HumpDownHump: f_,
  HumpEqual: m_,
  hybull: g_,
  hyphen: __,
  Iacute: b_,
  iacute: k_,
  ic: w_,
  Icirc: y_,
  icirc: v_,
  Icy: x_,
  icy: A_,
  Idot: S_,
  IEcy: L_,
  iecy: E_,
  iexcl: C_,
  iff: T_,
  ifr: D_,
  Ifr: q_,
  Igrave: j_,
  igrave: R_,
  ii: N_,
  iiiint: P_,
  iiint: I_,
  iinfin: O_,
  iiota: F_,
  IJlig: M_,
  ijlig: B_,
  Imacr: z_,
  imacr: $_,
  image: G_,
  ImaginaryI: U_,
  imagline: H_,
  imagpart: V_,
  imath: W_,
  Im: Z_,
  imof: J_,
  imped: Q_,
  Implies: Y_,
  incare: X_,
  in: "∈",
  infin: K_,
  infintie: eb,
  inodot: nb,
  intcal: tb,
  int: ob,
  Int: sb,
  integers: rb,
  Integral: cb,
  intercal: ab,
  Intersection: ib,
  intlarhk: lb,
  intprod: ub,
  InvisibleComma: pb,
  InvisibleTimes: hb,
  IOcy: db,
  iocy: fb,
  Iogon: mb,
  iogon: gb,
  Iopf: _b,
  iopf: bb,
  Iota: kb,
  iota: wb,
  iprod: yb,
  iquest: vb,
  iscr: xb,
  Iscr: Ab,
  isin: Sb,
  isindot: Lb,
  isinE: Eb,
  isins: Cb,
  isinsv: Tb,
  isinv: Db,
  it: qb,
  Itilde: jb,
  itilde: Rb,
  Iukcy: Nb,
  iukcy: Pb,
  Iuml: Ib,
  iuml: Ob,
  Jcirc: Fb,
  jcirc: Mb,
  Jcy: Bb,
  jcy: zb,
  Jfr: $b,
  jfr: Gb,
  jmath: Ub,
  Jopf: Hb,
  jopf: Vb,
  Jscr: Wb,
  jscr: Zb,
  Jsercy: Jb,
  jsercy: Qb,
  Jukcy: Yb,
  jukcy: Xb,
  Kappa: Kb,
  kappa: ek,
  kappav: nk,
  Kcedil: tk,
  kcedil: ok,
  Kcy: sk,
  kcy: rk,
  Kfr: ck,
  kfr: ak,
  kgreen: ik,
  KHcy: lk,
  khcy: uk,
  KJcy: pk,
  kjcy: hk,
  Kopf: dk,
  kopf: fk,
  Kscr: mk,
  kscr: gk,
  lAarr: _k,
  Lacute: bk,
  lacute: kk,
  laemptyv: wk,
  lagran: yk,
  Lambda: vk,
  lambda: xk,
  lang: Ak,
  Lang: Sk,
  langd: Lk,
  langle: Ek,
  lap: Ck,
  Laplacetrf: Tk,
  laquo: Dk,
  larrb: qk,
  larrbfs: jk,
  larr: Rk,
  Larr: Nk,
  lArr: Pk,
  larrfs: Ik,
  larrhk: Ok,
  larrlp: Fk,
  larrpl: Mk,
  larrsim: Bk,
  larrtl: zk,
  latail: $k,
  lAtail: Gk,
  lat: Uk,
  late: Hk,
  lates: Vk,
  lbarr: Wk,
  lBarr: Zk,
  lbbrk: Jk,
  lbrace: Qk,
  lbrack: Yk,
  lbrke: Xk,
  lbrksld: Kk,
  lbrkslu: ew,
  Lcaron: nw,
  lcaron: tw,
  Lcedil: ow,
  lcedil: sw,
  lceil: rw,
  lcub: cw,
  Lcy: aw,
  lcy: iw,
  ldca: lw,
  ldquo: uw,
  ldquor: pw,
  ldrdhar: hw,
  ldrushar: dw,
  ldsh: fw,
  le: mw,
  lE: gw,
  LeftAngleBracket: _w,
  LeftArrowBar: bw,
  leftarrow: kw,
  LeftArrow: ww,
  Leftarrow: yw,
  LeftArrowRightArrow: vw,
  leftarrowtail: xw,
  LeftCeiling: Aw,
  LeftDoubleBracket: Sw,
  LeftDownTeeVector: Lw,
  LeftDownVectorBar: Ew,
  LeftDownVector: Cw,
  LeftFloor: Tw,
  leftharpoondown: Dw,
  leftharpoonup: qw,
  leftleftarrows: jw,
  leftrightarrow: Rw,
  LeftRightArrow: Nw,
  Leftrightarrow: Pw,
  leftrightarrows: Iw,
  leftrightharpoons: Ow,
  leftrightsquigarrow: Fw,
  LeftRightVector: Mw,
  LeftTeeArrow: Bw,
  LeftTee: zw,
  LeftTeeVector: $w,
  leftthreetimes: Gw,
  LeftTriangleBar: Uw,
  LeftTriangle: Hw,
  LeftTriangleEqual: Vw,
  LeftUpDownVector: Ww,
  LeftUpTeeVector: Zw,
  LeftUpVectorBar: Jw,
  LeftUpVector: Qw,
  LeftVectorBar: Yw,
  LeftVector: Xw,
  lEg: Kw,
  leg: ey,
  leq: ny,
  leqq: ty,
  leqslant: oy,
  lescc: sy,
  les: ry,
  lesdot: cy,
  lesdoto: ay,
  lesdotor: iy,
  lesg: ly,
  lesges: uy,
  lessapprox: py,
  lessdot: hy,
  lesseqgtr: dy,
  lesseqqgtr: fy,
  LessEqualGreater: my,
  LessFullEqual: gy,
  LessGreater: _y,
  lessgtr: by,
  LessLess: ky,
  lesssim: wy,
  LessSlantEqual: yy,
  LessTilde: vy,
  lfisht: xy,
  lfloor: Ay,
  Lfr: Sy,
  lfr: Ly,
  lg: Ey,
  lgE: Cy,
  lHar: Ty,
  lhard: Dy,
  lharu: qy,
  lharul: jy,
  lhblk: Ry,
  LJcy: Ny,
  ljcy: Py,
  llarr: Iy,
  ll: Oy,
  Ll: Fy,
  llcorner: My,
  Lleftarrow: By,
  llhard: zy,
  lltri: $y,
  Lmidot: Gy,
  lmidot: Uy,
  lmoustache: Hy,
  lmoust: Vy,
  lnap: Wy,
  lnapprox: Zy,
  lne: Jy,
  lnE: Qy,
  lneq: Yy,
  lneqq: Xy,
  lnsim: Ky,
  loang: e0,
  loarr: n0,
  lobrk: t0,
  longleftarrow: o0,
  LongLeftArrow: s0,
  Longleftarrow: r0,
  longleftrightarrow: c0,
  LongLeftRightArrow: a0,
  Longleftrightarrow: i0,
  longmapsto: l0,
  longrightarrow: u0,
  LongRightArrow: p0,
  Longrightarrow: h0,
  looparrowleft: d0,
  looparrowright: f0,
  lopar: m0,
  Lopf: g0,
  lopf: _0,
  loplus: b0,
  lotimes: k0,
  lowast: w0,
  lowbar: y0,
  LowerLeftArrow: v0,
  LowerRightArrow: x0,
  loz: A0,
  lozenge: S0,
  lozf: L0,
  lpar: E0,
  lparlt: C0,
  lrarr: T0,
  lrcorner: D0,
  lrhar: q0,
  lrhard: j0,
  lrm: R0,
  lrtri: N0,
  lsaquo: P0,
  lscr: I0,
  Lscr: O0,
  lsh: F0,
  Lsh: M0,
  lsim: B0,
  lsime: z0,
  lsimg: $0,
  lsqb: G0,
  lsquo: U0,
  lsquor: H0,
  Lstrok: V0,
  lstrok: W0,
  ltcc: Z0,
  ltcir: J0,
  lt: Q0,
  LT: Y0,
  Lt: X0,
  ltdot: K0,
  lthree: ev,
  ltimes: nv,
  ltlarr: tv,
  ltquest: ov,
  ltri: sv,
  ltrie: rv,
  ltrif: cv,
  ltrPar: av,
  lurdshar: iv,
  luruhar: lv,
  lvertneqq: uv,
  lvnE: pv,
  macr: hv,
  male: dv,
  malt: fv,
  maltese: mv,
  Map: "⤅",
  map: gv,
  mapsto: _v,
  mapstodown: bv,
  mapstoleft: kv,
  mapstoup: wv,
  marker: yv,
  mcomma: vv,
  Mcy: xv,
  mcy: Av,
  mdash: Sv,
  mDDot: Lv,
  measuredangle: Ev,
  MediumSpace: Cv,
  Mellintrf: Tv,
  Mfr: Dv,
  mfr: qv,
  mho: jv,
  micro: Rv,
  midast: Nv,
  midcir: Pv,
  mid: Iv,
  middot: Ov,
  minusb: Fv,
  minus: Mv,
  minusd: Bv,
  minusdu: zv,
  MinusPlus: $v,
  mlcp: Gv,
  mldr: Uv,
  mnplus: Hv,
  models: Vv,
  Mopf: Wv,
  mopf: Zv,
  mp: Jv,
  mscr: Qv,
  Mscr: Yv,
  mstpos: Xv,
  Mu: Kv,
  mu: e1,
  multimap: n1,
  mumap: t1,
  nabla: o1,
  Nacute: s1,
  nacute: r1,
  nang: c1,
  nap: a1,
  napE: i1,
  napid: l1,
  napos: u1,
  napprox: p1,
  natural: h1,
  naturals: d1,
  natur: f1,
  nbsp: m1,
  nbump: g1,
  nbumpe: _1,
  ncap: b1,
  Ncaron: k1,
  ncaron: w1,
  Ncedil: y1,
  ncedil: v1,
  ncong: x1,
  ncongdot: A1,
  ncup: S1,
  Ncy: L1,
  ncy: E1,
  ndash: C1,
  nearhk: T1,
  nearr: D1,
  neArr: q1,
  nearrow: j1,
  ne: R1,
  nedot: N1,
  NegativeMediumSpace: P1,
  NegativeThickSpace: I1,
  NegativeThinSpace: O1,
  NegativeVeryThinSpace: F1,
  nequiv: M1,
  nesear: B1,
  nesim: z1,
  NestedGreaterGreater: $1,
  NestedLessLess: G1,
  NewLine: U1,
  nexist: H1,
  nexists: V1,
  Nfr: W1,
  nfr: Z1,
  ngE: J1,
  nge: Q1,
  ngeq: Y1,
  ngeqq: X1,
  ngeqslant: K1,
  nges: ex,
  nGg: nx,
  ngsim: tx,
  nGt: ox,
  ngt: sx,
  ngtr: rx,
  nGtv: cx,
  nharr: ax,
  nhArr: ix,
  nhpar: lx,
  ni: ux,
  nis: px,
  nisd: hx,
  niv: dx,
  NJcy: fx,
  njcy: mx,
  nlarr: gx,
  nlArr: _x,
  nldr: bx,
  nlE: kx,
  nle: wx,
  nleftarrow: yx,
  nLeftarrow: vx,
  nleftrightarrow: xx,
  nLeftrightarrow: Ax,
  nleq: Sx,
  nleqq: Lx,
  nleqslant: Ex,
  nles: Cx,
  nless: Tx,
  nLl: Dx,
  nlsim: qx,
  nLt: jx,
  nlt: Rx,
  nltri: Nx,
  nltrie: Px,
  nLtv: Ix,
  nmid: Ox,
  NoBreak: Fx,
  NonBreakingSpace: Mx,
  nopf: Bx,
  Nopf: zx,
  Not: $x,
  not: Gx,
  NotCongruent: Ux,
  NotCupCap: Hx,
  NotDoubleVerticalBar: Vx,
  NotElement: Wx,
  NotEqual: Zx,
  NotEqualTilde: Jx,
  NotExists: Qx,
  NotGreater: Yx,
  NotGreaterEqual: Xx,
  NotGreaterFullEqual: Kx,
  NotGreaterGreater: eA,
  NotGreaterLess: nA,
  NotGreaterSlantEqual: tA,
  NotGreaterTilde: oA,
  NotHumpDownHump: sA,
  NotHumpEqual: rA,
  notin: cA,
  notindot: aA,
  notinE: iA,
  notinva: lA,
  notinvb: uA,
  notinvc: pA,
  NotLeftTriangleBar: hA,
  NotLeftTriangle: dA,
  NotLeftTriangleEqual: fA,
  NotLess: mA,
  NotLessEqual: gA,
  NotLessGreater: _A,
  NotLessLess: bA,
  NotLessSlantEqual: kA,
  NotLessTilde: wA,
  NotNestedGreaterGreater: yA,
  NotNestedLessLess: vA,
  notni: xA,
  notniva: AA,
  notnivb: SA,
  notnivc: LA,
  NotPrecedes: EA,
  NotPrecedesEqual: CA,
  NotPrecedesSlantEqual: TA,
  NotReverseElement: DA,
  NotRightTriangleBar: qA,
  NotRightTriangle: jA,
  NotRightTriangleEqual: RA,
  NotSquareSubset: NA,
  NotSquareSubsetEqual: PA,
  NotSquareSuperset: IA,
  NotSquareSupersetEqual: OA,
  NotSubset: FA,
  NotSubsetEqual: MA,
  NotSucceeds: BA,
  NotSucceedsEqual: zA,
  NotSucceedsSlantEqual: $A,
  NotSucceedsTilde: GA,
  NotSuperset: UA,
  NotSupersetEqual: HA,
  NotTilde: VA,
  NotTildeEqual: WA,
  NotTildeFullEqual: ZA,
  NotTildeTilde: JA,
  NotVerticalBar: QA,
  nparallel: YA,
  npar: XA,
  nparsl: KA,
  npart: eS,
  npolint: nS,
  npr: tS,
  nprcue: oS,
  nprec: sS,
  npreceq: rS,
  npre: cS,
  nrarrc: aS,
  nrarr: iS,
  nrArr: lS,
  nrarrw: uS,
  nrightarrow: pS,
  nRightarrow: hS,
  nrtri: dS,
  nrtrie: fS,
  nsc: mS,
  nsccue: gS,
  nsce: _S,
  Nscr: bS,
  nscr: kS,
  nshortmid: wS,
  nshortparallel: yS,
  nsim: vS,
  nsime: xS,
  nsimeq: AS,
  nsmid: SS,
  nspar: LS,
  nsqsube: ES,
  nsqsupe: CS,
  nsub: TS,
  nsubE: DS,
  nsube: qS,
  nsubset: jS,
  nsubseteq: RS,
  nsubseteqq: NS,
  nsucc: PS,
  nsucceq: IS,
  nsup: OS,
  nsupE: FS,
  nsupe: MS,
  nsupset: BS,
  nsupseteq: zS,
  nsupseteqq: $S,
  ntgl: GS,
  Ntilde: US,
  ntilde: HS,
  ntlg: VS,
  ntriangleleft: WS,
  ntrianglelefteq: ZS,
  ntriangleright: JS,
  ntrianglerighteq: QS,
  Nu: YS,
  nu: XS,
  num: KS,
  numero: eL,
  numsp: nL,
  nvap: tL,
  nvdash: oL,
  nvDash: sL,
  nVdash: rL,
  nVDash: cL,
  nvge: aL,
  nvgt: iL,
  nvHarr: lL,
  nvinfin: uL,
  nvlArr: pL,
  nvle: hL,
  nvlt: dL,
  nvltrie: fL,
  nvrArr: mL,
  nvrtrie: gL,
  nvsim: _L,
  nwarhk: bL,
  nwarr: kL,
  nwArr: wL,
  nwarrow: yL,
  nwnear: vL,
  Oacute: xL,
  oacute: AL,
  oast: SL,
  Ocirc: LL,
  ocirc: EL,
  ocir: CL,
  Ocy: TL,
  ocy: DL,
  odash: qL,
  Odblac: jL,
  odblac: RL,
  odiv: NL,
  odot: PL,
  odsold: IL,
  OElig: OL,
  oelig: FL,
  ofcir: ML,
  Ofr: BL,
  ofr: zL,
  ogon: $L,
  Ograve: GL,
  ograve: UL,
  ogt: HL,
  ohbar: VL,
  ohm: WL,
  oint: ZL,
  olarr: JL,
  olcir: QL,
  olcross: YL,
  oline: XL,
  olt: KL,
  Omacr: eE,
  omacr: nE,
  Omega: tE,
  omega: oE,
  Omicron: sE,
  omicron: rE,
  omid: cE,
  ominus: aE,
  Oopf: iE,
  oopf: lE,
  opar: uE,
  OpenCurlyDoubleQuote: pE,
  OpenCurlyQuote: hE,
  operp: dE,
  oplus: fE,
  orarr: mE,
  Or: gE,
  or: _E,
  ord: bE,
  order: kE,
  orderof: wE,
  ordf: yE,
  ordm: vE,
  origof: xE,
  oror: AE,
  orslope: SE,
  orv: LE,
  oS: EE,
  Oscr: CE,
  oscr: TE,
  Oslash: DE,
  oslash: qE,
  osol: jE,
  Otilde: RE,
  otilde: NE,
  otimesas: PE,
  Otimes: IE,
  otimes: OE,
  Ouml: FE,
  ouml: ME,
  ovbar: BE,
  OverBar: zE,
  OverBrace: $E,
  OverBracket: GE,
  OverParenthesis: UE,
  para: HE,
  parallel: VE,
  par: WE,
  parsim: ZE,
  parsl: JE,
  part: QE,
  PartialD: YE,
  Pcy: XE,
  pcy: KE,
  percnt: eC,
  period: nC,
  permil: tC,
  perp: oC,
  pertenk: sC,
  Pfr: rC,
  pfr: cC,
  Phi: aC,
  phi: iC,
  phiv: lC,
  phmmat: uC,
  phone: pC,
  Pi: hC,
  pi: dC,
  pitchfork: fC,
  piv: mC,
  planck: gC,
  planckh: _C,
  plankv: bC,
  plusacir: kC,
  plusb: wC,
  pluscir: yC,
  plus: vC,
  plusdo: xC,
  plusdu: AC,
  pluse: SC,
  PlusMinus: LC,
  plusmn: EC,
  plussim: CC,
  plustwo: TC,
  pm: DC,
  Poincareplane: qC,
  pointint: jC,
  popf: RC,
  Popf: NC,
  pound: PC,
  prap: IC,
  Pr: OC,
  pr: FC,
  prcue: MC,
  precapprox: BC,
  prec: zC,
  preccurlyeq: $C,
  Precedes: GC,
  PrecedesEqual: UC,
  PrecedesSlantEqual: HC,
  PrecedesTilde: VC,
  preceq: WC,
  precnapprox: ZC,
  precneqq: JC,
  precnsim: QC,
  pre: YC,
  prE: XC,
  precsim: KC,
  prime: eT,
  Prime: nT,
  primes: tT,
  prnap: oT,
  prnE: sT,
  prnsim: rT,
  prod: cT,
  Product: aT,
  profalar: iT,
  profline: lT,
  profsurf: uT,
  prop: pT,
  Proportional: hT,
  Proportion: dT,
  propto: fT,
  prsim: mT,
  prurel: gT,
  Pscr: _T,
  pscr: bT,
  Psi: kT,
  psi: wT,
  puncsp: yT,
  Qfr: vT,
  qfr: xT,
  qint: AT,
  qopf: ST,
  Qopf: LT,
  qprime: ET,
  Qscr: CT,
  qscr: TT,
  quaternions: DT,
  quatint: qT,
  quest: jT,
  questeq: RT,
  quot: NT,
  QUOT: PT,
  rAarr: IT,
  race: OT,
  Racute: FT,
  racute: MT,
  radic: BT,
  raemptyv: zT,
  rang: $T,
  Rang: GT,
  rangd: UT,
  range: HT,
  rangle: VT,
  raquo: WT,
  rarrap: ZT,
  rarrb: JT,
  rarrbfs: QT,
  rarrc: YT,
  rarr: XT,
  Rarr: KT,
  rArr: eD,
  rarrfs: nD,
  rarrhk: tD,
  rarrlp: oD,
  rarrpl: sD,
  rarrsim: rD,
  Rarrtl: cD,
  rarrtl: aD,
  rarrw: iD,
  ratail: lD,
  rAtail: uD,
  ratio: pD,
  rationals: hD,
  rbarr: dD,
  rBarr: fD,
  RBarr: mD,
  rbbrk: gD,
  rbrace: _D,
  rbrack: bD,
  rbrke: kD,
  rbrksld: wD,
  rbrkslu: yD,
  Rcaron: vD,
  rcaron: xD,
  Rcedil: AD,
  rcedil: SD,
  rceil: LD,
  rcub: ED,
  Rcy: CD,
  rcy: TD,
  rdca: DD,
  rdldhar: qD,
  rdquo: jD,
  rdquor: RD,
  rdsh: ND,
  real: PD,
  realine: ID,
  realpart: OD,
  reals: FD,
  Re: MD,
  rect: BD,
  reg: zD,
  REG: $D,
  ReverseElement: GD,
  ReverseEquilibrium: UD,
  ReverseUpEquilibrium: HD,
  rfisht: VD,
  rfloor: WD,
  rfr: ZD,
  Rfr: JD,
  rHar: QD,
  rhard: YD,
  rharu: XD,
  rharul: KD,
  Rho: eq,
  rho: nq,
  rhov: tq,
  RightAngleBracket: oq,
  RightArrowBar: sq,
  rightarrow: rq,
  RightArrow: cq,
  Rightarrow: aq,
  RightArrowLeftArrow: iq,
  rightarrowtail: lq,
  RightCeiling: uq,
  RightDoubleBracket: pq,
  RightDownTeeVector: hq,
  RightDownVectorBar: dq,
  RightDownVector: fq,
  RightFloor: mq,
  rightharpoondown: gq,
  rightharpoonup: _q,
  rightleftarrows: bq,
  rightleftharpoons: kq,
  rightrightarrows: wq,
  rightsquigarrow: yq,
  RightTeeArrow: vq,
  RightTee: xq,
  RightTeeVector: Aq,
  rightthreetimes: Sq,
  RightTriangleBar: Lq,
  RightTriangle: Eq,
  RightTriangleEqual: Cq,
  RightUpDownVector: Tq,
  RightUpTeeVector: Dq,
  RightUpVectorBar: qq,
  RightUpVector: jq,
  RightVectorBar: Rq,
  RightVector: Nq,
  ring: Pq,
  risingdotseq: Iq,
  rlarr: Oq,
  rlhar: Fq,
  rlm: Mq,
  rmoustache: Bq,
  rmoust: zq,
  rnmid: $q,
  roang: Gq,
  roarr: Uq,
  robrk: Hq,
  ropar: Vq,
  ropf: Wq,
  Ropf: Zq,
  roplus: Jq,
  rotimes: Qq,
  RoundImplies: Yq,
  rpar: Xq,
  rpargt: Kq,
  rppolint: ej,
  rrarr: nj,
  Rrightarrow: tj,
  rsaquo: oj,
  rscr: sj,
  Rscr: rj,
  rsh: cj,
  Rsh: aj,
  rsqb: ij,
  rsquo: lj,
  rsquor: uj,
  rthree: pj,
  rtimes: hj,
  rtri: dj,
  rtrie: fj,
  rtrif: mj,
  rtriltri: gj,
  RuleDelayed: _j,
  ruluhar: bj,
  rx: kj,
  Sacute: wj,
  sacute: yj,
  sbquo: vj,
  scap: xj,
  Scaron: Aj,
  scaron: Sj,
  Sc: Lj,
  sc: Ej,
  sccue: Cj,
  sce: Tj,
  scE: Dj,
  Scedil: qj,
  scedil: jj,
  Scirc: Rj,
  scirc: Nj,
  scnap: Pj,
  scnE: Ij,
  scnsim: Oj,
  scpolint: Fj,
  scsim: Mj,
  Scy: Bj,
  scy: zj,
  sdotb: $j,
  sdot: Gj,
  sdote: Uj,
  searhk: Hj,
  searr: Vj,
  seArr: Wj,
  searrow: Zj,
  sect: Jj,
  semi: Qj,
  seswar: Yj,
  setminus: Xj,
  setmn: Kj,
  sext: e2,
  Sfr: n2,
  sfr: t2,
  sfrown: o2,
  sharp: s2,
  SHCHcy: r2,
  shchcy: c2,
  SHcy: a2,
  shcy: i2,
  ShortDownArrow: l2,
  ShortLeftArrow: u2,
  shortmid: p2,
  shortparallel: h2,
  ShortRightArrow: d2,
  ShortUpArrow: f2,
  shy: m2,
  Sigma: g2,
  sigma: _2,
  sigmaf: b2,
  sigmav: k2,
  sim: w2,
  simdot: y2,
  sime: v2,
  simeq: x2,
  simg: A2,
  simgE: S2,
  siml: L2,
  simlE: E2,
  simne: C2,
  simplus: T2,
  simrarr: D2,
  slarr: q2,
  SmallCircle: j2,
  smallsetminus: R2,
  smashp: N2,
  smeparsl: P2,
  smid: I2,
  smile: O2,
  smt: F2,
  smte: M2,
  smtes: B2,
  SOFTcy: z2,
  softcy: $2,
  solbar: G2,
  solb: U2,
  sol: H2,
  Sopf: V2,
  sopf: W2,
  spades: Z2,
  spadesuit: J2,
  spar: Q2,
  sqcap: Y2,
  sqcaps: X2,
  sqcup: K2,
  sqcups: eR,
  Sqrt: nR,
  sqsub: tR,
  sqsube: oR,
  sqsubset: sR,
  sqsubseteq: rR,
  sqsup: cR,
  sqsupe: aR,
  sqsupset: iR,
  sqsupseteq: lR,
  square: uR,
  Square: pR,
  SquareIntersection: hR,
  SquareSubset: dR,
  SquareSubsetEqual: fR,
  SquareSuperset: mR,
  SquareSupersetEqual: gR,
  SquareUnion: _R,
  squarf: bR,
  squ: kR,
  squf: wR,
  srarr: yR,
  Sscr: vR,
  sscr: xR,
  ssetmn: AR,
  ssmile: SR,
  sstarf: LR,
  Star: ER,
  star: CR,
  starf: TR,
  straightepsilon: DR,
  straightphi: qR,
  strns: jR,
  sub: RR,
  Sub: NR,
  subdot: PR,
  subE: IR,
  sube: OR,
  subedot: FR,
  submult: MR,
  subnE: BR,
  subne: zR,
  subplus: $R,
  subrarr: GR,
  subset: UR,
  Subset: HR,
  subseteq: VR,
  subseteqq: WR,
  SubsetEqual: ZR,
  subsetneq: JR,
  subsetneqq: QR,
  subsim: YR,
  subsub: XR,
  subsup: KR,
  succapprox: eN,
  succ: nN,
  succcurlyeq: tN,
  Succeeds: oN,
  SucceedsEqual: sN,
  SucceedsSlantEqual: rN,
  SucceedsTilde: cN,
  succeq: aN,
  succnapprox: iN,
  succneqq: lN,
  succnsim: uN,
  succsim: pN,
  SuchThat: hN,
  sum: dN,
  Sum: fN,
  sung: mN,
  sup1: gN,
  sup2: _N,
  sup3: bN,
  sup: kN,
  Sup: wN,
  supdot: yN,
  supdsub: vN,
  supE: xN,
  supe: AN,
  supedot: SN,
  Superset: LN,
  SupersetEqual: EN,
  suphsol: CN,
  suphsub: TN,
  suplarr: DN,
  supmult: qN,
  supnE: jN,
  supne: RN,
  supplus: NN,
  supset: PN,
  Supset: IN,
  supseteq: ON,
  supseteqq: FN,
  supsetneq: MN,
  supsetneqq: BN,
  supsim: zN,
  supsub: $N,
  supsup: GN,
  swarhk: UN,
  swarr: HN,
  swArr: VN,
  swarrow: WN,
  swnwar: ZN,
  szlig: JN,
  Tab: QN,
  target: YN,
  Tau: XN,
  tau: KN,
  tbrk: eP,
  Tcaron: nP,
  tcaron: tP,
  Tcedil: oP,
  tcedil: sP,
  Tcy: rP,
  tcy: cP,
  tdot: aP,
  telrec: iP,
  Tfr: lP,
  tfr: uP,
  there4: pP,
  therefore: hP,
  Therefore: dP,
  Theta: fP,
  theta: mP,
  thetasym: gP,
  thetav: _P,
  thickapprox: bP,
  thicksim: kP,
  ThickSpace: wP,
  ThinSpace: yP,
  thinsp: vP,
  thkap: xP,
  thksim: AP,
  THORN: SP,
  thorn: LP,
  tilde: EP,
  Tilde: CP,
  TildeEqual: TP,
  TildeFullEqual: DP,
  TildeTilde: qP,
  timesbar: jP,
  timesb: RP,
  times: NP,
  timesd: PP,
  tint: IP,
  toea: OP,
  topbot: FP,
  topcir: MP,
  top: BP,
  Topf: zP,
  topf: $P,
  topfork: GP,
  tosa: UP,
  tprime: HP,
  trade: VP,
  TRADE: WP,
  triangle: ZP,
  triangledown: JP,
  triangleleft: QP,
  trianglelefteq: YP,
  triangleq: XP,
  triangleright: KP,
  trianglerighteq: eI,
  tridot: nI,
  trie: tI,
  triminus: oI,
  TripleDot: sI,
  triplus: rI,
  trisb: cI,
  tritime: aI,
  trpezium: iI,
  Tscr: lI,
  tscr: uI,
  TScy: pI,
  tscy: hI,
  TSHcy: dI,
  tshcy: fI,
  Tstrok: mI,
  tstrok: gI,
  twixt: _I,
  twoheadleftarrow: bI,
  twoheadrightarrow: kI,
  Uacute: wI,
  uacute: yI,
  uarr: vI,
  Uarr: xI,
  uArr: AI,
  Uarrocir: SI,
  Ubrcy: LI,
  ubrcy: EI,
  Ubreve: CI,
  ubreve: TI,
  Ucirc: DI,
  ucirc: qI,
  Ucy: jI,
  ucy: RI,
  udarr: NI,
  Udblac: PI,
  udblac: II,
  udhar: OI,
  ufisht: FI,
  Ufr: MI,
  ufr: BI,
  Ugrave: zI,
  ugrave: $I,
  uHar: GI,
  uharl: UI,
  uharr: HI,
  uhblk: VI,
  ulcorn: WI,
  ulcorner: ZI,
  ulcrop: JI,
  ultri: QI,
  Umacr: YI,
  umacr: XI,
  uml: KI,
  UnderBar: eO,
  UnderBrace: nO,
  UnderBracket: tO,
  UnderParenthesis: oO,
  Union: sO,
  UnionPlus: rO,
  Uogon: cO,
  uogon: aO,
  Uopf: iO,
  uopf: lO,
  UpArrowBar: uO,
  uparrow: pO,
  UpArrow: hO,
  Uparrow: dO,
  UpArrowDownArrow: fO,
  updownarrow: mO,
  UpDownArrow: gO,
  Updownarrow: _O,
  UpEquilibrium: bO,
  upharpoonleft: kO,
  upharpoonright: wO,
  uplus: yO,
  UpperLeftArrow: vO,
  UpperRightArrow: xO,
  upsi: AO,
  Upsi: SO,
  upsih: LO,
  Upsilon: EO,
  upsilon: CO,
  UpTeeArrow: TO,
  UpTee: DO,
  upuparrows: qO,
  urcorn: jO,
  urcorner: RO,
  urcrop: NO,
  Uring: PO,
  uring: IO,
  urtri: OO,
  Uscr: FO,
  uscr: MO,
  utdot: BO,
  Utilde: zO,
  utilde: $O,
  utri: GO,
  utrif: UO,
  uuarr: HO,
  Uuml: VO,
  uuml: WO,
  uwangle: ZO,
  vangrt: JO,
  varepsilon: QO,
  varkappa: YO,
  varnothing: XO,
  varphi: KO,
  varpi: eF,
  varpropto: nF,
  varr: tF,
  vArr: oF,
  varrho: sF,
  varsigma: rF,
  varsubsetneq: cF,
  varsubsetneqq: aF,
  varsupsetneq: iF,
  varsupsetneqq: lF,
  vartheta: uF,
  vartriangleleft: pF,
  vartriangleright: hF,
  vBar: dF,
  Vbar: fF,
  vBarv: mF,
  Vcy: gF,
  vcy: _F,
  vdash: bF,
  vDash: kF,
  Vdash: wF,
  VDash: yF,
  Vdashl: vF,
  veebar: xF,
  vee: AF,
  Vee: SF,
  veeeq: LF,
  vellip: EF,
  verbar: CF,
  Verbar: TF,
  vert: DF,
  Vert: qF,
  VerticalBar: jF,
  VerticalLine: RF,
  VerticalSeparator: NF,
  VerticalTilde: PF,
  VeryThinSpace: IF,
  Vfr: OF,
  vfr: FF,
  vltri: MF,
  vnsub: BF,
  vnsup: zF,
  Vopf: $F,
  vopf: GF,
  vprop: UF,
  vrtri: HF,
  Vscr: VF,
  vscr: WF,
  vsubnE: ZF,
  vsubne: JF,
  vsupnE: QF,
  vsupne: YF,
  Vvdash: XF,
  vzigzag: KF,
  Wcirc: e3,
  wcirc: n3,
  wedbar: t3,
  wedge: o3,
  Wedge: s3,
  wedgeq: r3,
  weierp: c3,
  Wfr: a3,
  wfr: i3,
  Wopf: l3,
  wopf: u3,
  wp: p3,
  wr: h3,
  wreath: d3,
  Wscr: f3,
  wscr: m3,
  xcap: g3,
  xcirc: _3,
  xcup: b3,
  xdtri: k3,
  Xfr: w3,
  xfr: y3,
  xharr: v3,
  xhArr: x3,
  Xi: A3,
  xi: S3,
  xlarr: L3,
  xlArr: E3,
  xmap: C3,
  xnis: T3,
  xodot: D3,
  Xopf: q3,
  xopf: j3,
  xoplus: R3,
  xotime: N3,
  xrarr: P3,
  xrArr: I3,
  Xscr: O3,
  xscr: F3,
  xsqcup: M3,
  xuplus: B3,
  xutri: z3,
  xvee: $3,
  xwedge: G3,
  Yacute: U3,
  yacute: H3,
  YAcy: V3,
  yacy: W3,
  Ycirc: Z3,
  ycirc: J3,
  Ycy: Q3,
  ycy: Y3,
  yen: X3,
  Yfr: K3,
  yfr: eM,
  YIcy: nM,
  yicy: tM,
  Yopf: oM,
  yopf: sM,
  Yscr: rM,
  yscr: cM,
  YUcy: aM,
  yucy: iM,
  yuml: lM,
  Yuml: uM,
  Zacute: pM,
  zacute: hM,
  Zcaron: dM,
  zcaron: fM,
  Zcy: mM,
  zcy: gM,
  Zdot: _M,
  zdot: bM,
  zeetrf: kM,
  ZeroWidthSpace: wM,
  Zeta: yM,
  zeta: vM,
  zfr: xM,
  Zfr: AM,
  ZHcy: SM,
  zhcy: LM,
  zigrarr: EM,
  zopf: CM,
  Zopf: TM,
  Zscr: DM,
  zscr: qM,
  zwj: jM,
  zwnj: RM
};
(function(n) {
  n.exports = NM;
})(ms);
var Qn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, ze = {}, pt = {};
function PM(n) {
  var e, t, o = pt[n];
  if (o)
    return o;
  for (o = pt[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? o.push(t) : o.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    o[n.charCodeAt(e)] = n[e];
  return o;
}
function hn(n, e, t) {
  var o, r, s, a, c, l = "";
  for (typeof e != "string" && (t = e, e = hn.defaultChars), typeof t > "u" && (t = !0), c = PM(e), o = 0, r = n.length; o < r; o++) {
    if (s = n.charCodeAt(o), t && s === 37 && o + 2 < r && /^[0-9a-f]{2}$/i.test(n.slice(o + 1, o + 3))) {
      l += n.slice(o, o + 3), o += 2;
      continue;
    }
    if (s < 128) {
      l += c[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && o + 1 < r && (a = n.charCodeAt(o + 1), a >= 56320 && a <= 57343)) {
        l += encodeURIComponent(n[o] + n[o + 1]), o++;
        continue;
      }
      l += "%EF%BF%BD";
      continue;
    }
    l += encodeURIComponent(n[o]);
  }
  return l;
}
hn.defaultChars = ";/?:@&=+$,-_.!~*'()#";
hn.componentChars = "-_.!~*'()";
var IM = hn, ht = {};
function OM(n) {
  var e, t, o = ht[n];
  if (o)
    return o;
  for (o = ht[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), o.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), o[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return o;
}
function dn(n, e) {
  var t;
  return typeof e != "string" && (e = dn.defaultChars), t = OM(e), n.replace(/(%[a-f0-9]{2})+/gi, function(o) {
    var r, s, a, c, l, i, p, h = "";
    for (r = 0, s = o.length; r < s; r += 3) {
      if (a = parseInt(o.slice(r + 1, r + 3), 16), a < 128) {
        h += t[a];
        continue;
      }
      if ((a & 224) === 192 && r + 3 < s && (c = parseInt(o.slice(r + 4, r + 6), 16), (c & 192) === 128)) {
        p = a << 6 & 1984 | c & 63, p < 128 ? h += "��" : h += String.fromCharCode(p), r += 3;
        continue;
      }
      if ((a & 240) === 224 && r + 6 < s && (c = parseInt(o.slice(r + 4, r + 6), 16), l = parseInt(o.slice(r + 7, r + 9), 16), (c & 192) === 128 && (l & 192) === 128)) {
        p = a << 12 & 61440 | c << 6 & 4032 | l & 63, p < 2048 || p >= 55296 && p <= 57343 ? h += "���" : h += String.fromCharCode(p), r += 6;
        continue;
      }
      if ((a & 248) === 240 && r + 9 < s && (c = parseInt(o.slice(r + 4, r + 6), 16), l = parseInt(o.slice(r + 7, r + 9), 16), i = parseInt(o.slice(r + 10, r + 12), 16), (c & 192) === 128 && (l & 192) === 128 && (i & 192) === 128)) {
        p = a << 18 & 1835008 | c << 12 & 258048 | l << 6 & 4032 | i & 63, p < 65536 || p > 1114111 ? h += "����" : (p -= 65536, h += String.fromCharCode(55296 + (p >> 10), 56320 + (p & 1023))), r += 9;
        continue;
      }
      h += "�";
    }
    return h;
  });
}
dn.defaultChars = ";/?:@&=+$,#";
dn.componentChars = "";
var FM = dn, MM = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function rn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var BM = /^([a-z0-9.+-]+:)/i, zM = /:[0-9]*$/, $M = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, GM = ["<", ">", '"', "`", " ", "\r", `
`, "	"], UM = ["{", "}", "|", "\\", "^", "`"].concat(GM), HM = ["'"].concat(UM), dt = ["%", "/", "?", ";", "#"].concat(HM), ft = ["/", "?", "#"], VM = 255, mt = /^[+a-z0-9A-Z_-]{0,63}$/, WM = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, gt = {
  javascript: !0,
  "javascript:": !0
}, _t = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function ZM(n, e) {
  if (n && n instanceof rn)
    return n;
  var t = new rn();
  return t.parse(n, e), t;
}
rn.prototype.parse = function(n, e) {
  var t, o, r, s, a, c = n;
  if (c = c.trim(), !e && n.split("#").length === 1) {
    var l = $M.exec(c);
    if (l)
      return this.pathname = l[1], l[2] && (this.search = l[2]), this;
  }
  var i = BM.exec(c);
  if (i && (i = i[0], r = i.toLowerCase(), this.protocol = i, c = c.substr(i.length)), (e || i || c.match(/^\/\/[^@\/]+@[^@\/]+/)) && (a = c.substr(0, 2) === "//", a && !(i && gt[i]) && (c = c.substr(2), this.slashes = !0)), !gt[i] && (a || i && !_t[i])) {
    var p = -1;
    for (t = 0; t < ft.length; t++)
      s = c.indexOf(ft[t]), s !== -1 && (p === -1 || s < p) && (p = s);
    var h, d;
    for (p === -1 ? d = c.lastIndexOf("@") : d = c.lastIndexOf("@", p), d !== -1 && (h = c.slice(0, d), c = c.slice(d + 1), this.auth = h), p = -1, t = 0; t < dt.length; t++)
      s = c.indexOf(dt[t]), s !== -1 && (p === -1 || s < p) && (p = s);
    p === -1 && (p = c.length), c[p - 1] === ":" && p--;
    var f = c.slice(0, p);
    c = c.slice(p), this.parseHost(f), this.hostname = this.hostname || "";
    var m = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!m) {
      var S = this.hostname.split(/\./);
      for (t = 0, o = S.length; t < o; t++) {
        var L = S[t];
        if (L && !L.match(mt)) {
          for (var _ = "", k = 0, w = L.length; k < w; k++)
            L.charCodeAt(k) > 127 ? _ += "x" : _ += L[k];
          if (!_.match(mt)) {
            var E = S.slice(0, t), y = S.slice(t + 1), u = L.match(WM);
            u && (E.push(u[1]), y.unshift(u[2])), y.length && (c = y.join(".") + c), this.hostname = E.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > VM && (this.hostname = ""), m && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var g = c.indexOf("#");
  g !== -1 && (this.hash = c.substr(g), c = c.slice(0, g));
  var x = c.indexOf("?");
  return x !== -1 && (this.search = c.substr(x), c = c.slice(0, x)), c && (this.pathname = c), _t[r] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
rn.prototype.parseHost = function(n) {
  var e = zM.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var JM = ZM;
ze.encode = IM;
ze.decode = FM;
ze.format = MM;
ze.parse = JM;
var Ae = {}, An, bt;
function mo() {
  return bt || (bt = 1, An = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), An;
}
var Sn, kt;
function go() {
  return kt || (kt = 1, Sn = /[\0-\x1F\x7F-\x9F]/), Sn;
}
var Ln, wt;
function QM() {
  return wt || (wt = 1, Ln = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Ln;
}
var En, yt;
function _o() {
  return yt || (yt = 1, En = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), En;
}
var vt;
function YM() {
  return vt || (vt = 1, Ae.Any = mo(), Ae.Cc = go(), Ae.Cf = QM(), Ae.P = Qn, Ae.Z = _o()), Ae;
}
(function(n) {
  function e(T) {
    return Object.prototype.toString.call(T);
  }
  function t(T) {
    return e(T) === "[object String]";
  }
  var o = Object.prototype.hasOwnProperty;
  function r(T, q) {
    return o.call(T, q);
  }
  function s(T) {
    var q = Array.prototype.slice.call(arguments, 1);
    return q.forEach(function(R) {
      if (R) {
        if (typeof R != "object")
          throw new TypeError(R + "must be object");
        Object.keys(R).forEach(function(F) {
          T[F] = R[F];
        });
      }
    }), T;
  }
  function a(T, q, R) {
    return [].concat(T.slice(0, q), R, T.slice(q + 1));
  }
  function c(T) {
    return !(T >= 55296 && T <= 57343 || T >= 64976 && T <= 65007 || (T & 65535) === 65535 || (T & 65535) === 65534 || T >= 0 && T <= 8 || T === 11 || T >= 14 && T <= 31 || T >= 127 && T <= 159 || T > 1114111);
  }
  function l(T) {
    if (T > 65535) {
      T -= 65536;
      var q = 55296 + (T >> 10), R = 56320 + (T & 1023);
      return String.fromCharCode(q, R);
    }
    return String.fromCharCode(T);
  }
  var i = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, p = /&([a-z#][a-z0-9]{1,31});/gi, h = new RegExp(i.source + "|" + p.source, "gi"), d = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, f = sn;
  function m(T, q) {
    var R = 0;
    return r(f, q) ? f[q] : q.charCodeAt(0) === 35 && d.test(q) && (R = q[1].toLowerCase() === "x" ? parseInt(q.slice(2), 16) : parseInt(q.slice(1), 10), c(R)) ? l(R) : T;
  }
  function S(T) {
    return T.indexOf("\\") < 0 ? T : T.replace(i, "$1");
  }
  function L(T) {
    return T.indexOf("\\") < 0 && T.indexOf("&") < 0 ? T : T.replace(h, function(q, R, F) {
      return R || m(q, F);
    });
  }
  var _ = /[&<>"]/, k = /[&<>"]/g, w = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function E(T) {
    return w[T];
  }
  function y(T) {
    return _.test(T) ? T.replace(k, E) : T;
  }
  var u = /[.?*+^$[\]\\(){}|-]/g;
  function g(T) {
    return T.replace(u, "\\$&");
  }
  function x(T) {
    switch (T) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function b(T) {
    if (T >= 8192 && T <= 8202)
      return !0;
    switch (T) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var v = Qn;
  function A(T) {
    return v.test(T);
  }
  function C(T) {
    switch (T) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function D(T) {
    return T = T.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (T = T.replace(/ẞ/g, "ß")), T.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = ze, n.lib.ucmicro = YM(), n.assign = s, n.isString = t, n.has = r, n.unescapeMd = S, n.unescapeAll = L, n.isValidEntityCode = c, n.fromCodePoint = l, n.escapeHtml = y, n.arrayReplaceAt = a, n.isSpace = x, n.isWhiteSpace = b, n.isMdAsciiPunct = C, n.isPunctChar = A, n.escapeRE = g, n.normalizeReference = D;
})(B);
var fn = {}, XM = function(e, t, o) {
  var r, s, a, c, l = -1, i = e.posMax, p = e.pos;
  for (e.pos = t + 1, r = 1; e.pos < i; ) {
    if (a = e.src.charCodeAt(e.pos), a === 93 && (r--, r === 0)) {
      s = !0;
      break;
    }
    if (c = e.pos, e.md.inline.skipToken(e), a === 91) {
      if (c === e.pos - 1)
        r++;
      else if (o)
        return e.pos = p, -1;
    }
  }
  return s && (l = e.pos), e.pos = p, l;
}, xt = B.unescapeAll, KM = function(e, t, o) {
  var r, s, a = 0, c = t, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(t) === 60) {
    for (t++; t < o; ) {
      if (r = e.charCodeAt(t), r === 10 || r === 60)
        return l;
      if (r === 62)
        return l.pos = t + 1, l.str = xt(e.slice(c + 1, t)), l.ok = !0, l;
      if (r === 92 && t + 1 < o) {
        t += 2;
        continue;
      }
      t++;
    }
    return l;
  }
  for (s = 0; t < o && (r = e.charCodeAt(t), !(r === 32 || r < 32 || r === 127)); ) {
    if (r === 92 && t + 1 < o) {
      if (e.charCodeAt(t + 1) === 32)
        break;
      t += 2;
      continue;
    }
    if (r === 40 && (s++, s > 32))
      return l;
    if (r === 41) {
      if (s === 0)
        break;
      s--;
    }
    t++;
  }
  return c === t || s !== 0 || (l.str = xt(e.slice(c, t)), l.lines = a, l.pos = t, l.ok = !0), l;
}, eB = B.unescapeAll, nB = function(e, t, o) {
  var r, s, a = 0, c = t, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (t >= o || (s = e.charCodeAt(t), s !== 34 && s !== 39 && s !== 40))
    return l;
  for (t++, s === 40 && (s = 41); t < o; ) {
    if (r = e.charCodeAt(t), r === s)
      return l.pos = t + 1, l.lines = a, l.str = eB(e.slice(c + 1, t)), l.ok = !0, l;
    if (r === 40 && s === 41)
      return l;
    r === 10 ? a++ : r === 92 && t + 1 < o && (t++, e.charCodeAt(t) === 10 && a++), t++;
  }
  return l;
};
fn.parseLinkLabel = XM;
fn.parseLinkDestination = KM;
fn.parseLinkTitle = nB;
var tB = B.assign, oB = B.unescapeAll, De = B.escapeHtml, ue = {};
ue.code_inline = function(n, e, t, o, r) {
  var s = n[e];
  return "<code" + r.renderAttrs(s) + ">" + De(n[e].content) + "</code>";
};
ue.code_block = function(n, e, t, o, r) {
  var s = n[e];
  return "<pre" + r.renderAttrs(s) + "><code>" + De(n[e].content) + `</code></pre>
`;
};
ue.fence = function(n, e, t, o, r) {
  var s = n[e], a = s.info ? oB(s.info).trim() : "", c = "", l = "", i, p, h, d, f;
  return a && (h = a.split(/(\s+)/g), c = h[0], l = h.slice(2).join("")), t.highlight ? i = t.highlight(s.content, c, l) || De(s.content) : i = De(s.content), i.indexOf("<pre") === 0 ? i + `
` : a ? (p = s.attrIndex("class"), d = s.attrs ? s.attrs.slice() : [], p < 0 ? d.push(["class", t.langPrefix + c]) : (d[p] = d[p].slice(), d[p][1] += " " + t.langPrefix + c), f = {
    attrs: d
  }, "<pre><code" + r.renderAttrs(f) + ">" + i + `</code></pre>
`) : "<pre><code" + r.renderAttrs(s) + ">" + i + `</code></pre>
`;
};
ue.image = function(n, e, t, o, r) {
  var s = n[e];
  return s.attrs[s.attrIndex("alt")][1] = r.renderInlineAsText(s.children, t, o), r.renderToken(n, e, t);
};
ue.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
ue.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ue.text = function(n, e) {
  return De(n[e].content);
};
ue.html_block = function(n, e) {
  return n[e].content;
};
ue.html_inline = function(n, e) {
  return n[e].content;
};
function $e() {
  this.rules = tB({}, ue);
}
$e.prototype.renderAttrs = function(e) {
  var t, o, r;
  if (!e.attrs)
    return "";
  for (r = "", t = 0, o = e.attrs.length; t < o; t++)
    r += " " + De(e.attrs[t][0]) + '="' + De(e.attrs[t][1]) + '"';
  return r;
};
$e.prototype.renderToken = function(e, t, o) {
  var r, s = "", a = !1, c = e[t];
  return c.hidden ? "" : (c.block && c.nesting !== -1 && t && e[t - 1].hidden && (s += `
`), s += (c.nesting === -1 ? "</" : "<") + c.tag, s += this.renderAttrs(c), c.nesting === 0 && o.xhtmlOut && (s += " /"), c.block && (a = !0, c.nesting === 1 && t + 1 < e.length && (r = e[t + 1], (r.type === "inline" || r.hidden || r.nesting === -1 && r.tag === c.tag) && (a = !1))), s += a ? `>
` : ">", s);
};
$e.prototype.renderInline = function(n, e, t) {
  for (var o, r = "", s = this.rules, a = 0, c = n.length; a < c; a++)
    o = n[a].type, typeof s[o] < "u" ? r += s[o](n, a, e, t, this) : r += this.renderToken(n, a, e);
  return r;
};
$e.prototype.renderInlineAsText = function(n, e, t) {
  for (var o = "", r = 0, s = n.length; r < s; r++)
    n[r].type === "text" ? o += n[r].content : n[r].type === "image" ? o += this.renderInlineAsText(n[r].children, e, t) : n[r].type === "softbreak" && (o += `
`);
  return o;
};
$e.prototype.render = function(n, e, t) {
  var o, r, s, a = "", c = this.rules;
  for (o = 0, r = n.length; o < r; o++)
    s = n[o].type, s === "inline" ? a += this.renderInline(n[o].children, e, t) : typeof c[s] < "u" ? a += c[n[o].type](n, o, e, t, this) : a += this.renderToken(n, o, e, t);
  return a;
};
var sB = $e;
function ce() {
  this.__rules__ = [], this.__cache__ = null;
}
ce.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
ce.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(o) {
      e.indexOf(o) < 0 && e.push(o);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(o) {
      o.enabled && (t && o.alt.indexOf(t) < 0 || n.__cache__[t].push(o.fn));
    });
  });
};
ce.prototype.at = function(n, e, t) {
  var o = this.__find__(n), r = t || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[o].fn = e, this.__rules__[o].alt = r.alt || [], this.__cache__ = null;
};
ce.prototype.before = function(n, e, t, o) {
  var r = this.__find__(n), s = o || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(r, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
ce.prototype.after = function(n, e, t, o) {
  var r = this.__find__(n), s = o || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(r + 1, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
ce.prototype.push = function(n, e, t) {
  var o = t || {};
  this.__rules__.push({
    name: n,
    enabled: !0,
    fn: e,
    alt: o.alt || []
  }), this.__cache__ = null;
};
ce.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(o) {
    var r = this.__find__(o);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + o);
    }
    this.__rules__[r].enabled = !0, t.push(o);
  }, this), this.__cache__ = null, t;
};
ce.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = !1;
  }), this.enable(n, e);
};
ce.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(o) {
    var r = this.__find__(o);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + o);
    }
    this.__rules__[r].enabled = !1, t.push(o);
  }, this), this.__cache__ = null, t;
};
ce.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var Yn = ce, rB = /\r\n?|\n/g, cB = /\0/g, aB = function(e) {
  var t;
  t = e.src.replace(rB, `
`), t = t.replace(cB, "�"), e.src = t;
}, iB = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, lB = function(e) {
  var t = e.tokens, o, r, s;
  for (r = 0, s = t.length; r < s; r++)
    o = t[r], o.type === "inline" && e.md.inline.parse(o.content, e.md, e.env, o.children);
}, uB = B.arrayReplaceAt;
function pB(n) {
  return /^<a[>\s]/i.test(n);
}
function hB(n) {
  return /^<\/a\s*>/i.test(n);
}
var dB = function(e) {
  var t, o, r, s, a, c, l, i, p, h, d, f, m, S, L, _, k = e.tokens, w;
  if (e.md.options.linkify) {
    for (o = 0, r = k.length; o < r; o++)
      if (!(k[o].type !== "inline" || !e.md.linkify.pretest(k[o].content)))
        for (s = k[o].children, m = 0, t = s.length - 1; t >= 0; t--) {
          if (c = s[t], c.type === "link_close") {
            for (t--; s[t].level !== c.level && s[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (c.type === "html_inline" && (pB(c.content) && m > 0 && m--, hB(c.content) && m++), !(m > 0) && c.type === "text" && e.md.linkify.test(c.content)) {
            for (p = c.content, w = e.md.linkify.match(p), l = [], f = c.level, d = 0, w.length > 0 && w[0].index === 0 && t > 0 && s[t - 1].type === "text_special" && (w = w.slice(1)), i = 0; i < w.length; i++)
              S = w[i].url, L = e.md.normalizeLink(S), e.md.validateLink(L) && (_ = w[i].text, w[i].schema ? w[i].schema === "mailto:" && !/^mailto:/i.test(_) ? _ = e.md.normalizeLinkText("mailto:" + _).replace(/^mailto:/, "") : _ = e.md.normalizeLinkText(_) : _ = e.md.normalizeLinkText("http://" + _).replace(/^http:\/\//, ""), h = w[i].index, h > d && (a = new e.Token("text", "", 0), a.content = p.slice(d, h), a.level = f, l.push(a)), a = new e.Token("link_open", "a", 1), a.attrs = [["href", L]], a.level = f++, a.markup = "linkify", a.info = "auto", l.push(a), a = new e.Token("text", "", 0), a.content = _, a.level = f, l.push(a), a = new e.Token("link_close", "a", -1), a.level = --f, a.markup = "linkify", a.info = "auto", l.push(a), d = w[i].lastIndex);
            d < p.length && (a = new e.Token("text", "", 0), a.content = p.slice(d), a.level = f, l.push(a)), k[o].children = s = uB(s, t, l);
          }
        }
  }
}, bo = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, fB = /\((c|tm|r)\)/i, mB = /\((c|tm|r)\)/ig, gB = {
  c: "©",
  r: "®",
  tm: "™"
};
function _B(n, e) {
  return gB[e.toLowerCase()];
}
function bB(n) {
  var e, t, o = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !o && (t.content = t.content.replace(mB, _B)), t.type === "link_open" && t.info === "auto" && o--, t.type === "link_close" && t.info === "auto" && o++;
}
function kB(n) {
  var e, t, o = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !o && bo.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && o--, t.type === "link_close" && t.info === "auto" && o++;
}
var wB = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (fB.test(e.tokens[t].content) && bB(e.tokens[t].children), bo.test(e.tokens[t].content) && kB(e.tokens[t].children));
}, At = B.isWhiteSpace, St = B.isPunctChar, Lt = B.isMdAsciiPunct, yB = /['"]/, Et = /['"]/g, Ct = "’";
function en(n, e, t) {
  return n.slice(0, e) + t + n.slice(e + 1);
}
function vB(n, e) {
  var t, o, r, s, a, c, l, i, p, h, d, f, m, S, L, _, k, w, E, y, u;
  for (E = [], t = 0; t < n.length; t++) {
    for (o = n[t], l = n[t].level, k = E.length - 1; k >= 0 && !(E[k].level <= l); k--)
      ;
    if (E.length = k + 1, o.type === "text") {
      r = o.content, a = 0, c = r.length;
      e:
        for (; a < c && (Et.lastIndex = a, s = Et.exec(r), !!s); ) {
          if (L = _ = !0, a = s.index + 1, w = s[0] === "'", p = 32, s.index - 1 >= 0)
            p = r.charCodeAt(s.index - 1);
          else
            for (k = t - 1; k >= 0 && !(n[k].type === "softbreak" || n[k].type === "hardbreak"); k--)
              if (n[k].content) {
                p = n[k].content.charCodeAt(n[k].content.length - 1);
                break;
              }
          if (h = 32, a < c)
            h = r.charCodeAt(a);
          else
            for (k = t + 1; k < n.length && !(n[k].type === "softbreak" || n[k].type === "hardbreak"); k++)
              if (n[k].content) {
                h = n[k].content.charCodeAt(0);
                break;
              }
          if (d = Lt(p) || St(String.fromCharCode(p)), f = Lt(h) || St(String.fromCharCode(h)), m = At(p), S = At(h), S ? L = !1 : f && (m || d || (L = !1)), m ? _ = !1 : d && (S || f || (_ = !1)), h === 34 && s[0] === '"' && p >= 48 && p <= 57 && (_ = L = !1), L && _ && (L = d, _ = f), !L && !_) {
            w && (o.content = en(o.content, s.index, Ct));
            continue;
          }
          if (_) {
            for (k = E.length - 1; k >= 0 && (i = E[k], !(E[k].level < l)); k--)
              if (i.single === w && E[k].level === l) {
                i = E[k], w ? (y = e.md.options.quotes[2], u = e.md.options.quotes[3]) : (y = e.md.options.quotes[0], u = e.md.options.quotes[1]), o.content = en(o.content, s.index, u), n[i.token].content = en(
                  n[i.token].content,
                  i.pos,
                  y
                ), a += u.length - 1, i.token === t && (a += y.length - 1), r = o.content, c = r.length, E.length = k;
                continue e;
              }
          }
          L ? E.push({
            token: t,
            pos: s.index,
            single: w,
            level: l
          }) : _ && w && (o.content = en(o.content, s.index, Ct));
        }
    }
  }
}
var xB = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !yB.test(e.tokens[t].content) || vB(e.tokens[t].children, e);
}, AB = function(e) {
  var t, o, r, s, a, c, l = e.tokens;
  for (t = 0, o = l.length; t < o; t++)
    if (l[t].type === "inline") {
      for (r = l[t].children, a = r.length, s = 0; s < a; s++)
        r[s].type === "text_special" && (r[s].type = "text");
      for (s = c = 0; s < a; s++)
        r[s].type === "text" && s + 1 < a && r[s + 1].type === "text" ? r[s + 1].content = r[s].content + r[s + 1].content : (s !== c && (r[c] = r[s]), c++);
      s !== c && (r.length = c);
    }
};
function Ge(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Ge.prototype.attrIndex = function(e) {
  var t, o, r;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, o = 0, r = t.length; o < r; o++)
    if (t[o][0] === e)
      return o;
  return -1;
};
Ge.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Ge.prototype.attrSet = function(e, t) {
  var o = this.attrIndex(e), r = [e, t];
  o < 0 ? this.attrPush(r) : this.attrs[o] = r;
};
Ge.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), o = null;
  return t >= 0 && (o = this.attrs[t][1]), o;
};
Ge.prototype.attrJoin = function(e, t) {
  var o = this.attrIndex(e);
  o < 0 ? this.attrPush([e, t]) : this.attrs[o][1] = this.attrs[o][1] + " " + t;
};
var Xn = Ge, SB = Xn;
function ko(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
}
ko.prototype.Token = SB;
var LB = ko, EB = Yn, Cn = [
  ["normalize", aB],
  ["block", iB],
  ["inline", lB],
  ["linkify", dB],
  ["replacements", wB],
  ["smartquotes", xB],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", AB]
];
function Kn() {
  this.ruler = new EB();
  for (var n = 0; n < Cn.length; n++)
    this.ruler.push(Cn[n][0], Cn[n][1]);
}
Kn.prototype.process = function(n) {
  var e, t, o;
  for (o = this.ruler.getRules(""), e = 0, t = o.length; e < t; e++)
    o[e](n);
};
Kn.prototype.State = LB;
var CB = Kn, Tn = B.isSpace;
function Dn(n, e) {
  var t = n.bMarks[e] + n.tShift[e], o = n.eMarks[e];
  return n.src.slice(t, o);
}
function Tt(n) {
  var e = [], t = 0, o = n.length, r, s = !1, a = 0, c = "";
  for (r = n.charCodeAt(t); t < o; )
    r === 124 && (s ? (c += n.substring(a, t - 1), a = t) : (e.push(c + n.substring(a, t)), c = "", a = t + 1)), s = r === 92, t++, r = n.charCodeAt(t);
  return e.push(c + n.substring(a)), e;
}
var TB = function(e, t, o, r) {
  var s, a, c, l, i, p, h, d, f, m, S, L, _, k, w, E, y, u;
  if (t + 2 > o || (p = t + 1, e.sCount[p] < e.blkIndent) || e.sCount[p] - e.blkIndent >= 4 || (c = e.bMarks[p] + e.tShift[p], c >= e.eMarks[p]) || (y = e.src.charCodeAt(c++), y !== 124 && y !== 45 && y !== 58) || c >= e.eMarks[p] || (u = e.src.charCodeAt(c++), u !== 124 && u !== 45 && u !== 58 && !Tn(u)) || y === 45 && Tn(u))
    return !1;
  for (; c < e.eMarks[p]; ) {
    if (s = e.src.charCodeAt(c), s !== 124 && s !== 45 && s !== 58 && !Tn(s))
      return !1;
    c++;
  }
  for (a = Dn(e, t + 1), h = a.split("|"), m = [], l = 0; l < h.length; l++) {
    if (S = h[l].trim(), !S) {
      if (l === 0 || l === h.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(S))
      return !1;
    S.charCodeAt(S.length - 1) === 58 ? m.push(S.charCodeAt(0) === 58 ? "center" : "right") : S.charCodeAt(0) === 58 ? m.push("left") : m.push("");
  }
  if (a = Dn(e, t).trim(), a.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (h = Tt(a), h.length && h[0] === "" && h.shift(), h.length && h[h.length - 1] === "" && h.pop(), d = h.length, d === 0 || d !== m.length))
    return !1;
  if (r)
    return !0;
  for (k = e.parentType, e.parentType = "table", E = e.md.block.ruler.getRules("blockquote"), f = e.push("table_open", "table", 1), f.map = L = [t, 0], f = e.push("thead_open", "thead", 1), f.map = [t, t + 1], f = e.push("tr_open", "tr", 1), f.map = [t, t + 1], l = 0; l < h.length; l++)
    f = e.push("th_open", "th", 1), m[l] && (f.attrs = [["style", "text-align:" + m[l]]]), f = e.push("inline", "", 0), f.content = h[l].trim(), f.children = [], f = e.push("th_close", "th", -1);
  for (f = e.push("tr_close", "tr", -1), f = e.push("thead_close", "thead", -1), p = t + 2; p < o && !(e.sCount[p] < e.blkIndent); p++) {
    for (w = !1, l = 0, i = E.length; l < i; l++)
      if (E[l](e, p, o, !0)) {
        w = !0;
        break;
      }
    if (w || (a = Dn(e, p).trim(), !a) || e.sCount[p] - e.blkIndent >= 4)
      break;
    for (h = Tt(a), h.length && h[0] === "" && h.shift(), h.length && h[h.length - 1] === "" && h.pop(), p === t + 2 && (f = e.push("tbody_open", "tbody", 1), f.map = _ = [t + 2, 0]), f = e.push("tr_open", "tr", 1), f.map = [p, p + 1], l = 0; l < d; l++)
      f = e.push("td_open", "td", 1), m[l] && (f.attrs = [["style", "text-align:" + m[l]]]), f = e.push("inline", "", 0), f.content = h[l] ? h[l].trim() : "", f.children = [], f = e.push("td_close", "td", -1);
    f = e.push("tr_close", "tr", -1);
  }
  return _ && (f = e.push("tbody_close", "tbody", -1), _[1] = p), f = e.push("table_close", "table", -1), L[1] = p, e.parentType = k, e.line = p, !0;
}, DB = function(e, t, o) {
  var r, s, a;
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  for (s = r = t + 1; r < o; ) {
    if (e.isEmpty(r)) {
      r++;
      continue;
    }
    if (e.sCount[r] - e.blkIndent >= 4) {
      r++, s = r;
      continue;
    }
    break;
  }
  return e.line = s, a = e.push("code_block", "code", 0), a.content = e.getLines(t, s, 4 + e.blkIndent, !1) + `
`, a.map = [t, e.line], !0;
}, qB = function(e, t, o, r) {
  var s, a, c, l, i, p, h, d = !1, f = e.bMarks[t] + e.tShift[t], m = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || f + 3 > m || (s = e.src.charCodeAt(f), s !== 126 && s !== 96) || (i = f, f = e.skipChars(f, s), a = f - i, a < 3) || (h = e.src.slice(i, f), c = e.src.slice(f, m), s === 96 && c.indexOf(String.fromCharCode(s)) >= 0))
    return !1;
  if (r)
    return !0;
  for (l = t; l++, !(l >= o || (f = i = e.bMarks[l] + e.tShift[l], m = e.eMarks[l], f < m && e.sCount[l] < e.blkIndent)); )
    if (e.src.charCodeAt(f) === s && !(e.sCount[l] - e.blkIndent >= 4) && (f = e.skipChars(f, s), !(f - i < a) && (f = e.skipSpaces(f), !(f < m)))) {
      d = !0;
      break;
    }
  return a = e.sCount[t], e.line = l + (d ? 1 : 0), p = e.push("fence", "code", 0), p.info = c, p.content = e.getLines(t + 1, l, a, !0), p.markup = h, p.map = [t, e.line], !0;
}, Dt = B.isSpace, jB = function(e, t, o, r) {
  var s, a, c, l, i, p, h, d, f, m, S, L, _, k, w, E, y, u, g, x, b = e.lineMax, v = e.bMarks[t] + e.tShift[t], A = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(v++) !== 62)
    return !1;
  if (r)
    return !0;
  for (l = f = e.sCount[t] + 1, e.src.charCodeAt(v) === 32 ? (v++, l++, f++, s = !1, E = !0) : e.src.charCodeAt(v) === 9 ? (E = !0, (e.bsCount[t] + f) % 4 === 3 ? (v++, l++, f++, s = !1) : s = !0) : E = !1, m = [e.bMarks[t]], e.bMarks[t] = v; v < A && (a = e.src.charCodeAt(v), Dt(a)); ) {
    a === 9 ? f += 4 - (f + e.bsCount[t] + (s ? 1 : 0)) % 4 : f++;
    v++;
  }
  for (S = [e.bsCount[t]], e.bsCount[t] = e.sCount[t] + 1 + (E ? 1 : 0), p = v >= A, k = [e.sCount[t]], e.sCount[t] = f - l, w = [e.tShift[t]], e.tShift[t] = v - e.bMarks[t], u = e.md.block.ruler.getRules("blockquote"), _ = e.parentType, e.parentType = "blockquote", d = t + 1; d < o && (x = e.sCount[d] < e.blkIndent, v = e.bMarks[d] + e.tShift[d], A = e.eMarks[d], !(v >= A)); d++) {
    if (e.src.charCodeAt(v++) === 62 && !x) {
      for (l = f = e.sCount[d] + 1, e.src.charCodeAt(v) === 32 ? (v++, l++, f++, s = !1, E = !0) : e.src.charCodeAt(v) === 9 ? (E = !0, (e.bsCount[d] + f) % 4 === 3 ? (v++, l++, f++, s = !1) : s = !0) : E = !1, m.push(e.bMarks[d]), e.bMarks[d] = v; v < A && (a = e.src.charCodeAt(v), Dt(a)); ) {
        a === 9 ? f += 4 - (f + e.bsCount[d] + (s ? 1 : 0)) % 4 : f++;
        v++;
      }
      p = v >= A, S.push(e.bsCount[d]), e.bsCount[d] = e.sCount[d] + 1 + (E ? 1 : 0), k.push(e.sCount[d]), e.sCount[d] = f - l, w.push(e.tShift[d]), e.tShift[d] = v - e.bMarks[d];
      continue;
    }
    if (p)
      break;
    for (y = !1, c = 0, i = u.length; c < i; c++)
      if (u[c](e, d, o, !0)) {
        y = !0;
        break;
      }
    if (y) {
      e.lineMax = d, e.blkIndent !== 0 && (m.push(e.bMarks[d]), S.push(e.bsCount[d]), w.push(e.tShift[d]), k.push(e.sCount[d]), e.sCount[d] -= e.blkIndent);
      break;
    }
    m.push(e.bMarks[d]), S.push(e.bsCount[d]), w.push(e.tShift[d]), k.push(e.sCount[d]), e.sCount[d] = -1;
  }
  for (L = e.blkIndent, e.blkIndent = 0, g = e.push("blockquote_open", "blockquote", 1), g.markup = ">", g.map = h = [t, 0], e.md.block.tokenize(e, t, d), g = e.push("blockquote_close", "blockquote", -1), g.markup = ">", e.lineMax = b, e.parentType = _, h[1] = e.line, c = 0; c < w.length; c++)
    e.bMarks[c + t] = m[c], e.tShift[c + t] = w[c], e.sCount[c + t] = k[c], e.bsCount[c + t] = S[c];
  return e.blkIndent = L, !0;
}, RB = B.isSpace, NB = function(e, t, o, r) {
  var s, a, c, l, i = e.bMarks[t] + e.tShift[t], p = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(i++), s !== 42 && s !== 45 && s !== 95))
    return !1;
  for (a = 1; i < p; ) {
    if (c = e.src.charCodeAt(i++), c !== s && !RB(c))
      return !1;
    c === s && a++;
  }
  return a < 3 ? !1 : (r || (e.line = t + 1, l = e.push("hr", "hr", 0), l.map = [t, e.line], l.markup = Array(a + 1).join(String.fromCharCode(s))), !0);
}, wo = B.isSpace;
function qt(n, e) {
  var t, o, r, s;
  return o = n.bMarks[e] + n.tShift[e], r = n.eMarks[e], t = n.src.charCodeAt(o++), t !== 42 && t !== 45 && t !== 43 || o < r && (s = n.src.charCodeAt(o), !wo(s)) ? -1 : o;
}
function jt(n, e) {
  var t, o = n.bMarks[e] + n.tShift[e], r = o, s = n.eMarks[e];
  if (r + 1 >= s || (t = n.src.charCodeAt(r++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (r >= s)
      return -1;
    if (t = n.src.charCodeAt(r++), t >= 48 && t <= 57) {
      if (r - o >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return r < s && (t = n.src.charCodeAt(r), !wo(t)) ? -1 : r;
}
function PB(n, e) {
  var t, o, r = n.level + 2;
  for (t = e + 2, o = n.tokens.length - 2; t < o; t++)
    n.tokens[t].level === r && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = !0, n.tokens[t].hidden = !0, t += 2);
}
var IB = function(e, t, o, r) {
  var s, a, c, l, i, p, h, d, f, m, S, L, _, k, w, E, y, u, g, x, b, v, A, C, D, T, q, R, F = !1, M = !0;
  if (e.sCount[t] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[t] - e.listIndent >= 4 && e.sCount[t] < e.blkIndent)
    return !1;
  if (r && e.parentType === "paragraph" && e.sCount[t] >= e.blkIndent && (F = !0), (A = jt(e, t)) >= 0) {
    if (h = !0, D = e.bMarks[t] + e.tShift[t], _ = Number(e.src.slice(D, A - 1)), F && _ !== 1)
      return !1;
  } else if ((A = qt(e, t)) >= 0)
    h = !1;
  else
    return !1;
  if (F && e.skipSpaces(A) >= e.eMarks[t])
    return !1;
  if (L = e.src.charCodeAt(A - 1), r)
    return !0;
  for (S = e.tokens.length, h ? (R = e.push("ordered_list_open", "ol", 1), _ !== 1 && (R.attrs = [["start", _]])) : R = e.push("bullet_list_open", "ul", 1), R.map = m = [t, 0], R.markup = String.fromCharCode(L), w = t, C = !1, q = e.md.block.ruler.getRules("list"), u = e.parentType, e.parentType = "list"; w < o; ) {
    for (v = A, k = e.eMarks[w], p = E = e.sCount[w] + A - (e.bMarks[t] + e.tShift[t]); v < k; ) {
      if (s = e.src.charCodeAt(v), s === 9)
        E += 4 - (E + e.bsCount[w]) % 4;
      else if (s === 32)
        E++;
      else
        break;
      v++;
    }
    if (a = v, a >= k ? i = 1 : i = E - p, i > 4 && (i = 1), l = p + i, R = e.push("list_item_open", "li", 1), R.markup = String.fromCharCode(L), R.map = d = [t, 0], h && (R.info = e.src.slice(D, A - 1)), b = e.tight, x = e.tShift[t], g = e.sCount[t], y = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = l, e.tight = !0, e.tShift[t] = a - e.bMarks[t], e.sCount[t] = E, a >= k && e.isEmpty(t + 1) ? e.line = Math.min(e.line + 2, o) : e.md.block.tokenize(e, t, o, !0), (!e.tight || C) && (M = !1), C = e.line - t > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = y, e.tShift[t] = x, e.sCount[t] = g, e.tight = b, R = e.push("list_item_close", "li", -1), R.markup = String.fromCharCode(L), w = t = e.line, d[1] = w, a = e.bMarks[t], w >= o || e.sCount[w] < e.blkIndent || e.sCount[t] - e.blkIndent >= 4)
      break;
    for (T = !1, c = 0, f = q.length; c < f; c++)
      if (q[c](e, w, o, !0)) {
        T = !0;
        break;
      }
    if (T)
      break;
    if (h) {
      if (A = jt(e, w), A < 0)
        break;
      D = e.bMarks[w] + e.tShift[w];
    } else if (A = qt(e, w), A < 0)
      break;
    if (L !== e.src.charCodeAt(A - 1))
      break;
  }
  return h ? R = e.push("ordered_list_close", "ol", -1) : R = e.push("bullet_list_close", "ul", -1), R.markup = String.fromCharCode(L), m[1] = w, e.line = w, e.parentType = u, M && PB(e, S), !0;
}, OB = B.normalizeReference, nn = B.isSpace, FB = function(e, t, o, r) {
  var s, a, c, l, i, p, h, d, f, m, S, L, _, k, w, E, y = 0, u = e.bMarks[t] + e.tShift[t], g = e.eMarks[t], x = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(u) !== 91)
    return !1;
  for (; ++u < g; )
    if (e.src.charCodeAt(u) === 93 && e.src.charCodeAt(u - 1) !== 92) {
      if (u + 1 === g || e.src.charCodeAt(u + 1) !== 58)
        return !1;
      break;
    }
  for (l = e.lineMax, w = e.md.block.ruler.getRules("reference"), m = e.parentType, e.parentType = "reference"; x < l && !e.isEmpty(x); x++)
    if (!(e.sCount[x] - e.blkIndent > 3) && !(e.sCount[x] < 0)) {
      for (k = !1, p = 0, h = w.length; p < h; p++)
        if (w[p](e, x, l, !0)) {
          k = !0;
          break;
        }
      if (k)
        break;
    }
  for (_ = e.getLines(t, x, e.blkIndent, !1).trim(), g = _.length, u = 1; u < g; u++) {
    if (s = _.charCodeAt(u), s === 91)
      return !1;
    if (s === 93) {
      f = u;
      break;
    } else
      s === 10 ? y++ : s === 92 && (u++, u < g && _.charCodeAt(u) === 10 && y++);
  }
  if (f < 0 || _.charCodeAt(f + 1) !== 58)
    return !1;
  for (u = f + 2; u < g; u++)
    if (s = _.charCodeAt(u), s === 10)
      y++;
    else if (!nn(s))
      break;
  if (S = e.md.helpers.parseLinkDestination(_, u, g), !S.ok || (i = e.md.normalizeLink(S.str), !e.md.validateLink(i)))
    return !1;
  for (u = S.pos, y += S.lines, a = u, c = y, L = u; u < g; u++)
    if (s = _.charCodeAt(u), s === 10)
      y++;
    else if (!nn(s))
      break;
  for (S = e.md.helpers.parseLinkTitle(_, u, g), u < g && L !== u && S.ok ? (E = S.str, u = S.pos, y += S.lines) : (E = "", u = a, y = c); u < g && (s = _.charCodeAt(u), !!nn(s)); )
    u++;
  if (u < g && _.charCodeAt(u) !== 10 && E)
    for (E = "", u = a, y = c; u < g && (s = _.charCodeAt(u), !!nn(s)); )
      u++;
  return u < g && _.charCodeAt(u) !== 10 || (d = OB(_.slice(1, f)), !d) ? !1 : (r || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[d] > "u" && (e.env.references[d] = { title: E, href: i }), e.parentType = m, e.line = t + y + 1), !0);
}, MB = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], mn = {}, BB = "[a-zA-Z_:][a-zA-Z0-9:._-]*", zB = "[^\"'=<>`\\x00-\\x20]+", $B = "'[^']*'", GB = '"[^"]*"', UB = "(?:" + zB + "|" + $B + "|" + GB + ")", HB = "(?:\\s+" + BB + "(?:\\s*=\\s*" + UB + ")?)", yo = "<[A-Za-z][A-Za-z0-9\\-]*" + HB + "*\\s*\\/?>", vo = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", VB = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", WB = "<[?][\\s\\S]*?[?]>", ZB = "<![A-Z]+\\s+[^>]*>", JB = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", QB = new RegExp("^(?:" + yo + "|" + vo + "|" + VB + "|" + WB + "|" + ZB + "|" + JB + ")"), YB = new RegExp("^(?:" + yo + "|" + vo + ")");
mn.HTML_TAG_RE = QB;
mn.HTML_OPEN_CLOSE_TAG_RE = YB;
var XB = MB, KB = mn.HTML_OPEN_CLOSE_TAG_RE, Pe = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + XB.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(KB.source + "\\s*$"), /^$/, !1]
], ez = function(e, t, o, r) {
  var s, a, c, l, i = e.bMarks[t] + e.tShift[t], p = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(i) !== 60)
    return !1;
  for (l = e.src.slice(i, p), s = 0; s < Pe.length && !Pe[s][0].test(l); s++)
    ;
  if (s === Pe.length)
    return !1;
  if (r)
    return Pe[s][2];
  if (a = t + 1, !Pe[s][1].test(l)) {
    for (; a < o && !(e.sCount[a] < e.blkIndent); a++)
      if (i = e.bMarks[a] + e.tShift[a], p = e.eMarks[a], l = e.src.slice(i, p), Pe[s][1].test(l)) {
        l.length !== 0 && a++;
        break;
      }
  }
  return e.line = a, c = e.push("html_block", "", 0), c.map = [t, a], c.content = e.getLines(t, a, e.blkIndent, !0), !0;
}, Rt = B.isSpace, nz = function(e, t, o, r) {
  var s, a, c, l, i = e.bMarks[t] + e.tShift[t], p = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(i), s !== 35 || i >= p))
    return !1;
  for (a = 1, s = e.src.charCodeAt(++i); s === 35 && i < p && a <= 6; )
    a++, s = e.src.charCodeAt(++i);
  return a > 6 || i < p && !Rt(s) ? !1 : (r || (p = e.skipSpacesBack(p, i), c = e.skipCharsBack(p, 35, i), c > i && Rt(e.src.charCodeAt(c - 1)) && (p = c), e.line = t + 1, l = e.push("heading_open", "h" + String(a), 1), l.markup = "########".slice(0, a), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = e.src.slice(i, p).trim(), l.map = [t, e.line], l.children = [], l = e.push("heading_close", "h" + String(a), -1), l.markup = "########".slice(0, a)), !0);
}, tz = function(e, t, o) {
  var r, s, a, c, l, i, p, h, d, f = t + 1, m, S = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  for (m = e.parentType, e.parentType = "paragraph"; f < o && !e.isEmpty(f); f++)
    if (!(e.sCount[f] - e.blkIndent > 3)) {
      if (e.sCount[f] >= e.blkIndent && (i = e.bMarks[f] + e.tShift[f], p = e.eMarks[f], i < p && (d = e.src.charCodeAt(i), (d === 45 || d === 61) && (i = e.skipChars(i, d), i = e.skipSpaces(i), i >= p)))) {
        h = d === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[f] < 0)) {
        for (s = !1, a = 0, c = S.length; a < c; a++)
          if (S[a](e, f, o, !0)) {
            s = !0;
            break;
          }
        if (s)
          break;
      }
    }
  return h ? (r = e.getLines(t, f, e.blkIndent, !1).trim(), e.line = f + 1, l = e.push("heading_open", "h" + String(h), 1), l.markup = String.fromCharCode(d), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = r, l.map = [t, e.line - 1], l.children = [], l = e.push("heading_close", "h" + String(h), -1), l.markup = String.fromCharCode(d), e.parentType = m, !0) : !1;
}, oz = function(e, t) {
  var o, r, s, a, c, l, i = t + 1, p = e.md.block.ruler.getRules("paragraph"), h = e.lineMax;
  for (l = e.parentType, e.parentType = "paragraph"; i < h && !e.isEmpty(i); i++)
    if (!(e.sCount[i] - e.blkIndent > 3) && !(e.sCount[i] < 0)) {
      for (r = !1, s = 0, a = p.length; s < a; s++)
        if (p[s](e, i, h, !0)) {
          r = !0;
          break;
        }
      if (r)
        break;
    }
  return o = e.getLines(t, i, e.blkIndent, !1).trim(), e.line = i, c = e.push("paragraph_open", "p", 1), c.map = [t, e.line], c = e.push("inline", "", 0), c.content = o, c.map = [t, e.line], c.children = [], c = e.push("paragraph_close", "p", -1), e.parentType = l, !0;
}, xo = Xn, gn = B.isSpace;
function pe(n, e, t, o) {
  var r, s, a, c, l, i, p, h;
  for (this.src = n, this.md = e, this.env = t, this.tokens = o, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, h = !1, a = c = i = p = 0, l = s.length; c < l; c++) {
    if (r = s.charCodeAt(c), !h)
      if (gn(r)) {
        i++, r === 9 ? p += 4 - p % 4 : p++;
        continue;
      } else
        h = !0;
    (r === 10 || c === l - 1) && (r !== 10 && c++, this.bMarks.push(a), this.eMarks.push(c), this.tShift.push(i), this.sCount.push(p), this.bsCount.push(0), h = !1, i = 0, p = 0, a = c + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
pe.prototype.push = function(n, e, t) {
  var o = new xo(n, e, t);
  return o.block = !0, t < 0 && this.level--, o.level = this.level, t > 0 && this.level++, this.tokens.push(o), o;
};
pe.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
pe.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
pe.prototype.skipSpaces = function(e) {
  for (var t, o = this.src.length; e < o && (t = this.src.charCodeAt(e), !!gn(t)); e++)
    ;
  return e;
};
pe.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!gn(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
pe.prototype.skipChars = function(e, t) {
  for (var o = this.src.length; e < o && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
pe.prototype.skipCharsBack = function(e, t, o) {
  if (e <= o)
    return e;
  for (; e > o; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
pe.prototype.getLines = function(e, t, o, r) {
  var s, a, c, l, i, p, h, d = e;
  if (e >= t)
    return "";
  for (p = new Array(t - e), s = 0; d < t; d++, s++) {
    for (a = 0, h = l = this.bMarks[d], d + 1 < t || r ? i = this.eMarks[d] + 1 : i = this.eMarks[d]; l < i && a < o; ) {
      if (c = this.src.charCodeAt(l), gn(c))
        c === 9 ? a += 4 - (a + this.bsCount[d]) % 4 : a++;
      else if (l - h < this.tShift[d])
        a++;
      else
        break;
      l++;
    }
    a > o ? p[s] = new Array(a - o + 1).join(" ") + this.src.slice(l, i) : p[s] = this.src.slice(l, i);
  }
  return p.join("");
};
pe.prototype.Token = xo;
var sz = pe, rz = Yn, tn = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", TB, ["paragraph", "reference"]],
  ["code", DB],
  ["fence", qB, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", jB, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", NB, ["paragraph", "reference", "blockquote", "list"]],
  ["list", IB, ["paragraph", "reference", "blockquote"]],
  ["reference", FB],
  ["html_block", ez, ["paragraph", "reference", "blockquote"]],
  ["heading", nz, ["paragraph", "reference", "blockquote"]],
  ["lheading", tz],
  ["paragraph", oz]
];
function _n() {
  this.ruler = new rz();
  for (var n = 0; n < tn.length; n++)
    this.ruler.push(tn[n][0], tn[n][1], { alt: (tn[n][2] || []).slice() });
}
_n.prototype.tokenize = function(n, e, t) {
  for (var o, r, s = this.ruler.getRules(""), a = s.length, c = e, l = !1, i = n.md.options.maxNesting; c < t && (n.line = c = n.skipEmptyLines(c), !(c >= t || n.sCount[c] < n.blkIndent)); ) {
    if (n.level >= i) {
      n.line = t;
      break;
    }
    for (r = 0; r < a && (o = s[r](n, c, t, !1), !o); r++)
      ;
    n.tight = !l, n.isEmpty(n.line - 1) && (l = !0), c = n.line, c < t && n.isEmpty(c) && (l = !0, c++, n.line = c);
  }
};
_n.prototype.parse = function(n, e, t, o) {
  var r;
  n && (r = new this.State(n, e, t, o), this.tokenize(r, r.line, r.lineMax));
};
_n.prototype.State = sz;
var cz = _n;
function az(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var iz = function(e, t) {
  for (var o = e.pos; o < e.posMax && !az(e.src.charCodeAt(o)); )
    o++;
  return o === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, o)), e.pos = o, !0);
}, lz = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i, uz = function(e, t) {
  var o, r, s, a, c, l, i, p;
  return !e.md.options.linkify || e.linkLevel > 0 || (o = e.pos, r = e.posMax, o + 3 > r) || e.src.charCodeAt(o) !== 58 || e.src.charCodeAt(o + 1) !== 47 || e.src.charCodeAt(o + 2) !== 47 || (s = e.pending.match(lz), !s) || (a = s[1], c = e.md.linkify.matchAtStart(e.src.slice(o - a.length)), !c) || (l = c.url, l = l.replace(/\*+$/, ""), i = e.md.normalizeLink(l), !e.md.validateLink(i)) ? !1 : (t || (e.pending = e.pending.slice(0, -a.length), p = e.push("link_open", "a", 1), p.attrs = [["href", i]], p.markup = "linkify", p.info = "auto", p = e.push("text", "", 0), p.content = e.md.normalizeLinkText(l), p = e.push("link_close", "a", -1), p.markup = "linkify", p.info = "auto"), e.pos += l.length - a.length, !0);
}, pz = B.isSpace, hz = function(e, t) {
  var o, r, s, a = e.pos;
  if (e.src.charCodeAt(a) !== 10)
    return !1;
  if (o = e.pending.length - 1, r = e.posMax, !t)
    if (o >= 0 && e.pending.charCodeAt(o) === 32)
      if (o >= 1 && e.pending.charCodeAt(o - 1) === 32) {
        for (s = o - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (a++; a < r && pz(e.src.charCodeAt(a)); )
    a++;
  return e.pos = a, !0;
}, dz = B.isSpace, et = [];
for (var Nt = 0; Nt < 256; Nt++)
  et.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  et[n.charCodeAt(0)] = 1;
});
var fz = function(e, t) {
  var o, r, s, a, c, l = e.pos, i = e.posMax;
  if (e.src.charCodeAt(l) !== 92 || (l++, l >= i))
    return !1;
  if (o = e.src.charCodeAt(l), o === 10) {
    for (t || e.push("hardbreak", "br", 0), l++; l < i && (o = e.src.charCodeAt(l), !!dz(o)); )
      l++;
    return e.pos = l, !0;
  }
  return a = e.src[l], o >= 55296 && o <= 56319 && l + 1 < i && (r = e.src.charCodeAt(l + 1), r >= 56320 && r <= 57343 && (a += e.src[l + 1], l++)), s = "\\" + a, t || (c = e.push("text_special", "", 0), o < 256 && et[o] !== 0 ? c.content = a : c.content = s, c.markup = s, c.info = "escape"), e.pos = l + 1, !0;
}, mz = function(e, t) {
  var o, r, s, a, c, l, i, p, h = e.pos, d = e.src.charCodeAt(h);
  if (d !== 96)
    return !1;
  for (o = h, h++, r = e.posMax; h < r && e.src.charCodeAt(h) === 96; )
    h++;
  if (s = e.src.slice(o, h), i = s.length, e.backticksScanned && (e.backticks[i] || 0) <= o)
    return t || (e.pending += s), e.pos += i, !0;
  for (c = l = h; (c = e.src.indexOf("`", l)) !== -1; ) {
    for (l = c + 1; l < r && e.src.charCodeAt(l) === 96; )
      l++;
    if (p = l - c, p === i)
      return t || (a = e.push("code_inline", "code", 0), a.markup = s, a.content = e.src.slice(h, c).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = l, !0;
    e.backticks[p] = c;
  }
  return e.backticksScanned = !0, t || (e.pending += s), e.pos += i, !0;
}, bn = {};
bn.tokenize = function(e, t) {
  var o, r, s, a, c, l = e.pos, i = e.src.charCodeAt(l);
  if (t || i !== 126 || (r = e.scanDelims(e.pos, !0), a = r.length, c = String.fromCharCode(i), a < 2))
    return !1;
  for (a % 2 && (s = e.push("text", "", 0), s.content = c, a--), o = 0; o < a; o += 2)
    s = e.push("text", "", 0), s.content = c + c, e.delimiters.push({
      marker: i,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
};
function Pt(n, e) {
  var t, o, r, s, a, c = [], l = e.length;
  for (t = 0; t < l; t++)
    r = e[t], r.marker === 126 && r.end !== -1 && (s = e[r.end], a = n.tokens[r.token], a.type = "s_open", a.tag = "s", a.nesting = 1, a.markup = "~~", a.content = "", a = n.tokens[s.token], a.type = "s_close", a.tag = "s", a.nesting = -1, a.markup = "~~", a.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && c.push(s.token - 1));
  for (; c.length; ) {
    for (t = c.pop(), o = t + 1; o < n.tokens.length && n.tokens[o].type === "s_close"; )
      o++;
    o--, t !== o && (a = n.tokens[o], n.tokens[o] = n.tokens[t], n.tokens[t] = a);
  }
}
bn.postProcess = function(e) {
  var t, o = e.tokens_meta, r = e.tokens_meta.length;
  for (Pt(e, e.delimiters), t = 0; t < r; t++)
    o[t] && o[t].delimiters && Pt(e, o[t].delimiters);
};
var kn = {};
kn.tokenize = function(e, t) {
  var o, r, s, a = e.pos, c = e.src.charCodeAt(a);
  if (t || c !== 95 && c !== 42)
    return !1;
  for (r = e.scanDelims(e.pos, c === 42), o = 0; o < r.length; o++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(c), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: c,
      // Total length of these series of delimiters.
      //
      length: r.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
};
function It(n, e) {
  var t, o, r, s, a, c, l = e.length;
  for (t = l - 1; t >= 0; t--)
    o = e[t], !(o.marker !== 95 && o.marker !== 42) && o.end !== -1 && (r = e[o.end], c = t > 0 && e[t - 1].end === o.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === o.marker && e[t - 1].token === o.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[o.end + 1].token === r.token + 1, a = String.fromCharCode(o.marker), s = n.tokens[o.token], s.type = c ? "strong_open" : "em_open", s.tag = c ? "strong" : "em", s.nesting = 1, s.markup = c ? a + a : a, s.content = "", s = n.tokens[r.token], s.type = c ? "strong_close" : "em_close", s.tag = c ? "strong" : "em", s.nesting = -1, s.markup = c ? a + a : a, s.content = "", c && (n.tokens[e[t - 1].token].content = "", n.tokens[e[o.end + 1].token].content = "", t--));
}
kn.postProcess = function(e) {
  var t, o = e.tokens_meta, r = e.tokens_meta.length;
  for (It(e, e.delimiters), t = 0; t < r; t++)
    o[t] && o[t].delimiters && It(e, o[t].delimiters);
};
var gz = B.normalizeReference, qn = B.isSpace, _z = function(e, t) {
  var o, r, s, a, c, l, i, p, h, d = "", f = "", m = e.pos, S = e.posMax, L = e.pos, _ = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (c = e.pos + 1, a = e.md.helpers.parseLinkLabel(e, e.pos, !0), a < 0))
    return !1;
  if (l = a + 1, l < S && e.src.charCodeAt(l) === 40) {
    for (_ = !1, l++; l < S && (r = e.src.charCodeAt(l), !(!qn(r) && r !== 10)); l++)
      ;
    if (l >= S)
      return !1;
    if (L = l, i = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), i.ok) {
      for (d = e.md.normalizeLink(i.str), e.md.validateLink(d) ? l = i.pos : d = "", L = l; l < S && (r = e.src.charCodeAt(l), !(!qn(r) && r !== 10)); l++)
        ;
      if (i = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < S && L !== l && i.ok)
        for (f = i.str, l = i.pos; l < S && (r = e.src.charCodeAt(l), !(!qn(r) && r !== 10)); l++)
          ;
    }
    (l >= S || e.src.charCodeAt(l) !== 41) && (_ = !0), l++;
  }
  if (_) {
    if (typeof e.env.references > "u")
      return !1;
    if (l < S && e.src.charCodeAt(l) === 91 ? (L = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? s = e.src.slice(L, l++) : l = a + 1) : l = a + 1, s || (s = e.src.slice(c, a)), p = e.env.references[gz(s)], !p)
      return e.pos = m, !1;
    d = p.href, f = p.title;
  }
  return t || (e.pos = c, e.posMax = a, h = e.push("link_open", "a", 1), h.attrs = o = [["href", d]], f && o.push(["title", f]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, h = e.push("link_close", "a", -1)), e.pos = l, e.posMax = S, !0;
}, bz = B.normalizeReference, jn = B.isSpace, kz = function(e, t) {
  var o, r, s, a, c, l, i, p, h, d, f, m, S, L = "", _ = e.pos, k = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (l = e.pos + 2, c = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), c < 0))
    return !1;
  if (i = c + 1, i < k && e.src.charCodeAt(i) === 40) {
    for (i++; i < k && (r = e.src.charCodeAt(i), !(!jn(r) && r !== 10)); i++)
      ;
    if (i >= k)
      return !1;
    for (S = i, h = e.md.helpers.parseLinkDestination(e.src, i, e.posMax), h.ok && (L = e.md.normalizeLink(h.str), e.md.validateLink(L) ? i = h.pos : L = ""), S = i; i < k && (r = e.src.charCodeAt(i), !(!jn(r) && r !== 10)); i++)
      ;
    if (h = e.md.helpers.parseLinkTitle(e.src, i, e.posMax), i < k && S !== i && h.ok)
      for (d = h.str, i = h.pos; i < k && (r = e.src.charCodeAt(i), !(!jn(r) && r !== 10)); i++)
        ;
    else
      d = "";
    if (i >= k || e.src.charCodeAt(i) !== 41)
      return e.pos = _, !1;
    i++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (i < k && e.src.charCodeAt(i) === 91 ? (S = i + 1, i = e.md.helpers.parseLinkLabel(e, i), i >= 0 ? a = e.src.slice(S, i++) : i = c + 1) : i = c + 1, a || (a = e.src.slice(l, c)), p = e.env.references[bz(a)], !p)
      return e.pos = _, !1;
    L = p.href, d = p.title;
  }
  return t || (s = e.src.slice(l, c), e.md.inline.parse(
    s,
    e.md,
    e.env,
    m = []
  ), f = e.push("image", "img", 0), f.attrs = o = [["src", L], ["alt", ""]], f.children = m, f.content = s, d && o.push(["title", d])), e.pos = i, e.posMax = k, !0;
}, wz = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, yz = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, vz = function(e, t) {
  var o, r, s, a, c, l, i = e.pos;
  if (e.src.charCodeAt(i) !== 60)
    return !1;
  for (c = e.pos, l = e.posMax; ; ) {
    if (++i >= l || (a = e.src.charCodeAt(i), a === 60))
      return !1;
    if (a === 62)
      break;
  }
  return o = e.src.slice(c + 1, i), yz.test(o) ? (r = e.md.normalizeLink(o), e.md.validateLink(r) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", r]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(o), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += o.length + 2, !0) : !1) : wz.test(o) ? (r = e.md.normalizeLink("mailto:" + o), e.md.validateLink(r) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", r]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(o), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += o.length + 2, !0) : !1) : !1;
}, xz = mn.HTML_TAG_RE;
function Az(n) {
  return /^<a[>\s]/i.test(n);
}
function Sz(n) {
  return /^<\/a\s*>/i.test(n);
}
function Lz(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var Ez = function(e, t) {
  var o, r, s, a, c = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(c) !== 60 || c + 2 >= s) || (o = e.src.charCodeAt(c + 1), o !== 33 && o !== 63 && o !== 47 && !Lz(o)) || (r = e.src.slice(c).match(xz), !r) ? !1 : (t || (a = e.push("html_inline", "", 0), a.content = e.src.slice(c, c + r[0].length), Az(a.content) && e.linkLevel++, Sz(a.content) && e.linkLevel--), e.pos += r[0].length, !0);
}, Ot = sn, Cz = B.has, Tz = B.isValidEntityCode, Ft = B.fromCodePoint, Dz = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, qz = /^&([a-z][a-z0-9]{1,31});/i, jz = function(e, t) {
  var o, r, s, a, c = e.pos, l = e.posMax;
  if (e.src.charCodeAt(c) !== 38 || c + 1 >= l)
    return !1;
  if (o = e.src.charCodeAt(c + 1), o === 35) {
    if (s = e.src.slice(c).match(Dz), s)
      return t || (r = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), a = e.push("text_special", "", 0), a.content = Tz(r) ? Ft(r) : Ft(65533), a.markup = s[0], a.info = "entity"), e.pos += s[0].length, !0;
  } else if (s = e.src.slice(c).match(qz), s && Cz(Ot, s[1]))
    return t || (a = e.push("text_special", "", 0), a.content = Ot[s[1]], a.markup = s[0], a.info = "entity"), e.pos += s[0].length, !0;
  return !1;
};
function Mt(n, e) {
  var t, o, r, s, a, c, l, i, p = {}, h = e.length;
  if (h) {
    var d = 0, f = -2, m = [];
    for (t = 0; t < h; t++)
      if (r = e[t], m.push(0), (e[d].marker !== r.marker || f !== r.token - 1) && (d = t), f = r.token, r.length = r.length || 0, !!r.close) {
        for (p.hasOwnProperty(r.marker) || (p[r.marker] = [-1, -1, -1, -1, -1, -1]), a = p[r.marker][(r.open ? 3 : 0) + r.length % 3], o = d - m[d] - 1, c = o; o > a; o -= m[o] + 1)
          if (s = e[o], s.marker === r.marker && s.open && s.end < 0 && (l = !1, (s.close || r.open) && (s.length + r.length) % 3 === 0 && (s.length % 3 !== 0 || r.length % 3 !== 0) && (l = !0), !l)) {
            i = o > 0 && !e[o - 1].open ? m[o - 1] + 1 : 0, m[t] = t - o + i, m[o] = i, r.open = !1, s.end = t, s.close = !1, c = -1, f = -2;
            break;
          }
        c !== -1 && (p[r.marker][(r.open ? 3 : 0) + (r.length || 0) % 3] = c);
      }
  }
}
var Rz = function(e) {
  var t, o = e.tokens_meta, r = e.tokens_meta.length;
  for (Mt(e, e.delimiters), t = 0; t < r; t++)
    o[t] && o[t].delimiters && Mt(e, o[t].delimiters);
}, Nz = function(e) {
  var t, o, r = 0, s = e.tokens, a = e.tokens.length;
  for (t = o = 0; t < a; t++)
    s[t].nesting < 0 && r--, s[t].level = r, s[t].nesting > 0 && r++, s[t].type === "text" && t + 1 < a && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== o && (s[o] = s[t]), o++);
  t !== o && (s.length = o);
}, nt = Xn, Bt = B.isWhiteSpace, zt = B.isPunctChar, $t = B.isMdAsciiPunct;
function Ye(n, e, t, o) {
  this.src = n, this.env = t, this.md = e, this.tokens = o, this.tokens_meta = Array(o.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Ye.prototype.pushPending = function() {
  var n = new nt("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
Ye.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var o = new nt(n, e, t), r = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), o.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], r = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(o), this.tokens_meta.push(r), o;
};
Ye.prototype.scanDelims = function(n, e) {
  var t = n, o, r, s, a, c, l, i, p, h, d = !0, f = !0, m = this.posMax, S = this.src.charCodeAt(n);
  for (o = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < m && this.src.charCodeAt(t) === S; )
    t++;
  return s = t - n, r = t < m ? this.src.charCodeAt(t) : 32, i = $t(o) || zt(String.fromCharCode(o)), h = $t(r) || zt(String.fromCharCode(r)), l = Bt(o), p = Bt(r), p ? d = !1 : h && (l || i || (d = !1)), l ? f = !1 : i && (p || h || (f = !1)), e ? (a = d, c = f) : (a = d && (!f || i), c = f && (!d || h)), {
    can_open: a,
    can_close: c,
    length: s
  };
};
Ye.prototype.Token = nt;
var Pz = Ye, Gt = Yn, Rn = [
  ["text", iz],
  ["linkify", uz],
  ["newline", hz],
  ["escape", fz],
  ["backticks", mz],
  ["strikethrough", bn.tokenize],
  ["emphasis", kn.tokenize],
  ["link", _z],
  ["image", kz],
  ["autolink", vz],
  ["html_inline", Ez],
  ["entity", jz]
], Nn = [
  ["balance_pairs", Rz],
  ["strikethrough", bn.postProcess],
  ["emphasis", kn.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", Nz]
];
function Xe() {
  var n;
  for (this.ruler = new Gt(), n = 0; n < Rn.length; n++)
    this.ruler.push(Rn[n][0], Rn[n][1]);
  for (this.ruler2 = new Gt(), n = 0; n < Nn.length; n++)
    this.ruler2.push(Nn[n][0], Nn[n][1]);
}
Xe.prototype.skipToken = function(n) {
  var e, t, o = n.pos, r = this.ruler.getRules(""), s = r.length, a = n.md.options.maxNesting, c = n.cache;
  if (typeof c[o] < "u") {
    n.pos = c[o];
    return;
  }
  if (n.level < a)
    for (t = 0; t < s && (n.level++, e = r[t](n, !0), n.level--, !e); t++)
      ;
  else
    n.pos = n.posMax;
  e || n.pos++, c[o] = n.pos;
};
Xe.prototype.tokenize = function(n) {
  for (var e, t, o = this.ruler.getRules(""), r = o.length, s = n.posMax, a = n.md.options.maxNesting; n.pos < s; ) {
    if (n.level < a)
      for (t = 0; t < r && (e = o[t](n, !1), !e); t++)
        ;
    if (e) {
      if (n.pos >= s)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Xe.prototype.parse = function(n, e, t, o) {
  var r, s, a, c = new this.State(n, e, t, o);
  for (this.tokenize(c), s = this.ruler2.getRules(""), a = s.length, r = 0; r < a; r++)
    s[r](c);
};
Xe.prototype.State = Pz;
var Iz = Xe, Pn, Ut;
function Oz() {
  return Ut || (Ut = 1, Pn = function(n) {
    var e = {};
    n = n || {}, e.src_Any = mo().source, e.src_Cc = go().source, e.src_Z = _o().source, e.src_P = Qn.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!" + (n["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Pn;
}
function Un(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(o) {
      n[o] = t[o];
    });
  }), n;
}
function wn(n) {
  return Object.prototype.toString.call(n);
}
function Fz(n) {
  return wn(n) === "[object String]";
}
function Mz(n) {
  return wn(n) === "[object Object]";
}
function Bz(n) {
  return wn(n) === "[object RegExp]";
}
function Ht(n) {
  return wn(n) === "[object Function]";
}
function zz(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Ao = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function $z(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || Ao.hasOwnProperty(t);
  }, !1);
}
var Gz = {
  "http:": {
    validate: function(n, e, t) {
      var o = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(o) ? o.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var o = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(o) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : o.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var o = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(o) ? o.match(t.re.mailto)[0].length : 0;
    }
  }
}, Uz = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", Hz = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function Vz(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function Wz(n) {
  return function(e, t) {
    var o = e.slice(t);
    return n.test(o) ? o.match(n)[0].length : 0;
  };
}
function Vt() {
  return function(n, e) {
    e.normalize(n);
  };
}
function cn(n) {
  var e = n.re = Oz()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(Uz), t.push(e.src_xn), e.src_tlds = t.join("|");
  function o(c) {
    return c.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(o(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(o(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(o(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(o(e.tpl_host_fuzzy_test), "i");
  var r = [];
  n.__compiled__ = {};
  function s(c, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + c + '": ' + l);
  }
  Object.keys(n.__schemas__).forEach(function(c) {
    var l = n.__schemas__[c];
    if (l !== null) {
      var i = { validate: null, link: null };
      if (n.__compiled__[c] = i, Mz(l)) {
        Bz(l.validate) ? i.validate = Wz(l.validate) : Ht(l.validate) ? i.validate = l.validate : s(c, l), Ht(l.normalize) ? i.normalize = l.normalize : l.normalize ? s(c, l) : i.normalize = Vt();
        return;
      }
      if (Fz(l)) {
        r.push(c);
        return;
      }
      s(c, l);
    }
  }), r.forEach(function(c) {
    n.__compiled__[n.__schemas__[c]] && (n.__compiled__[c].validate = n.__compiled__[n.__schemas__[c]].validate, n.__compiled__[c].normalize = n.__compiled__[n.__schemas__[c]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: Vt() };
  var a = Object.keys(n.__compiled__).filter(function(c) {
    return c.length > 0 && n.__compiled__[c];
  }).map(zz).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + a + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + a + ")", "ig"), n.re.schema_at_start = RegExp("^" + n.re.schema_search.source, "i"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), Vz(n);
}
function Zz(n, e) {
  var t = n.__index__, o = n.__last_index__, r = n.__text_cache__.slice(t, o);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = o + e, this.raw = r, this.text = r, this.url = r;
}
function Hn(n, e) {
  var t = new Zz(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function te(n, e) {
  if (!(this instanceof te))
    return new te(n, e);
  e || $z(n) && (e = n, n = {}), this.__opts__ = Un({}, Ao, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Un({}, Gz, n), this.__compiled__ = {}, this.__tlds__ = Hz, this.__tlds_replaced__ = !1, this.re = {}, cn(this);
}
te.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, cn(this), this;
};
te.prototype.set = function(e) {
  return this.__opts__ = Un(this.__opts__, e), this;
};
te.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var t, o, r, s, a, c, l, i, p;
  if (this.re.schema_test.test(e)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (t = l.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, t[2], l.lastIndex), s) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (i = e.search(this.re.host_fuzzy_test), i >= 0 && (this.__index__ < 0 || i < this.__index__) && (o = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (a = o.index + o[1].length, (this.__index__ < 0 || a < this.__index__) && (this.__schema__ = "", this.__index__ = a, this.__last_index__ = o.index + o[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (p = e.indexOf("@"), p >= 0 && (r = e.match(this.re.email_fuzzy)) !== null && (a = r.index + r[1].length, c = r.index + r[0].length, (this.__index__ < 0 || a < this.__index__ || a === this.__index__ && c > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = a, this.__last_index__ = c))), this.__index__ >= 0;
};
te.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
te.prototype.testSchemaAt = function(e, t, o) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, o, this) : 0;
};
te.prototype.match = function(e) {
  var t = 0, o = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (o.push(Hn(this, t)), t = this.__last_index__);
  for (var r = t ? e.slice(t) : e; this.test(r); )
    o.push(Hn(this, t)), r = r.slice(this.__last_index__), t += this.__last_index__;
  return o.length ? o : null;
};
te.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return null;
  var t = this.re.schema_at_start.exec(e);
  if (!t)
    return null;
  var o = this.testSchemaAt(e, t[2], t[0].length);
  return o ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + o, Hn(this, 0)) : null;
};
te.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(o, r, s) {
    return o !== s[r - 1];
  }).reverse(), cn(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, cn(this), this);
};
te.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
te.prototype.onCompile = function() {
};
var Jz = te;
const Me = 2147483647, ie = 36, tt = 1, Je = 26, Qz = 38, Yz = 700, So = 72, Lo = 128, Eo = "-", Xz = /^xn--/, Kz = /[^\0-\x7F]/, e$ = /[\x2E\u3002\uFF0E\uFF61]/g, n$ = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, In = ie - tt, le = Math.floor, On = String.fromCharCode;
function ge(n) {
  throw new RangeError(n$[n]);
}
function t$(n, e) {
  const t = [];
  let o = n.length;
  for (; o--; )
    t[o] = e(n[o]);
  return t;
}
function Co(n, e) {
  const t = n.split("@");
  let o = "";
  t.length > 1 && (o = t[0] + "@", n = t[1]), n = n.replace(e$, ".");
  const r = n.split("."), s = t$(r, e).join(".");
  return o + s;
}
function ot(n) {
  const e = [];
  let t = 0;
  const o = n.length;
  for (; t < o; ) {
    const r = n.charCodeAt(t++);
    if (r >= 55296 && r <= 56319 && t < o) {
      const s = n.charCodeAt(t++);
      (s & 64512) == 56320 ? e.push(((r & 1023) << 10) + (s & 1023) + 65536) : (e.push(r), t--);
    } else
      e.push(r);
  }
  return e;
}
const To = (n) => String.fromCodePoint(...n), o$ = function(n) {
  return n >= 48 && n < 58 ? 26 + (n - 48) : n >= 65 && n < 91 ? n - 65 : n >= 97 && n < 123 ? n - 97 : ie;
}, Wt = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
}, Do = function(n, e, t) {
  let o = 0;
  for (n = t ? le(n / Yz) : n >> 1, n += le(n / e); n > In * Je >> 1; o += ie)
    n = le(n / In);
  return le(o + (In + 1) * n / (n + Qz));
}, st = function(n) {
  const e = [], t = n.length;
  let o = 0, r = Lo, s = So, a = n.lastIndexOf(Eo);
  a < 0 && (a = 0);
  for (let c = 0; c < a; ++c)
    n.charCodeAt(c) >= 128 && ge("not-basic"), e.push(n.charCodeAt(c));
  for (let c = a > 0 ? a + 1 : 0; c < t; ) {
    const l = o;
    for (let p = 1, h = ie; ; h += ie) {
      c >= t && ge("invalid-input");
      const d = o$(n.charCodeAt(c++));
      d >= ie && ge("invalid-input"), d > le((Me - o) / p) && ge("overflow"), o += d * p;
      const f = h <= s ? tt : h >= s + Je ? Je : h - s;
      if (d < f)
        break;
      const m = ie - f;
      p > le(Me / m) && ge("overflow"), p *= m;
    }
    const i = e.length + 1;
    s = Do(o - l, i, l == 0), le(o / i) > Me - r && ge("overflow"), r += le(o / i), o %= i, e.splice(o++, 0, r);
  }
  return String.fromCodePoint(...e);
}, rt = function(n) {
  const e = [];
  n = ot(n);
  const t = n.length;
  let o = Lo, r = 0, s = So;
  for (const l of n)
    l < 128 && e.push(On(l));
  const a = e.length;
  let c = a;
  for (a && e.push(Eo); c < t; ) {
    let l = Me;
    for (const p of n)
      p >= o && p < l && (l = p);
    const i = c + 1;
    l - o > le((Me - r) / i) && ge("overflow"), r += (l - o) * i, o = l;
    for (const p of n)
      if (p < o && ++r > Me && ge("overflow"), p === o) {
        let h = r;
        for (let d = ie; ; d += ie) {
          const f = d <= s ? tt : d >= s + Je ? Je : d - s;
          if (h < f)
            break;
          const m = h - f, S = ie - f;
          e.push(
            On(Wt(f + m % S, 0))
          ), h = le(m / S);
        }
        e.push(On(Wt(h, 0))), s = Do(r, i, c === a), r = 0, ++c;
      }
    ++r, ++o;
  }
  return e.join("");
}, qo = function(n) {
  return Co(n, function(e) {
    return Xz.test(e) ? st(e.slice(4).toLowerCase()) : e;
  });
}, jo = function(n) {
  return Co(n, function(e) {
    return Kz.test(e) ? "xn--" + rt(e) : e;
  });
}, s$ = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.1.0",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: ot,
    encode: To
  },
  decode: st,
  encode: rt,
  toASCII: jo,
  toUnicode: qo
}, r$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: st,
  default: s$,
  encode: rt,
  toASCII: jo,
  toUnicode: qo,
  ucs2decode: ot,
  ucs2encode: To
}, Symbol.toStringTag, { value: "Module" })), c$ = /* @__PURE__ */ ds(r$);
var a$ = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, i$ = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, l$ = {
  options: {
    html: !0,
    // Enable HTML tags in source
    xhtmlOut: !0,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, Ze = B, u$ = fn, p$ = sB, h$ = CB, d$ = cz, f$ = Iz, m$ = Jz, Le = ze, Ro = c$, g$ = {
  default: a$,
  zero: i$,
  commonmark: l$
}, _$ = /^(vbscript|javascript|file|data):/, b$ = /^data:image\/(gif|png|jpeg|webp);/;
function k$(n) {
  var e = n.trim().toLowerCase();
  return _$.test(e) ? !!b$.test(e) : !0;
}
var No = ["http:", "https:", "mailto:"];
function w$(n) {
  var e = Le.parse(n, !0);
  if (e.hostname && (!e.protocol || No.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Ro.toASCII(e.hostname);
    } catch {
    }
  return Le.encode(Le.format(e));
}
function y$(n) {
  var e = Le.parse(n, !0);
  if (e.hostname && (!e.protocol || No.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Ro.toUnicode(e.hostname);
    } catch {
    }
  return Le.decode(Le.format(e), Le.decode.defaultChars + "%");
}
function re(n, e) {
  if (!(this instanceof re))
    return new re(n, e);
  e || Ze.isString(n) || (e = n || {}, n = "default"), this.inline = new f$(), this.block = new d$(), this.core = new h$(), this.renderer = new p$(), this.linkify = new m$(), this.validateLink = k$, this.normalizeLink = w$, this.normalizeLinkText = y$, this.utils = Ze, this.helpers = Ze.assign({}, u$), this.options = {}, this.configure(n), e && this.set(e);
}
re.prototype.set = function(n) {
  return Ze.assign(this.options, n), this;
};
re.prototype.configure = function(n) {
  var e = this, t;
  if (Ze.isString(n) && (t = n, n = g$[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(o) {
    n.components[o].rules && e[o].ruler.enableOnly(n.components[o].rules), n.components[o].rules2 && e[o].ruler2.enableOnly(n.components[o].rules2);
  }), this;
};
re.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(r) {
    t = t.concat(this[r].ruler.enable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.enable(n, !0));
  var o = n.filter(function(r) {
    return t.indexOf(r) < 0;
  });
  if (o.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + o);
  return this;
};
re.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(r) {
    t = t.concat(this[r].ruler.disable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.disable(n, !0));
  var o = n.filter(function(r) {
    return t.indexOf(r) < 0;
  });
  if (o.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + o);
  return this;
};
re.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
re.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
re.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
re.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = !0, this.core.process(t), t.tokens;
};
re.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var v$ = re;
(function(n) {
  n.exports = v$;
})(fs);
const x$ = /* @__PURE__ */ hs(Gn);
var Zt = !1, Be = { false: "push", true: "unshift", after: "push", before: "unshift" }, an = { isPermalinkSymbol: !0 };
function Vn(n, e, t, o) {
  var r;
  if (!Zt) {
    var s = "Using deprecated markdown-it-anchor permalink option, see https://github.com/valeriangalliat/markdown-it-anchor#permalinks";
    typeof process == "object" && process && process.emitWarning ? process.emitWarning(s) : console.warn(s), Zt = !0;
  }
  var a = [Object.assign(new t.Token("link_open", "a", 1), { attrs: [].concat(e.permalinkClass ? [["class", e.permalinkClass]] : [], [["href", e.permalinkHref(n, t)]], Object.entries(e.permalinkAttrs(n, t))) }), Object.assign(new t.Token("html_block", "", 0), { content: e.permalinkSymbol, meta: an }), new t.Token("link_close", "a", -1)];
  e.permalinkSpace && t.tokens[o + 1].children[Be[e.permalinkBefore]](Object.assign(new t.Token("text", "", 0), { content: " " })), (r = t.tokens[o + 1].children)[Be[e.permalinkBefore]].apply(r, a);
}
function Po(n) {
  return "#" + n;
}
function Io(n) {
  return {};
}
var A$ = { class: "header-anchor", symbol: "#", renderHref: Po, renderAttrs: Io };
function Ke(n) {
  function e(t) {
    return t = Object.assign({}, e.defaults, t), function(o, r, s, a) {
      return n(o, t, r, s, a);
    };
  }
  return e.defaults = Object.assign({}, A$), e.renderPermalinkImpl = n, e;
}
var yn = Ke(function(n, e, t, o, r) {
  var s, a = [Object.assign(new o.Token("link_open", "a", 1), { attrs: [].concat(e.class ? [["class", e.class]] : [], [["href", e.renderHref(n, o)]], e.ariaHidden ? [["aria-hidden", "true"]] : [], Object.entries(e.renderAttrs(n, o))) }), Object.assign(new o.Token("html_inline", "", 0), { content: e.symbol, meta: an }), new o.Token("link_close", "a", -1)];
  if (e.space) {
    var c = typeof e.space == "string" ? e.space : " ";
    o.tokens[r + 1].children[Be[e.placement]](Object.assign(new o.Token(typeof e.space == "string" ? "html_inline" : "text", "", 0), { content: c }));
  }
  (s = o.tokens[r + 1].children)[Be[e.placement]].apply(s, a);
});
Object.assign(yn.defaults, { space: !0, placement: "after", ariaHidden: !1 });
var Se = Ke(yn.renderPermalinkImpl);
Se.defaults = Object.assign({}, yn.defaults, { ariaHidden: !0 });
var Oo = Ke(function(n, e, t, o, r) {
  var s = [Object.assign(new o.Token("link_open", "a", 1), { attrs: [].concat(e.class ? [["class", e.class]] : [], [["href", e.renderHref(n, o)]], Object.entries(e.renderAttrs(n, o))) })].concat(e.safariReaderFix ? [new o.Token("span_open", "span", 1)] : [], o.tokens[r + 1].children, e.safariReaderFix ? [new o.Token("span_close", "span", -1)] : [], [new o.Token("link_close", "a", -1)]);
  o.tokens[r + 1] = Object.assign(new o.Token("inline", "", 0), { children: s });
});
Object.assign(Oo.defaults, { safariReaderFix: !1 });
var Jt = Ke(function(n, e, t, o, r) {
  var s;
  if (!["visually-hidden", "aria-label", "aria-describedby", "aria-labelledby"].includes(e.style))
    throw new Error("`permalink.linkAfterHeader` called with unknown style option `" + e.style + "`");
  if (!["aria-describedby", "aria-labelledby"].includes(e.style) && !e.assistiveText)
    throw new Error("`permalink.linkAfterHeader` called without the `assistiveText` option in `" + e.style + "` style");
  if (e.style === "visually-hidden" && !e.visuallyHiddenClass)
    throw new Error("`permalink.linkAfterHeader` called without the `visuallyHiddenClass` option in `visually-hidden` style");
  var a = o.tokens[r + 1].children.filter(function(h) {
    return h.type === "text" || h.type === "code_inline";
  }).reduce(function(h, d) {
    return h + d.content;
  }, ""), c = [], l = [];
  if (e.class && l.push(["class", e.class]), l.push(["href", e.renderHref(n, o)]), l.push.apply(l, Object.entries(e.renderAttrs(n, o))), e.style === "visually-hidden") {
    if (c.push(Object.assign(new o.Token("span_open", "span", 1), { attrs: [["class", e.visuallyHiddenClass]] }), Object.assign(new o.Token("text", "", 0), { content: e.assistiveText(a) }), new o.Token("span_close", "span", -1)), e.space) {
      var i = typeof e.space == "string" ? e.space : " ";
      c[Be[e.placement]](Object.assign(new o.Token(typeof e.space == "string" ? "html_inline" : "text", "", 0), { content: i }));
    }
    c[Be[e.placement]](Object.assign(new o.Token("span_open", "span", 1), { attrs: [["aria-hidden", "true"]] }), Object.assign(new o.Token("html_inline", "", 0), { content: e.symbol, meta: an }), new o.Token("span_close", "span", -1));
  } else
    c.push(Object.assign(new o.Token("html_inline", "", 0), { content: e.symbol, meta: an }));
  e.style === "aria-label" ? l.push(["aria-label", e.assistiveText(a)]) : ["aria-describedby", "aria-labelledby"].includes(e.style) && l.push([e.style, n]);
  var p = [Object.assign(new o.Token("link_open", "a", 1), { attrs: l })].concat(c, [new o.Token("link_close", "a", -1)]);
  (s = o.tokens).splice.apply(s, [r + 3, 0].concat(p)), e.wrapper && (o.tokens.splice(r, 0, Object.assign(new o.Token("html_block", "", 0), { content: e.wrapper[0] + `
` })), o.tokens.splice(r + 3 + p.length + 1, 0, Object.assign(new o.Token("html_block", "", 0), { content: e.wrapper[1] + `
` })));
});
function Qt(n, e, t, o) {
  var r = n, s = o;
  if (t && Object.prototype.hasOwnProperty.call(e, r))
    throw new Error("User defined `id` attribute `" + n + "` is not unique. Please fix it in your Markdown to continue.");
  for (; Object.prototype.hasOwnProperty.call(e, r); )
    r = n + "-" + s, s += 1;
  return e[r] = !0, r;
}
function Ee(n, e) {
  e = Object.assign({}, Ee.defaults, e), n.core.ruler.push("anchor", function(t) {
    for (var o, r = {}, s = t.tokens, a = Array.isArray(e.level) ? (o = e.level, function(h) {
      return o.includes(h);
    }) : function(h) {
      return function(d) {
        return d >= h;
      };
    }(e.level), c = 0; c < s.length; c++) {
      var l = s[c];
      if (l.type === "heading_open" && a(Number(l.tag.substr(1)))) {
        var i = e.getTokensText(s[c + 1].children), p = l.attrGet("id");
        p = p == null ? Qt(e.slugify(i), r, !1, e.uniqueSlugStartIndex) : Qt(p, r, !0, e.uniqueSlugStartIndex), l.attrSet("id", p), e.tabIndex !== !1 && l.attrSet("tabindex", "" + e.tabIndex), typeof e.permalink == "function" ? e.permalink(p, e, t, c) : (e.permalink || e.renderPermalink && e.renderPermalink !== Vn) && e.renderPermalink(p, e, t, c), c = s.indexOf(l), e.callback && e.callback(l, { slug: p, title: i });
      }
    }
  });
}
Object.assign(Jt.defaults, { style: "visually-hidden", space: !0, placement: "after", wrapper: null }), Ee.permalink = { __proto__: null, legacy: Vn, renderHref: Po, renderAttrs: Io, makePermalink: Ke, linkInsideHeader: yn, ariaHidden: Se, headerLink: Oo, linkAfterHeader: Jt }, Ee.defaults = { level: 1, slugify: function(n) {
  return encodeURIComponent(String(n).trim().toLowerCase().replace(/\s+/g, "-"));
}, uniqueSlugStartIndex: 1, tabIndex: "-1", getTokensText: function(n) {
  return n.filter(function(e) {
    return ["text", "code_inline"].includes(e.type);
  }).map(function(e) {
    return e.content;
  }).join("");
}, permalink: !1, renderPermalink: Vn, permalinkClass: Se.defaults.class, permalinkSpace: Se.defaults.space, permalinkSymbol: "¶", permalinkBefore: Se.defaults.placement === "before", permalinkHref: Se.defaults.renderHref, permalinkAttrs: Se.defaults.renderAttrs }, Ee.default = Ee;
var be = {};
be.getAttrs = function(n, e, t) {
  const o = /[^\t\n\f />"'=]/, r = " ", s = "=", a = ".", c = "#", l = [];
  let i = "", p = "", h = !0, d = !1;
  for (let f = e + t.leftDelimiter.length; f < n.length; f++) {
    if (n.slice(f, f + t.rightDelimiter.length) === t.rightDelimiter) {
      i !== "" && l.push([i, p]);
      break;
    }
    const m = n.charAt(f);
    if (m === s && h) {
      h = !1;
      continue;
    }
    if (m === a && i === "") {
      n.charAt(f + 1) === a ? (i = "css-module", f += 1) : i = "class", h = !1;
      continue;
    }
    if (m === c && i === "") {
      i = "id", h = !1;
      continue;
    }
    if (m === '"' && p === "" && !d) {
      d = !0;
      continue;
    }
    if (m === '"' && d) {
      d = !1;
      continue;
    }
    if (m === r && !d) {
      if (i === "")
        continue;
      l.push([i, p]), i = "", p = "", h = !0;
      continue;
    }
    if (!(h && m.search(o) === -1)) {
      if (h) {
        i += m;
        continue;
      }
      p += m;
    }
  }
  if (t.allowedAttributes && t.allowedAttributes.length) {
    const f = t.allowedAttributes;
    return l.filter(function(m) {
      const S = m[0];
      function L(_) {
        return S === _ || _ instanceof RegExp && _.test(S);
      }
      return f.some(L);
    });
  }
  return l;
};
be.addAttrs = function(n, e) {
  for (let t = 0, o = n.length; t < o; ++t) {
    const r = n[t][0];
    r === "class" ? e.attrJoin("class", n[t][1]) : r === "css-module" ? e.attrJoin("css-module", n[t][1]) : e.attrPush(n[t]);
  }
  return e;
};
be.hasDelimiters = function(n, e) {
  if (!n)
    throw new Error('Parameter `where` not passed. Should be "start", "end" or "only".');
  return function(t) {
    const o = e.leftDelimiter.length + 1 + e.rightDelimiter.length;
    if (!t || typeof t != "string" || t.length < o)
      return !1;
    function r(p) {
      const h = p.charAt(e.leftDelimiter.length) === ".", d = p.charAt(e.leftDelimiter.length) === "#";
      return h || d ? p.length >= o + 1 : p.length >= o;
    }
    let s, a, c, l;
    const i = o - e.rightDelimiter.length;
    switch (n) {
      case "start":
        c = t.slice(0, e.leftDelimiter.length), s = c === e.leftDelimiter ? 0 : -1, a = s === -1 ? -1 : t.indexOf(e.rightDelimiter, i), l = t.charAt(a + e.rightDelimiter.length), l && e.rightDelimiter.indexOf(l) !== -1 && (a = -1);
        break;
      case "end":
        s = t.lastIndexOf(e.leftDelimiter), a = s === -1 ? -1 : t.indexOf(e.rightDelimiter, s + i), a = a === t.length - e.rightDelimiter.length ? a : -1;
        break;
      case "only":
        c = t.slice(0, e.leftDelimiter.length), s = c === e.leftDelimiter ? 0 : -1, c = t.slice(t.length - e.rightDelimiter.length), a = c === e.rightDelimiter ? t.length - e.rightDelimiter.length : -1;
        break;
      default:
        throw new Error(`Unexpected case ${n}, expected 'start', 'end' or 'only'`);
    }
    return s !== -1 && a !== -1 && r(t.substring(s, a + e.rightDelimiter.length));
  };
};
be.removeDelimiter = function(n, e) {
  const t = Wn(e.leftDelimiter), o = Wn(e.rightDelimiter), r = new RegExp(
    "[ \\n]?" + t + "[^" + t + o + "]+" + o + "$"
  ), s = n.search(r);
  return s !== -1 ? n.slice(0, s) : n;
};
function Wn(n) {
  return n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
be.escapeRegExp = Wn;
be.getMatchingOpeningToken = function(n, e) {
  if (n[e].type === "softbreak")
    return !1;
  if (n[e].nesting === 0)
    return n[e];
  const t = n[e].level, o = n[e].type.replace("_close", "_open");
  for (; e >= 0; --e)
    if (n[e].type === o && n[e].level === t)
      return n[e];
  return !1;
};
const S$ = /[&<>"]/, L$ = /[&<>"]/g, E$ = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function C$(n) {
  return E$[n];
}
be.escapeHtml = function(n) {
  return S$.test(n) ? n.replace(L$, C$) : n;
};
const I = be;
var T$ = (n) => {
  const e = new RegExp("^ {0,3}[-*_]{3,} ?" + I.escapeRegExp(n.leftDelimiter) + "[^" + I.escapeRegExp(n.rightDelimiter) + "]");
  return [
    {
      /**
       * ```python {.cls}
       * for i in range(10):
       *     print(i)
       * ```
       */
      name: "fenced code blocks",
      tests: [
        {
          shift: 0,
          block: !0,
          info: I.hasDelimiters("end", n)
        }
      ],
      transform: (t, o) => {
        const r = t[o], s = r.info.lastIndexOf(n.leftDelimiter), a = I.getAttrs(r.info, s, n);
        I.addAttrs(a, r), r.info = I.removeDelimiter(r.info, n);
      }
    },
    {
      /**
       * bla `click()`{.c} ![](img.png){.d}
       *
       * differs from 'inline attributes' as it does
       * not have a closing tag (nesting: -1)
       */
      name: "inline nesting 0",
      tests: [
        {
          shift: 0,
          type: "inline",
          children: [
            {
              shift: -1,
              type: (t) => t === "image" || t === "code_inline"
            },
            {
              shift: 0,
              type: "text",
              content: I.hasDelimiters("start", n)
            }
          ]
        }
      ],
      transform: (t, o, r) => {
        const s = t[o].children[r], a = s.content.indexOf(n.rightDelimiter), c = t[o].children[r - 1], l = I.getAttrs(s.content, 0, n);
        I.addAttrs(l, c), s.content.length === a + n.rightDelimiter.length ? t[o].children.splice(r, 1) : s.content = s.content.slice(a + n.rightDelimiter.length);
      }
    },
    {
      /**
       * | h1 |
       * | -- |
       * | c1 |
       *
       * {.c}
       */
      name: "tables",
      tests: [
        {
          // let this token be i, such that for-loop continues at
          // next token after tokens.splice
          shift: 0,
          type: "table_close"
        },
        {
          shift: 1,
          type: "paragraph_open"
        },
        {
          shift: 2,
          type: "inline",
          content: I.hasDelimiters("only", n)
        }
      ],
      transform: (t, o) => {
        const r = t[o + 2], s = I.getMatchingOpeningToken(t, o), a = I.getAttrs(r.content, 0, n);
        I.addAttrs(a, s), t.splice(o + 1, 3);
      }
    },
    {
      /**
       * *emphasis*{.with attrs=1}
       */
      name: "inline attributes",
      tests: [
        {
          shift: 0,
          type: "inline",
          children: [
            {
              shift: -1,
              nesting: -1
              // closing inline tag, </em>{.a}
            },
            {
              shift: 0,
              type: "text",
              content: I.hasDelimiters("start", n)
            }
          ]
        }
      ],
      transform: (t, o, r) => {
        const s = t[o].children[r], a = s.content, c = I.getAttrs(a, 0, n), l = I.getMatchingOpeningToken(t[o].children, r - 1);
        I.addAttrs(c, l), s.content = a.slice(a.indexOf(n.rightDelimiter) + n.rightDelimiter.length);
      }
    },
    {
      /**
       * - item
       * {.a}
       */
      name: "list softbreak",
      tests: [
        {
          shift: -2,
          type: "list_item_open"
        },
        {
          shift: 0,
          type: "inline",
          children: [
            {
              position: -2,
              type: "softbreak"
            },
            {
              position: -1,
              type: "text",
              content: I.hasDelimiters("only", n)
            }
          ]
        }
      ],
      transform: (t, o, r) => {
        const a = t[o].children[r].content, c = I.getAttrs(a, 0, n);
        let l = o - 2;
        for (; t[l - 1] && t[l - 1].type !== "ordered_list_open" && t[l - 1].type !== "bullet_list_open"; )
          l--;
        I.addAttrs(c, t[l - 1]), t[o].children = t[o].children.slice(0, -2);
      }
    },
    {
      /**
       * - nested list
       *   - with double \n
       *   {.a} <-- apply to nested ul
       *
       * {.b} <-- apply to root <ul>
       */
      name: "list double softbreak",
      tests: [
        {
          // let this token be i = 0 so that we can erase
          // the <p>{.a}</p> tokens below
          shift: 0,
          type: (t) => t === "bullet_list_close" || t === "ordered_list_close"
        },
        {
          shift: 1,
          type: "paragraph_open"
        },
        {
          shift: 2,
          type: "inline",
          content: I.hasDelimiters("only", n),
          children: (t) => t.length === 1
        },
        {
          shift: 3,
          type: "paragraph_close"
        }
      ],
      transform: (t, o) => {
        const s = t[o + 2].content, a = I.getAttrs(s, 0, n), c = I.getMatchingOpeningToken(t, o);
        I.addAttrs(a, c), t.splice(o + 1, 3);
      }
    },
    {
      /**
       * - end of {.list-item}
       */
      name: "list item end",
      tests: [
        {
          shift: -2,
          type: "list_item_open"
        },
        {
          shift: 0,
          type: "inline",
          children: [
            {
              position: -1,
              type: "text",
              content: I.hasDelimiters("end", n)
            }
          ]
        }
      ],
      transform: (t, o, r) => {
        const s = t[o].children[r], a = s.content, c = I.getAttrs(a, a.lastIndexOf(n.leftDelimiter), n);
        I.addAttrs(c, t[o - 2]);
        const l = a.slice(0, a.lastIndexOf(n.leftDelimiter));
        s.content = Yt(l) !== " " ? l : l.slice(0, -1);
      }
    },
    {
      /**
       * something with softbreak
       * {.cls}
       */
      name: `
{.a} softbreak then curly in start`,
      tests: [
        {
          shift: 0,
          type: "inline",
          children: [
            {
              position: -2,
              type: "softbreak"
            },
            {
              position: -1,
              type: "text",
              content: I.hasDelimiters("only", n)
            }
          ]
        }
      ],
      transform: (t, o, r) => {
        const s = t[o].children[r], a = I.getAttrs(s.content, 0, n);
        let c = o + 1;
        for (; t[c + 1] && t[c + 1].nesting === -1; )
          c++;
        const l = I.getMatchingOpeningToken(t, c);
        I.addAttrs(a, l), t[o].children = t[o].children.slice(0, -2);
      }
    },
    {
      /**
       * horizontal rule --- {#id}
       */
      name: "horizontal rule",
      tests: [
        {
          shift: 0,
          type: "paragraph_open"
        },
        {
          shift: 1,
          type: "inline",
          children: (t) => t.length === 1,
          content: (t) => t.match(e) !== null
        },
        {
          shift: 2,
          type: "paragraph_close"
        }
      ],
      transform: (t, o) => {
        const r = t[o];
        r.type = "hr", r.tag = "hr", r.nesting = 0;
        const s = t[o + 1].content, a = s.lastIndexOf(n.leftDelimiter), c = I.getAttrs(s, a, n);
        I.addAttrs(c, r), r.markup = s, t.splice(o + 1, 2);
      }
    },
    {
      /**
       * end of {.block}
       */
      name: "end of block",
      tests: [
        {
          shift: 0,
          type: "inline",
          children: [
            {
              position: -1,
              content: I.hasDelimiters("end", n),
              type: (t) => t !== "code_inline" && t !== "math_inline"
            }
          ]
        }
      ],
      transform: (t, o, r) => {
        const s = t[o].children[r], a = s.content, c = I.getAttrs(a, a.lastIndexOf(n.leftDelimiter), n);
        let l = o + 1;
        for (; t[l + 1] && t[l + 1].nesting === -1; )
          l++;
        const i = I.getMatchingOpeningToken(t, l);
        I.addAttrs(c, i);
        const p = a.slice(0, a.lastIndexOf(n.leftDelimiter));
        s.content = Yt(p) !== " " ? p : p.slice(0, -1);
      }
    }
  ];
};
function Yt(n) {
  return n.slice(-1)[0];
}
const D$ = T$, q$ = {
  leftDelimiter: "{",
  rightDelimiter: "}",
  allowedAttributes: []
};
var j$ = function(e, t) {
  let o = Object.assign({}, q$);
  o = Object.assign(o, t);
  const r = D$(o);
  function s(a) {
    const c = a.tokens;
    for (let l = 0; l < c.length; l++)
      for (let i = 0; i < r.length; i++) {
        const p = r[i];
        let h = null;
        p.tests.every((f) => {
          const m = Zn(c, l, f);
          return m.j !== null && (h = m.j), m.match;
        }) && (p.transform(c, l, h), (p.name === "inline attributes" || p.name === "inline nesting 0") && i--);
      }
  }
  e.core.ruler.before("linkify", "curly_attributes", s);
};
function Zn(n, e, t) {
  const o = {
    match: !1,
    j: null
    // position of child
  }, r = t.shift !== void 0 ? e + t.shift : t.position;
  if (t.shift !== void 0 && r < 0)
    return o;
  const s = P$(n, r);
  if (s === void 0)
    return o;
  for (const a of Object.keys(t))
    if (!(a === "shift" || a === "position")) {
      if (s[a] === void 0)
        return o;
      if (a === "children" && R$(t.children)) {
        if (s.children.length === 0)
          return o;
        let c;
        const l = t.children, i = s.children;
        if (l.every((p) => p.position !== void 0)) {
          if (c = l.every((p) => Zn(i, p.position, p).match), c) {
            const p = I$(l).position;
            o.j = p >= 0 ? p : i.length + p;
          }
        } else
          for (let p = 0; p < i.length; p++)
            if (c = l.every((h) => Zn(i, p, h).match), c) {
              o.j = p;
              break;
            }
        if (c === !1)
          return o;
        continue;
      }
      switch (typeof t[a]) {
        case "boolean":
        case "number":
        case "string":
          if (s[a] !== t[a])
            return o;
          break;
        case "function":
          if (!t[a](s[a]))
            return o;
          break;
        case "object":
          if (N$(t[a])) {
            if (t[a].every((l) => l(s[a])) === !1)
              return o;
            break;
          }
        default:
          throw new Error(`Unknown type of pattern test (key: ${a}). Test should be of type boolean, number, string, function or array of functions.`);
      }
    }
  return o.match = !0, o;
}
function R$(n) {
  return Array.isArray(n) && n.length && n.every((e) => typeof e == "object");
}
function N$(n) {
  return Array.isArray(n) && n.length && n.every((e) => typeof e == "function");
}
function P$(n, e) {
  return e >= 0 ? n[e] : n[n.length + e];
}
function I$(n) {
  return n.slice(-1)[0] || {};
}
const O$ = "😀", F$ = "😃", M$ = "😄", B$ = "😁", z$ = "😆", $$ = "😆", G$ = "😅", U$ = "🤣", H$ = "😂", V$ = "🙂", W$ = "🙃", Z$ = "😉", J$ = "😊", Q$ = "😇", Y$ = "🥰", X$ = "😍", K$ = "🤩", e5 = "😘", n5 = "😗", t5 = "☺️", o5 = "😚", s5 = "😙", r5 = "🥲", c5 = "😋", a5 = "😛", i5 = "😜", l5 = "🤪", u5 = "😝", p5 = "🤑", h5 = "🤗", d5 = "🤭", f5 = "🤫", m5 = "🤔", g5 = "🤐", _5 = "🤨", b5 = "😐", k5 = "😑", w5 = "😶", y5 = "😏", v5 = "😒", x5 = "🙄", A5 = "😬", S5 = "🤥", L5 = "😌", E5 = "😔", C5 = "😪", T5 = "🤤", D5 = "😴", q5 = "😷", j5 = "🤒", R5 = "🤕", N5 = "🤢", P5 = "🤮", I5 = "🤧", O5 = "🥵", F5 = "🥶", M5 = "🥴", B5 = "😵", z5 = "🤯", $5 = "🤠", G5 = "🥳", U5 = "🥸", H5 = "😎", V5 = "🤓", W5 = "🧐", Z5 = "😕", J5 = "😟", Q5 = "🙁", Y5 = "☹️", X5 = "😮", K5 = "😯", e6 = "😲", n6 = "😳", t6 = "🥺", o6 = "😦", s6 = "😧", r6 = "😨", c6 = "😰", a6 = "😥", i6 = "😢", l6 = "😭", u6 = "😱", p6 = "😖", h6 = "😣", d6 = "😞", f6 = "😓", m6 = "😩", g6 = "😫", _6 = "🥱", b6 = "😤", k6 = "😡", w6 = "😡", y6 = "😠", v6 = "🤬", x6 = "😈", A6 = "👿", S6 = "💀", L6 = "☠️", E6 = "💩", C6 = "💩", T6 = "💩", D6 = "🤡", q6 = "👹", j6 = "👺", R6 = "👻", N6 = "👽", P6 = "👾", I6 = "🤖", O6 = "😺", F6 = "😸", M6 = "😹", B6 = "😻", z6 = "😼", $6 = "😽", G6 = "🙀", U6 = "😿", H6 = "😾", V6 = "🙈", W6 = "🙉", Z6 = "🙊", J6 = "💋", Q6 = "💌", Y6 = "💘", X6 = "💝", K6 = "💖", e4 = "💗", n4 = "💓", t4 = "💞", o4 = "💕", s4 = "💟", r4 = "❣️", c4 = "💔", a4 = "❤️", i4 = "🧡", l4 = "💛", u4 = "💚", p4 = "💙", h4 = "💜", d4 = "🤎", f4 = "🖤", m4 = "🤍", g4 = "💢", _4 = "💥", b4 = "💥", k4 = "💫", w4 = "💦", y4 = "💨", v4 = "🕳️", x4 = "💣", A4 = "💬", S4 = "👁️‍🗨️", L4 = "🗨️", E4 = "🗯️", C4 = "💭", T4 = "💤", D4 = "👋", q4 = "🤚", j4 = "🖐️", R4 = "✋", N4 = "✋", P4 = "🖖", I4 = "👌", O4 = "🤌", F4 = "🤏", M4 = "✌️", B4 = "🤞", z4 = "🤟", $4 = "🤘", G4 = "🤙", U4 = "👈", H4 = "👉", V4 = "👆", W4 = "🖕", Z4 = "🖕", J4 = "👇", Q4 = "☝️", Y4 = "👍", X4 = "👎", K4 = "✊", e8 = "✊", n8 = "👊", t8 = "👊", o8 = "👊", s8 = "🤛", r8 = "🤜", c8 = "👏", a8 = "🙌", i8 = "👐", l8 = "🤲", u8 = "🤝", p8 = "🙏", h8 = "✍️", d8 = "💅", f8 = "🤳", m8 = "💪", g8 = "🦾", _8 = "🦿", b8 = "🦵", k8 = "🦶", w8 = "👂", y8 = "🦻", v8 = "👃", x8 = "🧠", A8 = "🫀", S8 = "🫁", L8 = "🦷", E8 = "🦴", C8 = "👀", T8 = "👁️", D8 = "👅", q8 = "👄", j8 = "👶", R8 = "🧒", N8 = "👦", P8 = "👧", I8 = "🧑", O8 = "👱", F8 = "👨", M8 = "🧔", B8 = "👨‍🦰", z8 = "👨‍🦱", $8 = "👨‍🦳", G8 = "👨‍🦲", U8 = "👩", H8 = "👩‍🦰", V8 = "🧑‍🦰", W8 = "👩‍🦱", Z8 = "🧑‍🦱", J8 = "👩‍🦳", Q8 = "🧑‍🦳", Y8 = "👩‍🦲", X8 = "🧑‍🦲", K8 = "👱‍♀️", eG = "👱‍♀️", nG = "👱‍♂️", tG = "🧓", oG = "👴", sG = "👵", rG = "🙍", cG = "🙍‍♂️", aG = "🙍‍♀️", iG = "🙎", lG = "🙎‍♂️", uG = "🙎‍♀️", pG = "🙅", hG = "🙅‍♂️", dG = "🙅‍♂️", fG = "🙅‍♀️", mG = "🙅‍♀️", gG = "🙆", _G = "🙆‍♂️", bG = "🙆‍♀️", kG = "💁", wG = "💁", yG = "💁‍♂️", vG = "💁‍♂️", xG = "💁‍♀️", AG = "💁‍♀️", SG = "🙋", LG = "🙋‍♂️", EG = "🙋‍♀️", CG = "🧏", TG = "🧏‍♂️", DG = "🧏‍♀️", qG = "🙇", jG = "🙇‍♂️", RG = "🙇‍♀️", NG = "🤦", PG = "🤦‍♂️", IG = "🤦‍♀️", OG = "🤷", FG = "🤷‍♂️", MG = "🤷‍♀️", BG = "🧑‍⚕️", zG = "👨‍⚕️", $G = "👩‍⚕️", GG = "🧑‍🎓", UG = "👨‍🎓", HG = "👩‍🎓", VG = "🧑‍🏫", WG = "👨‍🏫", ZG = "👩‍🏫", JG = "🧑‍⚖️", QG = "👨‍⚖️", YG = "👩‍⚖️", XG = "🧑‍🌾", KG = "👨‍🌾", eU = "👩‍🌾", nU = "🧑‍🍳", tU = "👨‍🍳", oU = "👩‍🍳", sU = "🧑‍🔧", rU = "👨‍🔧", cU = "👩‍🔧", aU = "🧑‍🏭", iU = "👨‍🏭", lU = "👩‍🏭", uU = "🧑‍💼", pU = "👨‍💼", hU = "👩‍💼", dU = "🧑‍🔬", fU = "👨‍🔬", mU = "👩‍🔬", gU = "🧑‍💻", _U = "👨‍💻", bU = "👩‍💻", kU = "🧑‍🎤", wU = "👨‍🎤", yU = "👩‍🎤", vU = "🧑‍🎨", xU = "👨‍🎨", AU = "👩‍🎨", SU = "🧑‍✈️", LU = "👨‍✈️", EU = "👩‍✈️", CU = "🧑‍🚀", TU = "👨‍🚀", DU = "👩‍🚀", qU = "🧑‍🚒", jU = "👨‍🚒", RU = "👩‍🚒", NU = "👮", PU = "👮", IU = "👮‍♂️", OU = "👮‍♀️", FU = "🕵️", MU = "🕵️‍♂️", BU = "🕵️‍♀️", zU = "💂", $U = "💂‍♂️", GU = "💂‍♀️", UU = "🥷", HU = "👷", VU = "👷‍♂️", WU = "👷‍♀️", ZU = "🤴", JU = "👸", QU = "👳", YU = "👳‍♂️", XU = "👳‍♀️", KU = "👲", e9 = "🧕", n9 = "🤵", t9 = "🤵‍♂️", o9 = "🤵‍♀️", s9 = "👰", r9 = "👰‍♂️", c9 = "👰‍♀️", a9 = "👰‍♀️", i9 = "🤰", l9 = "🤱", u9 = "👩‍🍼", p9 = "👨‍🍼", h9 = "🧑‍🍼", d9 = "👼", f9 = "🎅", m9 = "🤶", g9 = "🧑‍🎄", _9 = "🦸", b9 = "🦸‍♂️", k9 = "🦸‍♀️", w9 = "🦹", y9 = "🦹‍♂️", v9 = "🦹‍♀️", x9 = "🧙", A9 = "🧙‍♂️", S9 = "🧙‍♀️", L9 = "🧚", E9 = "🧚‍♂️", C9 = "🧚‍♀️", T9 = "🧛", D9 = "🧛‍♂️", q9 = "🧛‍♀️", j9 = "🧜", R9 = "🧜‍♂️", N9 = "🧜‍♀️", P9 = "🧝", I9 = "🧝‍♂️", O9 = "🧝‍♀️", F9 = "🧞", M9 = "🧞‍♂️", B9 = "🧞‍♀️", z9 = "🧟", $9 = "🧟‍♂️", G9 = "🧟‍♀️", U9 = "💆", H9 = "💆‍♂️", V9 = "💆‍♀️", W9 = "💇", Z9 = "💇‍♂️", J9 = "💇‍♀️", Q9 = "🚶", Y9 = "🚶‍♂️", X9 = "🚶‍♀️", K9 = "🧍", e7 = "🧍‍♂️", n7 = "🧍‍♀️", t7 = "🧎", o7 = "🧎‍♂️", s7 = "🧎‍♀️", r7 = "🧑‍🦯", c7 = "👨‍🦯", a7 = "👩‍🦯", i7 = "🧑‍🦼", l7 = "👨‍🦼", u7 = "👩‍🦼", p7 = "🧑‍🦽", h7 = "👨‍🦽", d7 = "👩‍🦽", f7 = "🏃", m7 = "🏃", g7 = "🏃‍♂️", _7 = "🏃‍♀️", b7 = "💃", k7 = "💃", w7 = "🕺", y7 = "🕴️", v7 = "👯", x7 = "👯‍♂️", A7 = "👯‍♀️", S7 = "🧖", L7 = "🧖‍♂️", E7 = "🧖‍♀️", C7 = "🧗", T7 = "🧗‍♂️", D7 = "🧗‍♀️", q7 = "🤺", j7 = "🏇", R7 = "⛷️", N7 = "🏂", P7 = "🏌️", I7 = "🏌️‍♂️", O7 = "🏌️‍♀️", F7 = "🏄", M7 = "🏄‍♂️", B7 = "🏄‍♀️", z7 = "🚣", $7 = "🚣‍♂️", G7 = "🚣‍♀️", U7 = "🏊", H7 = "🏊‍♂️", V7 = "🏊‍♀️", W7 = "⛹️", Z7 = "⛹️‍♂️", J7 = "⛹️‍♂️", Q7 = "⛹️‍♀️", Y7 = "⛹️‍♀️", X7 = "🏋️", K7 = "🏋️‍♂️", eH = "🏋️‍♀️", nH = "🚴", tH = "🚴‍♂️", oH = "🚴‍♀️", sH = "🚵", rH = "🚵‍♂️", cH = "🚵‍♀️", aH = "🤸", iH = "🤸‍♂️", lH = "🤸‍♀️", uH = "🤼", pH = "🤼‍♂️", hH = "🤼‍♀️", dH = "🤽", fH = "🤽‍♂️", mH = "🤽‍♀️", gH = "🤾", _H = "🤾‍♂️", bH = "🤾‍♀️", kH = "🤹", wH = "🤹‍♂️", yH = "🤹‍♀️", vH = "🧘", xH = "🧘‍♂️", AH = "🧘‍♀️", SH = "🛀", LH = "🛌", EH = "🧑‍🤝‍🧑", CH = "👭", TH = "👫", DH = "👬", qH = "💏", jH = "👩‍❤️‍💋‍👨", RH = "👨‍❤️‍💋‍👨", NH = "👩‍❤️‍💋‍👩", PH = "💑", IH = "👩‍❤️‍👨", OH = "👨‍❤️‍👨", FH = "👩‍❤️‍👩", MH = "👪", BH = "👨‍👩‍👦", zH = "👨‍👩‍👧", $H = "👨‍👩‍👧‍👦", GH = "👨‍👩‍👦‍👦", UH = "👨‍👩‍👧‍👧", HH = "👨‍👨‍👦", VH = "👨‍👨‍👧", WH = "👨‍👨‍👧‍👦", ZH = "👨‍👨‍👦‍👦", JH = "👨‍👨‍👧‍👧", QH = "👩‍👩‍👦", YH = "👩‍👩‍👧", XH = "👩‍👩‍👧‍👦", KH = "👩‍👩‍👦‍👦", eV = "👩‍👩‍👧‍👧", nV = "👨‍👦", tV = "👨‍👦‍👦", oV = "👨‍👧", sV = "👨‍👧‍👦", rV = "👨‍👧‍👧", cV = "👩‍👦", aV = "👩‍👦‍👦", iV = "👩‍👧", lV = "👩‍👧‍👦", uV = "👩‍👧‍👧", pV = "🗣️", hV = "👤", dV = "👥", fV = "🫂", mV = "👣", gV = "🐵", _V = "🐒", bV = "🦍", kV = "🦧", wV = "🐶", yV = "🐕", vV = "🦮", xV = "🐕‍🦺", AV = "🐩", SV = "🐺", LV = "🦊", EV = "🦝", CV = "🐱", TV = "🐈", DV = "🐈‍⬛", qV = "🦁", jV = "🐯", RV = "🐅", NV = "🐆", PV = "🐴", IV = "🐎", OV = "🦄", FV = "🦓", MV = "🦌", BV = "🦬", zV = "🐮", $V = "🐂", GV = "🐃", UV = "🐄", HV = "🐷", VV = "🐖", WV = "🐗", ZV = "🐽", JV = "🐏", QV = "🐑", YV = "🐐", XV = "🐪", KV = "🐫", eW = "🦙", nW = "🦒", tW = "🐘", oW = "🦣", sW = "🦏", rW = "🦛", cW = "🐭", aW = "🐁", iW = "🐀", lW = "🐹", uW = "🐰", pW = "🐇", hW = "🐿️", dW = "🦫", fW = "🦔", mW = "🦇", gW = "🐻", _W = "🐻‍❄️", bW = "🐨", kW = "🐼", wW = "🦥", yW = "🦦", vW = "🦨", xW = "🦘", AW = "🦡", SW = "🐾", LW = "🐾", EW = "🦃", CW = "🐔", TW = "🐓", DW = "🐣", qW = "🐤", jW = "🐥", RW = "🐦", NW = "🐧", PW = "🕊️", IW = "🦅", OW = "🦆", FW = "🦢", MW = "🦉", BW = "🦤", zW = "🪶", $W = "🦩", GW = "🦚", UW = "🦜", HW = "🐸", VW = "🐊", WW = "🐢", ZW = "🦎", JW = "🐍", QW = "🐲", YW = "🐉", XW = "🦕", KW = "🐳", eZ = "🐋", nZ = "🐬", tZ = "🐬", oZ = "🦭", sZ = "🐟", rZ = "🐠", cZ = "🐡", aZ = "🦈", iZ = "🐙", lZ = "🐚", uZ = "🐌", pZ = "🦋", hZ = "🐛", dZ = "🐜", fZ = "🐝", mZ = "🐝", gZ = "🪲", _Z = "🐞", bZ = "🦗", kZ = "🪳", wZ = "🕷️", yZ = "🕸️", vZ = "🦂", xZ = "🦟", AZ = "🪰", SZ = "🪱", LZ = "🦠", EZ = "💐", CZ = "🌸", TZ = "💮", DZ = "🏵️", qZ = "🌹", jZ = "🥀", RZ = "🌺", NZ = "🌻", PZ = "🌼", IZ = "🌷", OZ = "🌱", FZ = "🪴", MZ = "🌲", BZ = "🌳", zZ = "🌴", $Z = "🌵", GZ = "🌾", UZ = "🌿", HZ = "☘️", VZ = "🍀", WZ = "🍁", ZZ = "🍂", JZ = "🍃", QZ = "🍇", YZ = "🍈", XZ = "🍉", KZ = "🍊", eJ = "🍊", nJ = "🍊", tJ = "🍋", oJ = "🍌", sJ = "🍍", rJ = "🥭", cJ = "🍎", aJ = "🍏", iJ = "🍐", lJ = "🍑", uJ = "🍒", pJ = "🍓", hJ = "🫐", dJ = "🥝", fJ = "🍅", mJ = "🫒", gJ = "🥥", _J = "🥑", bJ = "🍆", kJ = "🥔", wJ = "🥕", yJ = "🌽", vJ = "🌶️", xJ = "🫑", AJ = "🥒", SJ = "🥬", LJ = "🥦", EJ = "🧄", CJ = "🧅", TJ = "🍄", DJ = "🥜", qJ = "🌰", jJ = "🍞", RJ = "🥐", NJ = "🥖", PJ = "🫓", IJ = "🥨", OJ = "🥯", FJ = "🥞", MJ = "🧇", BJ = "🧀", zJ = "🍖", $J = "🍗", GJ = "🥩", UJ = "🥓", HJ = "🍔", VJ = "🍟", WJ = "🍕", ZJ = "🌭", JJ = "🥪", QJ = "🌮", YJ = "🌯", XJ = "🫔", KJ = "🥙", eQ = "🧆", nQ = "🥚", tQ = "🍳", oQ = "🥘", sQ = "🍲", rQ = "🫕", cQ = "🥣", aQ = "🥗", iQ = "🍿", lQ = "🧈", uQ = "🧂", pQ = "🥫", hQ = "🍱", dQ = "🍘", fQ = "🍙", mQ = "🍚", gQ = "🍛", _Q = "🍜", bQ = "🍝", kQ = "🍠", wQ = "🍢", yQ = "🍣", vQ = "🍤", xQ = "🍥", AQ = "🥮", SQ = "🍡", LQ = "🥟", EQ = "🥠", CQ = "🥡", TQ = "🦀", DQ = "🦞", qQ = "🦐", jQ = "🦑", RQ = "🦪", NQ = "🍦", PQ = "🍧", IQ = "🍨", OQ = "🍩", FQ = "🍪", MQ = "🎂", BQ = "🍰", zQ = "🧁", $Q = "🥧", GQ = "🍫", UQ = "🍬", HQ = "🍭", VQ = "🍮", WQ = "🍯", ZQ = "🍼", JQ = "🥛", QQ = "☕", YQ = "🫖", XQ = "🍵", KQ = "🍶", eY = "🍾", nY = "🍷", tY = "🍸", oY = "🍹", sY = "🍺", rY = "🍻", cY = "🥂", aY = "🥃", iY = "🥤", lY = "🧋", uY = "🧃", pY = "🧉", hY = "🧊", dY = "🥢", fY = "🍽️", mY = "🍴", gY = "🥄", _Y = "🔪", bY = "🔪", kY = "🏺", wY = "🌍", yY = "🌎", vY = "🌏", xY = "🌐", AY = "🗺️", SY = "🗾", LY = "🧭", EY = "🏔️", CY = "⛰️", TY = "🌋", DY = "🗻", qY = "🏕️", jY = "🏖️", RY = "🏜️", NY = "🏝️", PY = "🏞️", IY = "🏟️", OY = "🏛️", FY = "🏗️", MY = "🧱", BY = "🪨", zY = "🪵", $Y = "🛖", GY = "🏘️", UY = "🏚️", HY = "🏠", VY = "🏡", WY = "🏢", ZY = "🏣", JY = "🏤", QY = "🏥", YY = "🏦", XY = "🏨", KY = "🏩", eX = "🏪", nX = "🏫", tX = "🏬", oX = "🏭", sX = "🏯", rX = "🏰", cX = "💒", aX = "🗼", iX = "🗽", lX = "⛪", uX = "🕌", pX = "🛕", hX = "🕍", dX = "⛩️", fX = "🕋", mX = "⛲", gX = "⛺", _X = "🌁", bX = "🌃", kX = "🏙️", wX = "🌄", yX = "🌅", vX = "🌆", xX = "🌇", AX = "🌉", SX = "♨️", LX = "🎠", EX = "🎡", CX = "🎢", TX = "💈", DX = "🎪", qX = "🚂", jX = "🚃", RX = "🚄", NX = "🚅", PX = "🚆", IX = "🚇", OX = "🚈", FX = "🚉", MX = "🚊", BX = "🚝", zX = "🚞", $X = "🚋", GX = "🚌", UX = "🚍", HX = "🚎", VX = "🚐", WX = "🚑", ZX = "🚒", JX = "🚓", QX = "🚔", YX = "🚕", XX = "🚖", KX = "🚗", eK = "🚗", nK = "🚘", tK = "🚙", oK = "🛻", sK = "🚚", rK = "🚛", cK = "🚜", aK = "🏎️", iK = "🏍️", lK = "🛵", uK = "🦽", pK = "🦼", hK = "🛺", dK = "🚲", fK = "🛴", mK = "🛹", gK = "🛼", _K = "🚏", bK = "🛣️", kK = "🛤️", wK = "🛢️", yK = "⛽", vK = "🚨", xK = "🚥", AK = "🚦", SK = "🛑", LK = "🚧", EK = "⚓", CK = "⛵", TK = "⛵", DK = "🛶", qK = "🚤", jK = "🛳️", RK = "⛴️", NK = "🛥️", PK = "🚢", IK = "✈️", OK = "🛩️", FK = "🛫", MK = "🛬", BK = "🪂", zK = "💺", $K = "🚁", GK = "🚟", UK = "🚠", HK = "🚡", VK = "🛰️", WK = "🚀", ZK = "🛸", JK = "🛎️", QK = "🧳", YK = "⌛", XK = "⏳", KK = "⌚", eee = "⏰", nee = "⏱️", tee = "⏲️", oee = "🕰️", see = "🕛", ree = "🕧", cee = "🕐", aee = "🕜", iee = "🕑", lee = "🕝", uee = "🕒", pee = "🕞", hee = "🕓", dee = "🕟", fee = "🕔", mee = "🕠", gee = "🕕", _ee = "🕡", bee = "🕖", kee = "🕢", wee = "🕗", yee = "🕣", vee = "🕘", xee = "🕤", Aee = "🕙", See = "🕥", Lee = "🕚", Eee = "🕦", Cee = "🌑", Tee = "🌒", Dee = "🌓", qee = "🌔", jee = "🌔", Ree = "🌕", Nee = "🌖", Pee = "🌗", Iee = "🌘", Oee = "🌙", Fee = "🌚", Mee = "🌛", Bee = "🌜", zee = "🌡️", $ee = "☀️", Gee = "🌝", Uee = "🌞", Hee = "🪐", Vee = "⭐", Wee = "🌟", Zee = "🌠", Jee = "🌌", Qee = "☁️", Yee = "⛅", Xee = "⛈️", Kee = "🌤️", ene = "🌥️", nne = "🌦️", tne = "🌧️", one = "🌨️", sne = "🌩️", rne = "🌪️", cne = "🌫️", ane = "🌬️", ine = "🌀", lne = "🌈", une = "🌂", pne = "☂️", hne = "☔", dne = "⛱️", fne = "⚡", mne = "❄️", gne = "☃️", _ne = "⛄", bne = "☄️", kne = "🔥", wne = "💧", yne = "🌊", vne = "🎃", xne = "🎄", Ane = "🎆", Sne = "🎇", Lne = "🧨", Ene = "✨", Cne = "🎈", Tne = "🎉", Dne = "🎊", qne = "🎋", jne = "🎍", Rne = "🎎", Nne = "🎏", Pne = "🎐", Ine = "🎑", One = "🧧", Fne = "🎀", Mne = "🎁", Bne = "🎗️", zne = "🎟️", $ne = "🎫", Gne = "🎖️", Une = "🏆", Hne = "🏅", Vne = "⚽", Wne = "⚾", Zne = "🥎", Jne = "🏀", Qne = "🏐", Yne = "🏈", Xne = "🏉", Kne = "🎾", ete = "🥏", nte = "🎳", tte = "🏏", ote = "🏑", ste = "🏒", rte = "🥍", cte = "🏓", ate = "🏸", ite = "🥊", lte = "🥋", ute = "🥅", pte = "⛳", hte = "⛸️", dte = "🎣", fte = "🤿", mte = "🎽", gte = "🎿", _te = "🛷", bte = "🥌", kte = "🎯", wte = "🪀", yte = "🪁", vte = "🔮", xte = "🪄", Ate = "🧿", Ste = "🎮", Lte = "🕹️", Ete = "🎰", Cte = "🎲", Tte = "🧩", Dte = "🧸", qte = "🪅", jte = "🪆", Rte = "♠️", Nte = "♥️", Pte = "♦️", Ite = "♣️", Ote = "♟️", Fte = "🃏", Mte = "🀄", Bte = "🎴", zte = "🎭", $te = "🖼️", Gte = "🎨", Ute = "🧵", Hte = "🪡", Vte = "🧶", Wte = "🪢", Zte = "👓", Jte = "🕶️", Qte = "🥽", Yte = "🥼", Xte = "🦺", Kte = "👔", eoe = "👕", noe = "👕", toe = "👖", ooe = "🧣", soe = "🧤", roe = "🧥", coe = "🧦", aoe = "👗", ioe = "👘", loe = "🥻", uoe = "🩱", poe = "🩲", hoe = "🩳", doe = "👙", foe = "👚", moe = "👛", goe = "👜", _oe = "👝", boe = "🛍️", koe = "🎒", woe = "🩴", yoe = "👞", voe = "👞", xoe = "👟", Aoe = "🥾", Soe = "🥿", Loe = "👠", Eoe = "👡", Coe = "🩰", Toe = "👢", Doe = "👑", qoe = "👒", joe = "🎩", Roe = "🎓", Noe = "🧢", Poe = "🪖", Ioe = "⛑️", Ooe = "📿", Foe = "💄", Moe = "💍", Boe = "💎", zoe = "🔇", $oe = "🔈", Goe = "🔉", Uoe = "🔊", Hoe = "📢", Voe = "📣", Woe = "📯", Zoe = "🔔", Joe = "🔕", Qoe = "🎼", Yoe = "🎵", Xoe = "🎶", Koe = "🎙️", ese = "🎚️", nse = "🎛️", tse = "🎤", ose = "🎧", sse = "📻", rse = "🎷", cse = "🪗", ase = "🎸", ise = "🎹", lse = "🎺", use = "🎻", pse = "🪕", hse = "🥁", dse = "🪘", fse = "📱", mse = "📲", gse = "☎️", _se = "☎️", bse = "📞", kse = "📟", wse = "📠", yse = "🔋", vse = "🔌", xse = "💻", Ase = "🖥️", Sse = "🖨️", Lse = "⌨️", Ese = "🖱️", Cse = "🖲️", Tse = "💽", Dse = "💾", qse = "💿", jse = "📀", Rse = "🧮", Nse = "🎥", Pse = "🎞️", Ise = "📽️", Ose = "🎬", Fse = "📺", Mse = "📷", Bse = "📸", zse = "📹", $se = "📼", Gse = "🔍", Use = "🔎", Hse = "🕯️", Vse = "💡", Wse = "🔦", Zse = "🏮", Jse = "🏮", Qse = "🪔", Yse = "📔", Xse = "📕", Kse = "📖", ere = "📖", nre = "📗", tre = "📘", ore = "📙", sre = "📚", rre = "📓", cre = "📒", are = "📃", ire = "📜", lre = "📄", ure = "📰", pre = "🗞️", hre = "📑", dre = "🔖", fre = "🏷️", mre = "💰", gre = "🪙", _re = "💴", bre = "💵", kre = "💶", wre = "💷", yre = "💸", vre = "💳", xre = "🧾", Are = "💹", Sre = "✉️", Lre = "📧", Ere = "📨", Cre = "📩", Tre = "📤", Dre = "📥", qre = "📫", jre = "📪", Rre = "📬", Nre = "📭", Pre = "📮", Ire = "🗳️", Ore = "✏️", Fre = "✒️", Mre = "🖋️", Bre = "🖊️", zre = "🖌️", $re = "🖍️", Gre = "📝", Ure = "📝", Hre = "💼", Vre = "📁", Wre = "📂", Zre = "🗂️", Jre = "📅", Qre = "📆", Yre = "🗒️", Xre = "🗓️", Kre = "📇", ece = "📈", nce = "📉", tce = "📊", oce = "📋", sce = "📌", rce = "📍", cce = "📎", ace = "🖇️", ice = "📏", lce = "📐", uce = "✂️", pce = "🗃️", hce = "🗄️", dce = "🗑️", fce = "🔒", mce = "🔓", gce = "🔏", _ce = "🔐", bce = "🔑", kce = "🗝️", wce = "🔨", yce = "🪓", vce = "⛏️", xce = "⚒️", Ace = "🛠️", Sce = "🗡️", Lce = "⚔️", Ece = "🔫", Cce = "🪃", Tce = "🏹", Dce = "🛡️", qce = "🪚", jce = "🔧", Rce = "🪛", Nce = "🔩", Pce = "⚙️", Ice = "🗜️", Oce = "⚖️", Fce = "🦯", Mce = "🔗", Bce = "⛓️", zce = "🪝", $ce = "🧰", Gce = "🧲", Uce = "🪜", Hce = "⚗️", Vce = "🧪", Wce = "🧫", Zce = "🧬", Jce = "🔬", Qce = "🔭", Yce = "📡", Xce = "💉", Kce = "🩸", eae = "💊", nae = "🩹", tae = "🩺", oae = "🚪", sae = "🛗", rae = "🪞", cae = "🪟", aae = "🛏️", iae = "🛋️", lae = "🪑", uae = "🚽", pae = "🪠", hae = "🚿", dae = "🛁", fae = "🪤", mae = "🪒", gae = "🧴", _ae = "🧷", bae = "🧹", kae = "🧺", wae = "🧻", yae = "🪣", vae = "🧼", xae = "🪥", Aae = "🧽", Sae = "🧯", Lae = "🛒", Eae = "🚬", Cae = "⚰️", Tae = "🪦", Dae = "⚱️", qae = "🗿", jae = "🪧", Rae = "🏧", Nae = "🚮", Pae = "🚰", Iae = "♿", Oae = "🚹", Fae = "🚺", Mae = "🚻", Bae = "🚼", zae = "🚾", $ae = "🛂", Gae = "🛃", Uae = "🛄", Hae = "🛅", Vae = "⚠️", Wae = "🚸", Zae = "⛔", Jae = "🚫", Qae = "🚳", Yae = "🚭", Xae = "🚯", Kae = "🚷", eie = "📵", nie = "🔞", tie = "☢️", oie = "☣️", sie = "⬆️", rie = "↗️", cie = "➡️", aie = "↘️", iie = "⬇️", lie = "↙️", uie = "⬅️", pie = "↖️", hie = "↕️", die = "↔️", fie = "↩️", mie = "↪️", gie = "⤴️", _ie = "⤵️", bie = "🔃", kie = "🔄", wie = "🔙", yie = "🔚", vie = "🔛", xie = "🔜", Aie = "🔝", Sie = "🛐", Lie = "⚛️", Eie = "🕉️", Cie = "✡️", Tie = "☸️", Die = "☯️", qie = "✝️", jie = "☦️", Rie = "☪️", Nie = "☮️", Pie = "🕎", Iie = "🔯", Oie = "♈", Fie = "♉", Mie = "♊", Bie = "♋", zie = "♌", $ie = "♍", Gie = "♎", Uie = "♏", Hie = "♐", Vie = "♑", Wie = "♒", Zie = "♓", Jie = "⛎", Qie = "🔀", Yie = "🔁", Xie = "🔂", Kie = "▶️", ele = "⏩", nle = "⏭️", tle = "⏯️", ole = "◀️", sle = "⏪", rle = "⏮️", cle = "🔼", ale = "⏫", ile = "🔽", lle = "⏬", ule = "⏸️", ple = "⏹️", hle = "⏺️", dle = "⏏️", fle = "🎦", mle = "🔅", gle = "🔆", _le = "📶", ble = "📳", kle = "📴", wle = "♀️", yle = "♂️", vle = "⚧️", xle = "✖️", Ale = "➕", Sle = "➖", Lle = "➗", Ele = "♾️", Cle = "‼️", Tle = "⁉️", Dle = "❓", qle = "❔", jle = "❕", Rle = "❗", Nle = "❗", Ple = "〰️", Ile = "💱", Ole = "💲", Fle = "⚕️", Mle = "♻️", Ble = "⚜️", zle = "🔱", $le = "📛", Gle = "🔰", Ule = "⭕", Hle = "✅", Vle = "☑️", Wle = "✔️", Zle = "❌", Jle = "❎", Qle = "➰", Yle = "➿", Xle = "〽️", Kle = "✳️", eue = "✴️", nue = "❇️", tue = "©️", oue = "®️", sue = "™️", rue = "#️⃣", cue = "*️⃣", aue = "0️⃣", iue = "1️⃣", lue = "2️⃣", uue = "3️⃣", pue = "4️⃣", hue = "5️⃣", due = "6️⃣", fue = "7️⃣", mue = "8️⃣", gue = "9️⃣", _ue = "🔟", bue = "🔠", kue = "🔡", wue = "🔣", yue = "🔤", vue = "🅰️", xue = "🆎", Aue = "🅱️", Sue = "🆑", Lue = "🆒", Eue = "🆓", Cue = "ℹ️", Tue = "🆔", Due = "Ⓜ️", que = "🆖", jue = "🅾️", Rue = "🆗", Nue = "🅿️", Pue = "🆘", Iue = "🆙", Oue = "🆚", Fue = "🈁", Mue = "🈂️", Bue = "🉐", zue = "🉑", $ue = "㊗️", Gue = "㊙️", Uue = "🈵", Hue = "🔴", Vue = "🟠", Wue = "🟡", Zue = "🟢", Jue = "🔵", Que = "🟣", Yue = "🟤", Xue = "⚫", Kue = "⚪", epe = "🟥", npe = "🟧", tpe = "🟨", ope = "🟩", spe = "🟦", rpe = "🟪", cpe = "🟫", ape = "⬛", ipe = "⬜", lpe = "◼️", upe = "◻️", ppe = "◾", hpe = "◽", dpe = "▪️", fpe = "▫️", mpe = "🔶", gpe = "🔷", _pe = "🔸", bpe = "🔹", kpe = "🔺", wpe = "🔻", ype = "💠", vpe = "🔘", xpe = "🔳", Ape = "🔲", Spe = "🏁", Lpe = "🚩", Epe = "🎌", Cpe = "🏴", Tpe = "🏳️", Dpe = "🏳️‍🌈", qpe = "🏳️‍⚧️", jpe = "🏴‍☠️", Rpe = "🇦🇨", Npe = "🇦🇩", Ppe = "🇦🇪", Ipe = "🇦🇫", Ope = "🇦🇬", Fpe = "🇦🇮", Mpe = "🇦🇱", Bpe = "🇦🇲", zpe = "🇦🇴", $pe = "🇦🇶", Gpe = "🇦🇷", Upe = "🇦🇸", Hpe = "🇦🇹", Vpe = "🇦🇺", Wpe = "🇦🇼", Zpe = "🇦🇽", Jpe = "🇦🇿", Qpe = "🇧🇦", Ype = "🇧🇧", Xpe = "🇧🇩", Kpe = "🇧🇪", ehe = "🇧🇫", nhe = "🇧🇬", the = "🇧🇭", ohe = "🇧🇮", she = "🇧🇯", rhe = "🇧🇱", che = "🇧🇲", ahe = "🇧🇳", ihe = "🇧🇴", lhe = "🇧🇶", uhe = "🇧🇷", phe = "🇧🇸", hhe = "🇧🇹", dhe = "🇧🇻", fhe = "🇧🇼", mhe = "🇧🇾", ghe = "🇧🇿", _he = "🇨🇦", bhe = "🇨🇨", khe = "🇨🇩", whe = "🇨🇫", yhe = "🇨🇬", vhe = "🇨🇭", xhe = "🇨🇮", Ahe = "🇨🇰", She = "🇨🇱", Lhe = "🇨🇲", Ehe = "🇨🇳", Che = "🇨🇴", The = "🇨🇵", Dhe = "🇨🇷", qhe = "🇨🇺", jhe = "🇨🇻", Rhe = "🇨🇼", Nhe = "🇨🇽", Phe = "🇨🇾", Ihe = "🇨🇿", Ohe = "🇩🇪", Fhe = "🇩🇬", Mhe = "🇩🇯", Bhe = "🇩🇰", zhe = "🇩🇲", $he = "🇩🇴", Ghe = "🇩🇿", Uhe = "🇪🇦", Hhe = "🇪🇨", Vhe = "🇪🇪", Whe = "🇪🇬", Zhe = "🇪🇭", Jhe = "🇪🇷", Qhe = "🇪🇸", Yhe = "🇪🇹", Xhe = "🇪🇺", Khe = "🇪🇺", ede = "🇫🇮", nde = "🇫🇯", tde = "🇫🇰", ode = "🇫🇲", sde = "🇫🇴", rde = "🇫🇷", cde = "🇬🇦", ade = "🇬🇧", ide = "🇬🇧", lde = "🇬🇩", ude = "🇬🇪", pde = "🇬🇫", hde = "🇬🇬", dde = "🇬🇭", fde = "🇬🇮", mde = "🇬🇱", gde = "🇬🇲", _de = "🇬🇳", bde = "🇬🇵", kde = "🇬🇶", wde = "🇬🇷", yde = "🇬🇸", vde = "🇬🇹", xde = "🇬🇺", Ade = "🇬🇼", Sde = "🇬🇾", Lde = "🇭🇰", Ede = "🇭🇲", Cde = "🇭🇳", Tde = "🇭🇷", Dde = "🇭🇹", qde = "🇭🇺", jde = "🇮🇨", Rde = "🇮🇩", Nde = "🇮🇪", Pde = "🇮🇱", Ide = "🇮🇲", Ode = "🇮🇳", Fde = "🇮🇴", Mde = "🇮🇶", Bde = "🇮🇷", zde = "🇮🇸", $de = "🇮🇹", Gde = "🇯🇪", Ude = "🇯🇲", Hde = "🇯🇴", Vde = "🇯🇵", Wde = "🇰🇪", Zde = "🇰🇬", Jde = "🇰🇭", Qde = "🇰🇮", Yde = "🇰🇲", Xde = "🇰🇳", Kde = "🇰🇵", efe = "🇰🇷", nfe = "🇰🇼", tfe = "🇰🇾", ofe = "🇰🇿", sfe = "🇱🇦", rfe = "🇱🇧", cfe = "🇱🇨", afe = "🇱🇮", ife = "🇱🇰", lfe = "🇱🇷", ufe = "🇱🇸", pfe = "🇱🇹", hfe = "🇱🇺", dfe = "🇱🇻", ffe = "🇱🇾", mfe = "🇲🇦", gfe = "🇲🇨", _fe = "🇲🇩", bfe = "🇲🇪", kfe = "🇲🇫", wfe = "🇲🇬", yfe = "🇲🇭", vfe = "🇲🇰", xfe = "🇲🇱", Afe = "🇲🇲", Sfe = "🇲🇳", Lfe = "🇲🇴", Efe = "🇲🇵", Cfe = "🇲🇶", Tfe = "🇲🇷", Dfe = "🇲🇸", qfe = "🇲🇹", jfe = "🇲🇺", Rfe = "🇲🇻", Nfe = "🇲🇼", Pfe = "🇲🇽", Ife = "🇲🇾", Ofe = "🇲🇿", Ffe = "🇳🇦", Mfe = "🇳🇨", Bfe = "🇳🇪", zfe = "🇳🇫", $fe = "🇳🇬", Gfe = "🇳🇮", Ufe = "🇳🇱", Hfe = "🇳🇴", Vfe = "🇳🇵", Wfe = "🇳🇷", Zfe = "🇳🇺", Jfe = "🇳🇿", Qfe = "🇴🇲", Yfe = "🇵🇦", Xfe = "🇵🇪", Kfe = "🇵🇫", eme = "🇵🇬", nme = "🇵🇭", tme = "🇵🇰", ome = "🇵🇱", sme = "🇵🇲", rme = "🇵🇳", cme = "🇵🇷", ame = "🇵🇸", ime = "🇵🇹", lme = "🇵🇼", ume = "🇵🇾", pme = "🇶🇦", hme = "🇷🇪", dme = "🇷🇴", fme = "🇷🇸", mme = "🇷🇺", gme = "🇷🇼", _me = "🇸🇦", bme = "🇸🇧", kme = "🇸🇨", wme = "🇸🇩", yme = "🇸🇪", vme = "🇸🇬", xme = "🇸🇭", Ame = "🇸🇮", Sme = "🇸🇯", Lme = "🇸🇰", Eme = "🇸🇱", Cme = "🇸🇲", Tme = "🇸🇳", Dme = "🇸🇴", qme = "🇸🇷", jme = "🇸🇸", Rme = "🇸🇹", Nme = "🇸🇻", Pme = "🇸🇽", Ime = "🇸🇾", Ome = "🇸🇿", Fme = "🇹🇦", Mme = "🇹🇨", Bme = "🇹🇩", zme = "🇹🇫", $me = "🇹🇬", Gme = "🇹🇭", Ume = "🇹🇯", Hme = "🇹🇰", Vme = "🇹🇱", Wme = "🇹🇲", Zme = "🇹🇳", Jme = "🇹🇴", Qme = "🇹🇷", Yme = "🇹🇹", Xme = "🇹🇻", Kme = "🇹🇼", ege = "🇹🇿", nge = "🇺🇦", tge = "🇺🇬", oge = "🇺🇲", sge = "🇺🇳", rge = "🇺🇸", cge = "🇺🇾", age = "🇺🇿", ige = "🇻🇦", lge = "🇻🇨", uge = "🇻🇪", pge = "🇻🇬", hge = "🇻🇮", dge = "🇻🇳", fge = "🇻🇺", mge = "🇼🇫", gge = "🇼🇸", _ge = "🇽🇰", bge = "🇾🇪", kge = "🇾🇹", wge = "🇿🇦", yge = "🇿🇲", vge = "🇿🇼", xge = "🏴󠁧󠁢󠁥󠁮󠁧󠁿", Age = "🏴󠁧󠁢󠁳󠁣󠁴󠁿", Sge = "🏴󠁧󠁢󠁷󠁬󠁳󠁿", Lge = {
  100: "💯",
  1234: "🔢",
  grinning: O$,
  smiley: F$,
  smile: M$,
  grin: B$,
  laughing: z$,
  satisfied: $$,
  sweat_smile: G$,
  rofl: U$,
  joy: H$,
  slightly_smiling_face: V$,
  upside_down_face: W$,
  wink: Z$,
  blush: J$,
  innocent: Q$,
  smiling_face_with_three_hearts: Y$,
  heart_eyes: X$,
  star_struck: K$,
  kissing_heart: e5,
  kissing: n5,
  relaxed: t5,
  kissing_closed_eyes: o5,
  kissing_smiling_eyes: s5,
  smiling_face_with_tear: r5,
  yum: c5,
  stuck_out_tongue: a5,
  stuck_out_tongue_winking_eye: i5,
  zany_face: l5,
  stuck_out_tongue_closed_eyes: u5,
  money_mouth_face: p5,
  hugs: h5,
  hand_over_mouth: d5,
  shushing_face: f5,
  thinking: m5,
  zipper_mouth_face: g5,
  raised_eyebrow: _5,
  neutral_face: b5,
  expressionless: k5,
  no_mouth: w5,
  smirk: y5,
  unamused: v5,
  roll_eyes: x5,
  grimacing: A5,
  lying_face: S5,
  relieved: L5,
  pensive: E5,
  sleepy: C5,
  drooling_face: T5,
  sleeping: D5,
  mask: q5,
  face_with_thermometer: j5,
  face_with_head_bandage: R5,
  nauseated_face: N5,
  vomiting_face: P5,
  sneezing_face: I5,
  hot_face: O5,
  cold_face: F5,
  woozy_face: M5,
  dizzy_face: B5,
  exploding_head: z5,
  cowboy_hat_face: $5,
  partying_face: G5,
  disguised_face: U5,
  sunglasses: H5,
  nerd_face: V5,
  monocle_face: W5,
  confused: Z5,
  worried: J5,
  slightly_frowning_face: Q5,
  frowning_face: Y5,
  open_mouth: X5,
  hushed: K5,
  astonished: e6,
  flushed: n6,
  pleading_face: t6,
  frowning: o6,
  anguished: s6,
  fearful: r6,
  cold_sweat: c6,
  disappointed_relieved: a6,
  cry: i6,
  sob: l6,
  scream: u6,
  confounded: p6,
  persevere: h6,
  disappointed: d6,
  sweat: f6,
  weary: m6,
  tired_face: g6,
  yawning_face: _6,
  triumph: b6,
  rage: k6,
  pout: w6,
  angry: y6,
  cursing_face: v6,
  smiling_imp: x6,
  imp: A6,
  skull: S6,
  skull_and_crossbones: L6,
  hankey: E6,
  poop: C6,
  shit: T6,
  clown_face: D6,
  japanese_ogre: q6,
  japanese_goblin: j6,
  ghost: R6,
  alien: N6,
  space_invader: P6,
  robot: I6,
  smiley_cat: O6,
  smile_cat: F6,
  joy_cat: M6,
  heart_eyes_cat: B6,
  smirk_cat: z6,
  kissing_cat: $6,
  scream_cat: G6,
  crying_cat_face: U6,
  pouting_cat: H6,
  see_no_evil: V6,
  hear_no_evil: W6,
  speak_no_evil: Z6,
  kiss: J6,
  love_letter: Q6,
  cupid: Y6,
  gift_heart: X6,
  sparkling_heart: K6,
  heartpulse: e4,
  heartbeat: n4,
  revolving_hearts: t4,
  two_hearts: o4,
  heart_decoration: s4,
  heavy_heart_exclamation: r4,
  broken_heart: c4,
  heart: a4,
  orange_heart: i4,
  yellow_heart: l4,
  green_heart: u4,
  blue_heart: p4,
  purple_heart: h4,
  brown_heart: d4,
  black_heart: f4,
  white_heart: m4,
  anger: g4,
  boom: _4,
  collision: b4,
  dizzy: k4,
  sweat_drops: w4,
  dash: y4,
  hole: v4,
  bomb: x4,
  speech_balloon: A4,
  eye_speech_bubble: S4,
  left_speech_bubble: L4,
  right_anger_bubble: E4,
  thought_balloon: C4,
  zzz: T4,
  wave: D4,
  raised_back_of_hand: q4,
  raised_hand_with_fingers_splayed: j4,
  hand: R4,
  raised_hand: N4,
  vulcan_salute: P4,
  ok_hand: I4,
  pinched_fingers: O4,
  pinching_hand: F4,
  v: M4,
  crossed_fingers: B4,
  love_you_gesture: z4,
  metal: $4,
  call_me_hand: G4,
  point_left: U4,
  point_right: H4,
  point_up_2: V4,
  middle_finger: W4,
  fu: Z4,
  point_down: J4,
  point_up: Q4,
  "+1": "👍",
  thumbsup: Y4,
  "-1": "👎",
  thumbsdown: X4,
  fist_raised: K4,
  fist: e8,
  fist_oncoming: n8,
  facepunch: t8,
  punch: o8,
  fist_left: s8,
  fist_right: r8,
  clap: c8,
  raised_hands: a8,
  open_hands: i8,
  palms_up_together: l8,
  handshake: u8,
  pray: p8,
  writing_hand: h8,
  nail_care: d8,
  selfie: f8,
  muscle: m8,
  mechanical_arm: g8,
  mechanical_leg: _8,
  leg: b8,
  foot: k8,
  ear: w8,
  ear_with_hearing_aid: y8,
  nose: v8,
  brain: x8,
  anatomical_heart: A8,
  lungs: S8,
  tooth: L8,
  bone: E8,
  eyes: C8,
  eye: T8,
  tongue: D8,
  lips: q8,
  baby: j8,
  child: R8,
  boy: N8,
  girl: P8,
  adult: I8,
  blond_haired_person: O8,
  man: F8,
  bearded_person: M8,
  red_haired_man: B8,
  curly_haired_man: z8,
  white_haired_man: $8,
  bald_man: G8,
  woman: U8,
  red_haired_woman: H8,
  person_red_hair: V8,
  curly_haired_woman: W8,
  person_curly_hair: Z8,
  white_haired_woman: J8,
  person_white_hair: Q8,
  bald_woman: Y8,
  person_bald: X8,
  blond_haired_woman: K8,
  blonde_woman: eG,
  blond_haired_man: nG,
  older_adult: tG,
  older_man: oG,
  older_woman: sG,
  frowning_person: rG,
  frowning_man: cG,
  frowning_woman: aG,
  pouting_face: iG,
  pouting_man: lG,
  pouting_woman: uG,
  no_good: pG,
  no_good_man: hG,
  ng_man: dG,
  no_good_woman: fG,
  ng_woman: mG,
  ok_person: gG,
  ok_man: _G,
  ok_woman: bG,
  tipping_hand_person: kG,
  information_desk_person: wG,
  tipping_hand_man: yG,
  sassy_man: vG,
  tipping_hand_woman: xG,
  sassy_woman: AG,
  raising_hand: SG,
  raising_hand_man: LG,
  raising_hand_woman: EG,
  deaf_person: CG,
  deaf_man: TG,
  deaf_woman: DG,
  bow: qG,
  bowing_man: jG,
  bowing_woman: RG,
  facepalm: NG,
  man_facepalming: PG,
  woman_facepalming: IG,
  shrug: OG,
  man_shrugging: FG,
  woman_shrugging: MG,
  health_worker: BG,
  man_health_worker: zG,
  woman_health_worker: $G,
  student: GG,
  man_student: UG,
  woman_student: HG,
  teacher: VG,
  man_teacher: WG,
  woman_teacher: ZG,
  judge: JG,
  man_judge: QG,
  woman_judge: YG,
  farmer: XG,
  man_farmer: KG,
  woman_farmer: eU,
  cook: nU,
  man_cook: tU,
  woman_cook: oU,
  mechanic: sU,
  man_mechanic: rU,
  woman_mechanic: cU,
  factory_worker: aU,
  man_factory_worker: iU,
  woman_factory_worker: lU,
  office_worker: uU,
  man_office_worker: pU,
  woman_office_worker: hU,
  scientist: dU,
  man_scientist: fU,
  woman_scientist: mU,
  technologist: gU,
  man_technologist: _U,
  woman_technologist: bU,
  singer: kU,
  man_singer: wU,
  woman_singer: yU,
  artist: vU,
  man_artist: xU,
  woman_artist: AU,
  pilot: SU,
  man_pilot: LU,
  woman_pilot: EU,
  astronaut: CU,
  man_astronaut: TU,
  woman_astronaut: DU,
  firefighter: qU,
  man_firefighter: jU,
  woman_firefighter: RU,
  police_officer: NU,
  cop: PU,
  policeman: IU,
  policewoman: OU,
  detective: FU,
  male_detective: MU,
  female_detective: BU,
  guard: zU,
  guardsman: $U,
  guardswoman: GU,
  ninja: UU,
  construction_worker: HU,
  construction_worker_man: VU,
  construction_worker_woman: WU,
  prince: ZU,
  princess: JU,
  person_with_turban: QU,
  man_with_turban: YU,
  woman_with_turban: XU,
  man_with_gua_pi_mao: KU,
  woman_with_headscarf: e9,
  person_in_tuxedo: n9,
  man_in_tuxedo: t9,
  woman_in_tuxedo: o9,
  person_with_veil: s9,
  man_with_veil: r9,
  woman_with_veil: c9,
  bride_with_veil: a9,
  pregnant_woman: i9,
  breast_feeding: l9,
  woman_feeding_baby: u9,
  man_feeding_baby: p9,
  person_feeding_baby: h9,
  angel: d9,
  santa: f9,
  mrs_claus: m9,
  mx_claus: g9,
  superhero: _9,
  superhero_man: b9,
  superhero_woman: k9,
  supervillain: w9,
  supervillain_man: y9,
  supervillain_woman: v9,
  mage: x9,
  mage_man: A9,
  mage_woman: S9,
  fairy: L9,
  fairy_man: E9,
  fairy_woman: C9,
  vampire: T9,
  vampire_man: D9,
  vampire_woman: q9,
  merperson: j9,
  merman: R9,
  mermaid: N9,
  elf: P9,
  elf_man: I9,
  elf_woman: O9,
  genie: F9,
  genie_man: M9,
  genie_woman: B9,
  zombie: z9,
  zombie_man: $9,
  zombie_woman: G9,
  massage: U9,
  massage_man: H9,
  massage_woman: V9,
  haircut: W9,
  haircut_man: Z9,
  haircut_woman: J9,
  walking: Q9,
  walking_man: Y9,
  walking_woman: X9,
  standing_person: K9,
  standing_man: e7,
  standing_woman: n7,
  kneeling_person: t7,
  kneeling_man: o7,
  kneeling_woman: s7,
  person_with_probing_cane: r7,
  man_with_probing_cane: c7,
  woman_with_probing_cane: a7,
  person_in_motorized_wheelchair: i7,
  man_in_motorized_wheelchair: l7,
  woman_in_motorized_wheelchair: u7,
  person_in_manual_wheelchair: p7,
  man_in_manual_wheelchair: h7,
  woman_in_manual_wheelchair: d7,
  runner: f7,
  running: m7,
  running_man: g7,
  running_woman: _7,
  woman_dancing: b7,
  dancer: k7,
  man_dancing: w7,
  business_suit_levitating: y7,
  dancers: v7,
  dancing_men: x7,
  dancing_women: A7,
  sauna_person: S7,
  sauna_man: L7,
  sauna_woman: E7,
  climbing: C7,
  climbing_man: T7,
  climbing_woman: D7,
  person_fencing: q7,
  horse_racing: j7,
  skier: R7,
  snowboarder: N7,
  golfing: P7,
  golfing_man: I7,
  golfing_woman: O7,
  surfer: F7,
  surfing_man: M7,
  surfing_woman: B7,
  rowboat: z7,
  rowing_man: $7,
  rowing_woman: G7,
  swimmer: U7,
  swimming_man: H7,
  swimming_woman: V7,
  bouncing_ball_person: W7,
  bouncing_ball_man: Z7,
  basketball_man: J7,
  bouncing_ball_woman: Q7,
  basketball_woman: Y7,
  weight_lifting: X7,
  weight_lifting_man: K7,
  weight_lifting_woman: eH,
  bicyclist: nH,
  biking_man: tH,
  biking_woman: oH,
  mountain_bicyclist: sH,
  mountain_biking_man: rH,
  mountain_biking_woman: cH,
  cartwheeling: aH,
  man_cartwheeling: iH,
  woman_cartwheeling: lH,
  wrestling: uH,
  men_wrestling: pH,
  women_wrestling: hH,
  water_polo: dH,
  man_playing_water_polo: fH,
  woman_playing_water_polo: mH,
  handball_person: gH,
  man_playing_handball: _H,
  woman_playing_handball: bH,
  juggling_person: kH,
  man_juggling: wH,
  woman_juggling: yH,
  lotus_position: vH,
  lotus_position_man: xH,
  lotus_position_woman: AH,
  bath: SH,
  sleeping_bed: LH,
  people_holding_hands: EH,
  two_women_holding_hands: CH,
  couple: TH,
  two_men_holding_hands: DH,
  couplekiss: qH,
  couplekiss_man_woman: jH,
  couplekiss_man_man: RH,
  couplekiss_woman_woman: NH,
  couple_with_heart: PH,
  couple_with_heart_woman_man: IH,
  couple_with_heart_man_man: OH,
  couple_with_heart_woman_woman: FH,
  family: MH,
  family_man_woman_boy: BH,
  family_man_woman_girl: zH,
  family_man_woman_girl_boy: $H,
  family_man_woman_boy_boy: GH,
  family_man_woman_girl_girl: UH,
  family_man_man_boy: HH,
  family_man_man_girl: VH,
  family_man_man_girl_boy: WH,
  family_man_man_boy_boy: ZH,
  family_man_man_girl_girl: JH,
  family_woman_woman_boy: QH,
  family_woman_woman_girl: YH,
  family_woman_woman_girl_boy: XH,
  family_woman_woman_boy_boy: KH,
  family_woman_woman_girl_girl: eV,
  family_man_boy: nV,
  family_man_boy_boy: tV,
  family_man_girl: oV,
  family_man_girl_boy: sV,
  family_man_girl_girl: rV,
  family_woman_boy: cV,
  family_woman_boy_boy: aV,
  family_woman_girl: iV,
  family_woman_girl_boy: lV,
  family_woman_girl_girl: uV,
  speaking_head: pV,
  bust_in_silhouette: hV,
  busts_in_silhouette: dV,
  people_hugging: fV,
  footprints: mV,
  monkey_face: gV,
  monkey: _V,
  gorilla: bV,
  orangutan: kV,
  dog: wV,
  dog2: yV,
  guide_dog: vV,
  service_dog: xV,
  poodle: AV,
  wolf: SV,
  fox_face: LV,
  raccoon: EV,
  cat: CV,
  cat2: TV,
  black_cat: DV,
  lion: qV,
  tiger: jV,
  tiger2: RV,
  leopard: NV,
  horse: PV,
  racehorse: IV,
  unicorn: OV,
  zebra: FV,
  deer: MV,
  bison: BV,
  cow: zV,
  ox: $V,
  water_buffalo: GV,
  cow2: UV,
  pig: HV,
  pig2: VV,
  boar: WV,
  pig_nose: ZV,
  ram: JV,
  sheep: QV,
  goat: YV,
  dromedary_camel: XV,
  camel: KV,
  llama: eW,
  giraffe: nW,
  elephant: tW,
  mammoth: oW,
  rhinoceros: sW,
  hippopotamus: rW,
  mouse: cW,
  mouse2: aW,
  rat: iW,
  hamster: lW,
  rabbit: uW,
  rabbit2: pW,
  chipmunk: hW,
  beaver: dW,
  hedgehog: fW,
  bat: mW,
  bear: gW,
  polar_bear: _W,
  koala: bW,
  panda_face: kW,
  sloth: wW,
  otter: yW,
  skunk: vW,
  kangaroo: xW,
  badger: AW,
  feet: SW,
  paw_prints: LW,
  turkey: EW,
  chicken: CW,
  rooster: TW,
  hatching_chick: DW,
  baby_chick: qW,
  hatched_chick: jW,
  bird: RW,
  penguin: NW,
  dove: PW,
  eagle: IW,
  duck: OW,
  swan: FW,
  owl: MW,
  dodo: BW,
  feather: zW,
  flamingo: $W,
  peacock: GW,
  parrot: UW,
  frog: HW,
  crocodile: VW,
  turtle: WW,
  lizard: ZW,
  snake: JW,
  dragon_face: QW,
  dragon: YW,
  sauropod: XW,
  "t-rex": "🦖",
  whale: KW,
  whale2: eZ,
  dolphin: nZ,
  flipper: tZ,
  seal: oZ,
  fish: sZ,
  tropical_fish: rZ,
  blowfish: cZ,
  shark: aZ,
  octopus: iZ,
  shell: lZ,
  snail: uZ,
  butterfly: pZ,
  bug: hZ,
  ant: dZ,
  bee: fZ,
  honeybee: mZ,
  beetle: gZ,
  lady_beetle: _Z,
  cricket: bZ,
  cockroach: kZ,
  spider: wZ,
  spider_web: yZ,
  scorpion: vZ,
  mosquito: xZ,
  fly: AZ,
  worm: SZ,
  microbe: LZ,
  bouquet: EZ,
  cherry_blossom: CZ,
  white_flower: TZ,
  rosette: DZ,
  rose: qZ,
  wilted_flower: jZ,
  hibiscus: RZ,
  sunflower: NZ,
  blossom: PZ,
  tulip: IZ,
  seedling: OZ,
  potted_plant: FZ,
  evergreen_tree: MZ,
  deciduous_tree: BZ,
  palm_tree: zZ,
  cactus: $Z,
  ear_of_rice: GZ,
  herb: UZ,
  shamrock: HZ,
  four_leaf_clover: VZ,
  maple_leaf: WZ,
  fallen_leaf: ZZ,
  leaves: JZ,
  grapes: QZ,
  melon: YZ,
  watermelon: XZ,
  tangerine: KZ,
  orange: eJ,
  mandarin: nJ,
  lemon: tJ,
  banana: oJ,
  pineapple: sJ,
  mango: rJ,
  apple: cJ,
  green_apple: aJ,
  pear: iJ,
  peach: lJ,
  cherries: uJ,
  strawberry: pJ,
  blueberries: hJ,
  kiwi_fruit: dJ,
  tomato: fJ,
  olive: mJ,
  coconut: gJ,
  avocado: _J,
  eggplant: bJ,
  potato: kJ,
  carrot: wJ,
  corn: yJ,
  hot_pepper: vJ,
  bell_pepper: xJ,
  cucumber: AJ,
  leafy_green: SJ,
  broccoli: LJ,
  garlic: EJ,
  onion: CJ,
  mushroom: TJ,
  peanuts: DJ,
  chestnut: qJ,
  bread: jJ,
  croissant: RJ,
  baguette_bread: NJ,
  flatbread: PJ,
  pretzel: IJ,
  bagel: OJ,
  pancakes: FJ,
  waffle: MJ,
  cheese: BJ,
  meat_on_bone: zJ,
  poultry_leg: $J,
  cut_of_meat: GJ,
  bacon: UJ,
  hamburger: HJ,
  fries: VJ,
  pizza: WJ,
  hotdog: ZJ,
  sandwich: JJ,
  taco: QJ,
  burrito: YJ,
  tamale: XJ,
  stuffed_flatbread: KJ,
  falafel: eQ,
  egg: nQ,
  fried_egg: tQ,
  shallow_pan_of_food: oQ,
  stew: sQ,
  fondue: rQ,
  bowl_with_spoon: cQ,
  green_salad: aQ,
  popcorn: iQ,
  butter: lQ,
  salt: uQ,
  canned_food: pQ,
  bento: hQ,
  rice_cracker: dQ,
  rice_ball: fQ,
  rice: mQ,
  curry: gQ,
  ramen: _Q,
  spaghetti: bQ,
  sweet_potato: kQ,
  oden: wQ,
  sushi: yQ,
  fried_shrimp: vQ,
  fish_cake: xQ,
  moon_cake: AQ,
  dango: SQ,
  dumpling: LQ,
  fortune_cookie: EQ,
  takeout_box: CQ,
  crab: TQ,
  lobster: DQ,
  shrimp: qQ,
  squid: jQ,
  oyster: RQ,
  icecream: NQ,
  shaved_ice: PQ,
  ice_cream: IQ,
  doughnut: OQ,
  cookie: FQ,
  birthday: MQ,
  cake: BQ,
  cupcake: zQ,
  pie: $Q,
  chocolate_bar: GQ,
  candy: UQ,
  lollipop: HQ,
  custard: VQ,
  honey_pot: WQ,
  baby_bottle: ZQ,
  milk_glass: JQ,
  coffee: QQ,
  teapot: YQ,
  tea: XQ,
  sake: KQ,
  champagne: eY,
  wine_glass: nY,
  cocktail: tY,
  tropical_drink: oY,
  beer: sY,
  beers: rY,
  clinking_glasses: cY,
  tumbler_glass: aY,
  cup_with_straw: iY,
  bubble_tea: lY,
  beverage_box: uY,
  mate: pY,
  ice_cube: hY,
  chopsticks: dY,
  plate_with_cutlery: fY,
  fork_and_knife: mY,
  spoon: gY,
  hocho: _Y,
  knife: bY,
  amphora: kY,
  earth_africa: wY,
  earth_americas: yY,
  earth_asia: vY,
  globe_with_meridians: xY,
  world_map: AY,
  japan: SY,
  compass: LY,
  mountain_snow: EY,
  mountain: CY,
  volcano: TY,
  mount_fuji: DY,
  camping: qY,
  beach_umbrella: jY,
  desert: RY,
  desert_island: NY,
  national_park: PY,
  stadium: IY,
  classical_building: OY,
  building_construction: FY,
  bricks: MY,
  rock: BY,
  wood: zY,
  hut: $Y,
  houses: GY,
  derelict_house: UY,
  house: HY,
  house_with_garden: VY,
  office: WY,
  post_office: ZY,
  european_post_office: JY,
  hospital: QY,
  bank: YY,
  hotel: XY,
  love_hotel: KY,
  convenience_store: eX,
  school: nX,
  department_store: tX,
  factory: oX,
  japanese_castle: sX,
  european_castle: rX,
  wedding: cX,
  tokyo_tower: aX,
  statue_of_liberty: iX,
  church: lX,
  mosque: uX,
  hindu_temple: pX,
  synagogue: hX,
  shinto_shrine: dX,
  kaaba: fX,
  fountain: mX,
  tent: gX,
  foggy: _X,
  night_with_stars: bX,
  cityscape: kX,
  sunrise_over_mountains: wX,
  sunrise: yX,
  city_sunset: vX,
  city_sunrise: xX,
  bridge_at_night: AX,
  hotsprings: SX,
  carousel_horse: LX,
  ferris_wheel: EX,
  roller_coaster: CX,
  barber: TX,
  circus_tent: DX,
  steam_locomotive: qX,
  railway_car: jX,
  bullettrain_side: RX,
  bullettrain_front: NX,
  train2: PX,
  metro: IX,
  light_rail: OX,
  station: FX,
  tram: MX,
  monorail: BX,
  mountain_railway: zX,
  train: $X,
  bus: GX,
  oncoming_bus: UX,
  trolleybus: HX,
  minibus: VX,
  ambulance: WX,
  fire_engine: ZX,
  police_car: JX,
  oncoming_police_car: QX,
  taxi: YX,
  oncoming_taxi: XX,
  car: KX,
  red_car: eK,
  oncoming_automobile: nK,
  blue_car: tK,
  pickup_truck: oK,
  truck: sK,
  articulated_lorry: rK,
  tractor: cK,
  racing_car: aK,
  motorcycle: iK,
  motor_scooter: lK,
  manual_wheelchair: uK,
  motorized_wheelchair: pK,
  auto_rickshaw: hK,
  bike: dK,
  kick_scooter: fK,
  skateboard: mK,
  roller_skate: gK,
  busstop: _K,
  motorway: bK,
  railway_track: kK,
  oil_drum: wK,
  fuelpump: yK,
  rotating_light: vK,
  traffic_light: xK,
  vertical_traffic_light: AK,
  stop_sign: SK,
  construction: LK,
  anchor: EK,
  boat: CK,
  sailboat: TK,
  canoe: DK,
  speedboat: qK,
  passenger_ship: jK,
  ferry: RK,
  motor_boat: NK,
  ship: PK,
  airplane: IK,
  small_airplane: OK,
  flight_departure: FK,
  flight_arrival: MK,
  parachute: BK,
  seat: zK,
  helicopter: $K,
  suspension_railway: GK,
  mountain_cableway: UK,
  aerial_tramway: HK,
  artificial_satellite: VK,
  rocket: WK,
  flying_saucer: ZK,
  bellhop_bell: JK,
  luggage: QK,
  hourglass: YK,
  hourglass_flowing_sand: XK,
  watch: KK,
  alarm_clock: eee,
  stopwatch: nee,
  timer_clock: tee,
  mantelpiece_clock: oee,
  clock12: see,
  clock1230: ree,
  clock1: cee,
  clock130: aee,
  clock2: iee,
  clock230: lee,
  clock3: uee,
  clock330: pee,
  clock4: hee,
  clock430: dee,
  clock5: fee,
  clock530: mee,
  clock6: gee,
  clock630: _ee,
  clock7: bee,
  clock730: kee,
  clock8: wee,
  clock830: yee,
  clock9: vee,
  clock930: xee,
  clock10: Aee,
  clock1030: See,
  clock11: Lee,
  clock1130: Eee,
  new_moon: Cee,
  waxing_crescent_moon: Tee,
  first_quarter_moon: Dee,
  moon: qee,
  waxing_gibbous_moon: jee,
  full_moon: Ree,
  waning_gibbous_moon: Nee,
  last_quarter_moon: Pee,
  waning_crescent_moon: Iee,
  crescent_moon: Oee,
  new_moon_with_face: Fee,
  first_quarter_moon_with_face: Mee,
  last_quarter_moon_with_face: Bee,
  thermometer: zee,
  sunny: $ee,
  full_moon_with_face: Gee,
  sun_with_face: Uee,
  ringed_planet: Hee,
  star: Vee,
  star2: Wee,
  stars: Zee,
  milky_way: Jee,
  cloud: Qee,
  partly_sunny: Yee,
  cloud_with_lightning_and_rain: Xee,
  sun_behind_small_cloud: Kee,
  sun_behind_large_cloud: ene,
  sun_behind_rain_cloud: nne,
  cloud_with_rain: tne,
  cloud_with_snow: one,
  cloud_with_lightning: sne,
  tornado: rne,
  fog: cne,
  wind_face: ane,
  cyclone: ine,
  rainbow: lne,
  closed_umbrella: une,
  open_umbrella: pne,
  umbrella: hne,
  parasol_on_ground: dne,
  zap: fne,
  snowflake: mne,
  snowman_with_snow: gne,
  snowman: _ne,
  comet: bne,
  fire: kne,
  droplet: wne,
  ocean: yne,
  jack_o_lantern: vne,
  christmas_tree: xne,
  fireworks: Ane,
  sparkler: Sne,
  firecracker: Lne,
  sparkles: Ene,
  balloon: Cne,
  tada: Tne,
  confetti_ball: Dne,
  tanabata_tree: qne,
  bamboo: jne,
  dolls: Rne,
  flags: Nne,
  wind_chime: Pne,
  rice_scene: Ine,
  red_envelope: One,
  ribbon: Fne,
  gift: Mne,
  reminder_ribbon: Bne,
  tickets: zne,
  ticket: $ne,
  medal_military: Gne,
  trophy: Une,
  medal_sports: Hne,
  "1st_place_medal": "🥇",
  "2nd_place_medal": "🥈",
  "3rd_place_medal": "🥉",
  soccer: Vne,
  baseball: Wne,
  softball: Zne,
  basketball: Jne,
  volleyball: Qne,
  football: Yne,
  rugby_football: Xne,
  tennis: Kne,
  flying_disc: ete,
  bowling: nte,
  cricket_game: tte,
  field_hockey: ote,
  ice_hockey: ste,
  lacrosse: rte,
  ping_pong: cte,
  badminton: ate,
  boxing_glove: ite,
  martial_arts_uniform: lte,
  goal_net: ute,
  golf: pte,
  ice_skate: hte,
  fishing_pole_and_fish: dte,
  diving_mask: fte,
  running_shirt_with_sash: mte,
  ski: gte,
  sled: _te,
  curling_stone: bte,
  dart: kte,
  yo_yo: wte,
  kite: yte,
  "8ball": "🎱",
  crystal_ball: vte,
  magic_wand: xte,
  nazar_amulet: Ate,
  video_game: Ste,
  joystick: Lte,
  slot_machine: Ete,
  game_die: Cte,
  jigsaw: Tte,
  teddy_bear: Dte,
  pinata: qte,
  nesting_dolls: jte,
  spades: Rte,
  hearts: Nte,
  diamonds: Pte,
  clubs: Ite,
  chess_pawn: Ote,
  black_joker: Fte,
  mahjong: Mte,
  flower_playing_cards: Bte,
  performing_arts: zte,
  framed_picture: $te,
  art: Gte,
  thread: Ute,
  sewing_needle: Hte,
  yarn: Vte,
  knot: Wte,
  eyeglasses: Zte,
  dark_sunglasses: Jte,
  goggles: Qte,
  lab_coat: Yte,
  safety_vest: Xte,
  necktie: Kte,
  shirt: eoe,
  tshirt: noe,
  jeans: toe,
  scarf: ooe,
  gloves: soe,
  coat: roe,
  socks: coe,
  dress: aoe,
  kimono: ioe,
  sari: loe,
  one_piece_swimsuit: uoe,
  swim_brief: poe,
  shorts: hoe,
  bikini: doe,
  womans_clothes: foe,
  purse: moe,
  handbag: goe,
  pouch: _oe,
  shopping: boe,
  school_satchel: koe,
  thong_sandal: woe,
  mans_shoe: yoe,
  shoe: voe,
  athletic_shoe: xoe,
  hiking_boot: Aoe,
  flat_shoe: Soe,
  high_heel: Loe,
  sandal: Eoe,
  ballet_shoes: Coe,
  boot: Toe,
  crown: Doe,
  womans_hat: qoe,
  tophat: joe,
  mortar_board: Roe,
  billed_cap: Noe,
  military_helmet: Poe,
  rescue_worker_helmet: Ioe,
  prayer_beads: Ooe,
  lipstick: Foe,
  ring: Moe,
  gem: Boe,
  mute: zoe,
  speaker: $oe,
  sound: Goe,
  loud_sound: Uoe,
  loudspeaker: Hoe,
  mega: Voe,
  postal_horn: Woe,
  bell: Zoe,
  no_bell: Joe,
  musical_score: Qoe,
  musical_note: Yoe,
  notes: Xoe,
  studio_microphone: Koe,
  level_slider: ese,
  control_knobs: nse,
  microphone: tse,
  headphones: ose,
  radio: sse,
  saxophone: rse,
  accordion: cse,
  guitar: ase,
  musical_keyboard: ise,
  trumpet: lse,
  violin: use,
  banjo: pse,
  drum: hse,
  long_drum: dse,
  iphone: fse,
  calling: mse,
  phone: gse,
  telephone: _se,
  telephone_receiver: bse,
  pager: kse,
  fax: wse,
  battery: yse,
  electric_plug: vse,
  computer: xse,
  desktop_computer: Ase,
  printer: Sse,
  keyboard: Lse,
  computer_mouse: Ese,
  trackball: Cse,
  minidisc: Tse,
  floppy_disk: Dse,
  cd: qse,
  dvd: jse,
  abacus: Rse,
  movie_camera: Nse,
  film_strip: Pse,
  film_projector: Ise,
  clapper: Ose,
  tv: Fse,
  camera: Mse,
  camera_flash: Bse,
  video_camera: zse,
  vhs: $se,
  mag: Gse,
  mag_right: Use,
  candle: Hse,
  bulb: Vse,
  flashlight: Wse,
  izakaya_lantern: Zse,
  lantern: Jse,
  diya_lamp: Qse,
  notebook_with_decorative_cover: Yse,
  closed_book: Xse,
  book: Kse,
  open_book: ere,
  green_book: nre,
  blue_book: tre,
  orange_book: ore,
  books: sre,
  notebook: rre,
  ledger: cre,
  page_with_curl: are,
  scroll: ire,
  page_facing_up: lre,
  newspaper: ure,
  newspaper_roll: pre,
  bookmark_tabs: hre,
  bookmark: dre,
  label: fre,
  moneybag: mre,
  coin: gre,
  yen: _re,
  dollar: bre,
  euro: kre,
  pound: wre,
  money_with_wings: yre,
  credit_card: vre,
  receipt: xre,
  chart: Are,
  envelope: Sre,
  email: Lre,
  "e-mail": "📧",
  incoming_envelope: Ere,
  envelope_with_arrow: Cre,
  outbox_tray: Tre,
  inbox_tray: Dre,
  package: "📦",
  mailbox: qre,
  mailbox_closed: jre,
  mailbox_with_mail: Rre,
  mailbox_with_no_mail: Nre,
  postbox: Pre,
  ballot_box: Ire,
  pencil2: Ore,
  black_nib: Fre,
  fountain_pen: Mre,
  pen: Bre,
  paintbrush: zre,
  crayon: $re,
  memo: Gre,
  pencil: Ure,
  briefcase: Hre,
  file_folder: Vre,
  open_file_folder: Wre,
  card_index_dividers: Zre,
  date: Jre,
  calendar: Qre,
  spiral_notepad: Yre,
  spiral_calendar: Xre,
  card_index: Kre,
  chart_with_upwards_trend: ece,
  chart_with_downwards_trend: nce,
  bar_chart: tce,
  clipboard: oce,
  pushpin: sce,
  round_pushpin: rce,
  paperclip: cce,
  paperclips: ace,
  straight_ruler: ice,
  triangular_ruler: lce,
  scissors: uce,
  card_file_box: pce,
  file_cabinet: hce,
  wastebasket: dce,
  lock: fce,
  unlock: mce,
  lock_with_ink_pen: gce,
  closed_lock_with_key: _ce,
  key: bce,
  old_key: kce,
  hammer: wce,
  axe: yce,
  pick: vce,
  hammer_and_pick: xce,
  hammer_and_wrench: Ace,
  dagger: Sce,
  crossed_swords: Lce,
  gun: Ece,
  boomerang: Cce,
  bow_and_arrow: Tce,
  shield: Dce,
  carpentry_saw: qce,
  wrench: jce,
  screwdriver: Rce,
  nut_and_bolt: Nce,
  gear: Pce,
  clamp: Ice,
  balance_scale: Oce,
  probing_cane: Fce,
  link: Mce,
  chains: Bce,
  hook: zce,
  toolbox: $ce,
  magnet: Gce,
  ladder: Uce,
  alembic: Hce,
  test_tube: Vce,
  petri_dish: Wce,
  dna: Zce,
  microscope: Jce,
  telescope: Qce,
  satellite: Yce,
  syringe: Xce,
  drop_of_blood: Kce,
  pill: eae,
  adhesive_bandage: nae,
  stethoscope: tae,
  door: oae,
  elevator: sae,
  mirror: rae,
  window: cae,
  bed: aae,
  couch_and_lamp: iae,
  chair: lae,
  toilet: uae,
  plunger: pae,
  shower: hae,
  bathtub: dae,
  mouse_trap: fae,
  razor: mae,
  lotion_bottle: gae,
  safety_pin: _ae,
  broom: bae,
  basket: kae,
  roll_of_paper: wae,
  bucket: yae,
  soap: vae,
  toothbrush: xae,
  sponge: Aae,
  fire_extinguisher: Sae,
  shopping_cart: Lae,
  smoking: Eae,
  coffin: Cae,
  headstone: Tae,
  funeral_urn: Dae,
  moyai: qae,
  placard: jae,
  atm: Rae,
  put_litter_in_its_place: Nae,
  potable_water: Pae,
  wheelchair: Iae,
  mens: Oae,
  womens: Fae,
  restroom: Mae,
  baby_symbol: Bae,
  wc: zae,
  passport_control: $ae,
  customs: Gae,
  baggage_claim: Uae,
  left_luggage: Hae,
  warning: Vae,
  children_crossing: Wae,
  no_entry: Zae,
  no_entry_sign: Jae,
  no_bicycles: Qae,
  no_smoking: Yae,
  do_not_litter: Xae,
  "non-potable_water": "🚱",
  no_pedestrians: Kae,
  no_mobile_phones: eie,
  underage: nie,
  radioactive: tie,
  biohazard: oie,
  arrow_up: sie,
  arrow_upper_right: rie,
  arrow_right: cie,
  arrow_lower_right: aie,
  arrow_down: iie,
  arrow_lower_left: lie,
  arrow_left: uie,
  arrow_upper_left: pie,
  arrow_up_down: hie,
  left_right_arrow: die,
  leftwards_arrow_with_hook: fie,
  arrow_right_hook: mie,
  arrow_heading_up: gie,
  arrow_heading_down: _ie,
  arrows_clockwise: bie,
  arrows_counterclockwise: kie,
  back: wie,
  end: yie,
  on: vie,
  soon: xie,
  top: Aie,
  place_of_worship: Sie,
  atom_symbol: Lie,
  om: Eie,
  star_of_david: Cie,
  wheel_of_dharma: Tie,
  yin_yang: Die,
  latin_cross: qie,
  orthodox_cross: jie,
  star_and_crescent: Rie,
  peace_symbol: Nie,
  menorah: Pie,
  six_pointed_star: Iie,
  aries: Oie,
  taurus: Fie,
  gemini: Mie,
  cancer: Bie,
  leo: zie,
  virgo: $ie,
  libra: Gie,
  scorpius: Uie,
  sagittarius: Hie,
  capricorn: Vie,
  aquarius: Wie,
  pisces: Zie,
  ophiuchus: Jie,
  twisted_rightwards_arrows: Qie,
  repeat: Yie,
  repeat_one: Xie,
  arrow_forward: Kie,
  fast_forward: ele,
  next_track_button: nle,
  play_or_pause_button: tle,
  arrow_backward: ole,
  rewind: sle,
  previous_track_button: rle,
  arrow_up_small: cle,
  arrow_double_up: ale,
  arrow_down_small: ile,
  arrow_double_down: lle,
  pause_button: ule,
  stop_button: ple,
  record_button: hle,
  eject_button: dle,
  cinema: fle,
  low_brightness: mle,
  high_brightness: gle,
  signal_strength: _le,
  vibration_mode: ble,
  mobile_phone_off: kle,
  female_sign: wle,
  male_sign: yle,
  transgender_symbol: vle,
  heavy_multiplication_x: xle,
  heavy_plus_sign: Ale,
  heavy_minus_sign: Sle,
  heavy_division_sign: Lle,
  infinity: Ele,
  bangbang: Cle,
  interrobang: Tle,
  question: Dle,
  grey_question: qle,
  grey_exclamation: jle,
  exclamation: Rle,
  heavy_exclamation_mark: Nle,
  wavy_dash: Ple,
  currency_exchange: Ile,
  heavy_dollar_sign: Ole,
  medical_symbol: Fle,
  recycle: Mle,
  fleur_de_lis: Ble,
  trident: zle,
  name_badge: $le,
  beginner: Gle,
  o: Ule,
  white_check_mark: Hle,
  ballot_box_with_check: Vle,
  heavy_check_mark: Wle,
  x: Zle,
  negative_squared_cross_mark: Jle,
  curly_loop: Qle,
  loop: Yle,
  part_alternation_mark: Xle,
  eight_spoked_asterisk: Kle,
  eight_pointed_black_star: eue,
  sparkle: nue,
  copyright: tue,
  registered: oue,
  tm: sue,
  hash: rue,
  asterisk: cue,
  zero: aue,
  one: iue,
  two: lue,
  three: uue,
  four: pue,
  five: hue,
  six: due,
  seven: fue,
  eight: mue,
  nine: gue,
  keycap_ten: _ue,
  capital_abcd: bue,
  abcd: kue,
  symbols: wue,
  abc: yue,
  a: vue,
  ab: xue,
  b: Aue,
  cl: Sue,
  cool: Lue,
  free: Eue,
  information_source: Cue,
  id: Tue,
  m: Due,
  new: "🆕",
  ng: que,
  o2: jue,
  ok: Rue,
  parking: Nue,
  sos: Pue,
  up: Iue,
  vs: Oue,
  koko: Fue,
  sa: Mue,
  ideograph_advantage: Bue,
  accept: zue,
  congratulations: $ue,
  secret: Gue,
  u6e80: Uue,
  red_circle: Hue,
  orange_circle: Vue,
  yellow_circle: Wue,
  green_circle: Zue,
  large_blue_circle: Jue,
  purple_circle: Que,
  brown_circle: Yue,
  black_circle: Xue,
  white_circle: Kue,
  red_square: epe,
  orange_square: npe,
  yellow_square: tpe,
  green_square: ope,
  blue_square: spe,
  purple_square: rpe,
  brown_square: cpe,
  black_large_square: ape,
  white_large_square: ipe,
  black_medium_square: lpe,
  white_medium_square: upe,
  black_medium_small_square: ppe,
  white_medium_small_square: hpe,
  black_small_square: dpe,
  white_small_square: fpe,
  large_orange_diamond: mpe,
  large_blue_diamond: gpe,
  small_orange_diamond: _pe,
  small_blue_diamond: bpe,
  small_red_triangle: kpe,
  small_red_triangle_down: wpe,
  diamond_shape_with_a_dot_inside: ype,
  radio_button: vpe,
  white_square_button: xpe,
  black_square_button: Ape,
  checkered_flag: Spe,
  triangular_flag_on_post: Lpe,
  crossed_flags: Epe,
  black_flag: Cpe,
  white_flag: Tpe,
  rainbow_flag: Dpe,
  transgender_flag: qpe,
  pirate_flag: jpe,
  ascension_island: Rpe,
  andorra: Npe,
  united_arab_emirates: Ppe,
  afghanistan: Ipe,
  antigua_barbuda: Ope,
  anguilla: Fpe,
  albania: Mpe,
  armenia: Bpe,
  angola: zpe,
  antarctica: $pe,
  argentina: Gpe,
  american_samoa: Upe,
  austria: Hpe,
  australia: Vpe,
  aruba: Wpe,
  aland_islands: Zpe,
  azerbaijan: Jpe,
  bosnia_herzegovina: Qpe,
  barbados: Ype,
  bangladesh: Xpe,
  belgium: Kpe,
  burkina_faso: ehe,
  bulgaria: nhe,
  bahrain: the,
  burundi: ohe,
  benin: she,
  st_barthelemy: rhe,
  bermuda: che,
  brunei: ahe,
  bolivia: ihe,
  caribbean_netherlands: lhe,
  brazil: uhe,
  bahamas: phe,
  bhutan: hhe,
  bouvet_island: dhe,
  botswana: fhe,
  belarus: mhe,
  belize: ghe,
  canada: _he,
  cocos_islands: bhe,
  congo_kinshasa: khe,
  central_african_republic: whe,
  congo_brazzaville: yhe,
  switzerland: vhe,
  cote_divoire: xhe,
  cook_islands: Ahe,
  chile: She,
  cameroon: Lhe,
  cn: Ehe,
  colombia: Che,
  clipperton_island: The,
  costa_rica: Dhe,
  cuba: qhe,
  cape_verde: jhe,
  curacao: Rhe,
  christmas_island: Nhe,
  cyprus: Phe,
  czech_republic: Ihe,
  de: Ohe,
  diego_garcia: Fhe,
  djibouti: Mhe,
  denmark: Bhe,
  dominica: zhe,
  dominican_republic: $he,
  algeria: Ghe,
  ceuta_melilla: Uhe,
  ecuador: Hhe,
  estonia: Vhe,
  egypt: Whe,
  western_sahara: Zhe,
  eritrea: Jhe,
  es: Qhe,
  ethiopia: Yhe,
  eu: Xhe,
  european_union: Khe,
  finland: ede,
  fiji: nde,
  falkland_islands: tde,
  micronesia: ode,
  faroe_islands: sde,
  fr: rde,
  gabon: cde,
  gb: ade,
  uk: ide,
  grenada: lde,
  georgia: ude,
  french_guiana: pde,
  guernsey: hde,
  ghana: dde,
  gibraltar: fde,
  greenland: mde,
  gambia: gde,
  guinea: _de,
  guadeloupe: bde,
  equatorial_guinea: kde,
  greece: wde,
  south_georgia_south_sandwich_islands: yde,
  guatemala: vde,
  guam: xde,
  guinea_bissau: Ade,
  guyana: Sde,
  hong_kong: Lde,
  heard_mcdonald_islands: Ede,
  honduras: Cde,
  croatia: Tde,
  haiti: Dde,
  hungary: qde,
  canary_islands: jde,
  indonesia: Rde,
  ireland: Nde,
  israel: Pde,
  isle_of_man: Ide,
  india: Ode,
  british_indian_ocean_territory: Fde,
  iraq: Mde,
  iran: Bde,
  iceland: zde,
  it: $de,
  jersey: Gde,
  jamaica: Ude,
  jordan: Hde,
  jp: Vde,
  kenya: Wde,
  kyrgyzstan: Zde,
  cambodia: Jde,
  kiribati: Qde,
  comoros: Yde,
  st_kitts_nevis: Xde,
  north_korea: Kde,
  kr: efe,
  kuwait: nfe,
  cayman_islands: tfe,
  kazakhstan: ofe,
  laos: sfe,
  lebanon: rfe,
  st_lucia: cfe,
  liechtenstein: afe,
  sri_lanka: ife,
  liberia: lfe,
  lesotho: ufe,
  lithuania: pfe,
  luxembourg: hfe,
  latvia: dfe,
  libya: ffe,
  morocco: mfe,
  monaco: gfe,
  moldova: _fe,
  montenegro: bfe,
  st_martin: kfe,
  madagascar: wfe,
  marshall_islands: yfe,
  macedonia: vfe,
  mali: xfe,
  myanmar: Afe,
  mongolia: Sfe,
  macau: Lfe,
  northern_mariana_islands: Efe,
  martinique: Cfe,
  mauritania: Tfe,
  montserrat: Dfe,
  malta: qfe,
  mauritius: jfe,
  maldives: Rfe,
  malawi: Nfe,
  mexico: Pfe,
  malaysia: Ife,
  mozambique: Ofe,
  namibia: Ffe,
  new_caledonia: Mfe,
  niger: Bfe,
  norfolk_island: zfe,
  nigeria: $fe,
  nicaragua: Gfe,
  netherlands: Ufe,
  norway: Hfe,
  nepal: Vfe,
  nauru: Wfe,
  niue: Zfe,
  new_zealand: Jfe,
  oman: Qfe,
  panama: Yfe,
  peru: Xfe,
  french_polynesia: Kfe,
  papua_new_guinea: eme,
  philippines: nme,
  pakistan: tme,
  poland: ome,
  st_pierre_miquelon: sme,
  pitcairn_islands: rme,
  puerto_rico: cme,
  palestinian_territories: ame,
  portugal: ime,
  palau: lme,
  paraguay: ume,
  qatar: pme,
  reunion: hme,
  romania: dme,
  serbia: fme,
  ru: mme,
  rwanda: gme,
  saudi_arabia: _me,
  solomon_islands: bme,
  seychelles: kme,
  sudan: wme,
  sweden: yme,
  singapore: vme,
  st_helena: xme,
  slovenia: Ame,
  svalbard_jan_mayen: Sme,
  slovakia: Lme,
  sierra_leone: Eme,
  san_marino: Cme,
  senegal: Tme,
  somalia: Dme,
  suriname: qme,
  south_sudan: jme,
  sao_tome_principe: Rme,
  el_salvador: Nme,
  sint_maarten: Pme,
  syria: Ime,
  swaziland: Ome,
  tristan_da_cunha: Fme,
  turks_caicos_islands: Mme,
  chad: Bme,
  french_southern_territories: zme,
  togo: $me,
  thailand: Gme,
  tajikistan: Ume,
  tokelau: Hme,
  timor_leste: Vme,
  turkmenistan: Wme,
  tunisia: Zme,
  tonga: Jme,
  tr: Qme,
  trinidad_tobago: Yme,
  tuvalu: Xme,
  taiwan: Kme,
  tanzania: ege,
  ukraine: nge,
  uganda: tge,
  us_outlying_islands: oge,
  united_nations: sge,
  us: rge,
  uruguay: cge,
  uzbekistan: age,
  vatican_city: ige,
  st_vincent_grenadines: lge,
  venezuela: uge,
  british_virgin_islands: pge,
  us_virgin_islands: hge,
  vietnam: dge,
  vanuatu: fge,
  wallis_futuna: mge,
  samoa: gge,
  kosovo: _ge,
  yemen: bge,
  mayotte: kge,
  south_africa: wge,
  zambia: yge,
  zimbabwe: vge,
  england: xge,
  scotland: Age,
  wales: Sge
};
var Ege = {
  angry: [">:(", ">:-("],
  blush: [':")', ':-")'],
  broken_heart: ["</3", "<\\3"],
  // :\ and :-\ not used because of conflict with markdown escaping
  confused: [":/", ":-/"],
  // twemoji shows question
  cry: [":'(", ":'-(", ":,(", ":,-("],
  frowning: [":(", ":-("],
  heart: ["<3"],
  imp: ["]:(", "]:-("],
  innocent: ["o:)", "O:)", "o:-)", "O:-)", "0:)", "0:-)"],
  joy: [":')", ":'-)", ":,)", ":,-)", ":'D", ":'-D", ":,D", ":,-D"],
  kissing: [":*", ":-*"],
  laughing: ["x-)", "X-)"],
  neutral_face: [":|", ":-|"],
  open_mouth: [":o", ":-o", ":O", ":-O"],
  rage: [":@", ":-@"],
  smile: [":D", ":-D"],
  smiley: [":)", ":-)"],
  smiling_imp: ["]:)", "]:-)"],
  sob: [":,'(", ":,'-(", ";(", ";-("],
  stuck_out_tongue: [":P", ":-P"],
  sunglasses: ["8-)", "B-)"],
  sweat: [",:(", ",:-("],
  sweat_smile: [",:)", ",:-)"],
  unamused: [":s", ":-S", ":z", ":-Z", ":$", ":-$"],
  wink: [";)", ";-)"]
}, Cge = function(e, t) {
  return e[t].content;
}, Tge = function(e, t, o, r, s) {
  var a = e.utils.arrayReplaceAt, c = e.utils.lib.ucmicro, l = new RegExp([c.Z.source, c.P.source, c.Cc.source].join("|"));
  function i(p, h, d) {
    var f, m = 0, S = [];
    return p.replace(s, function(L, _, k) {
      var w;
      if (o.hasOwnProperty(L)) {
        if (w = o[L], _ > 0 && !l.test(k[_ - 1]) || _ + L.length < k.length && !l.test(k[_ + L.length]))
          return;
      } else
        w = L.slice(1, -1);
      _ > m && (f = new d("text", "", 0), f.content = p.slice(m, _), S.push(f)), f = new d("emoji", "", 0), f.markup = w, f.content = t[w], S.push(f), m = _ + L.length;
    }), m < p.length && (f = new d("text", "", 0), f.content = p.slice(m), S.push(f)), S;
  }
  return function(h) {
    var d, f, m, S, L, _ = h.tokens, k = 0;
    for (f = 0, m = _.length; f < m; f++)
      if (_[f].type === "inline")
        for (S = _[f].children, d = S.length - 1; d >= 0; d--)
          L = S[d], (L.type === "link_open" || L.type === "link_close") && L.info === "auto" && (k -= L.nesting), L.type === "text" && k === 0 && r.test(L.content) && (_[f].children = S = a(
            S,
            d,
            i(L.content, L.level, h.Token)
          ));
  };
};
function Dge(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var qge = function(e) {
  var t = e.defs, o;
  e.enabled.length && (t = Object.keys(t).reduce(function(l, i) {
    return e.enabled.indexOf(i) >= 0 && (l[i] = t[i]), l;
  }, {})), o = Object.keys(e.shortcuts).reduce(function(l, i) {
    return t[i] ? Array.isArray(e.shortcuts[i]) ? (e.shortcuts[i].forEach(function(p) {
      l[p] = i;
    }), l) : (l[e.shortcuts[i]] = i, l) : l;
  }, {});
  var r = Object.keys(t), s;
  r.length === 0 ? s = "^$" : s = r.map(function(l) {
    return ":" + l + ":";
  }).concat(Object.keys(o)).sort().reverse().map(function(l) {
    return Dge(l);
  }).join("|");
  var a = RegExp(s), c = RegExp(s, "g");
  return {
    defs: t,
    shortcuts: o,
    scanRE: a,
    replaceRE: c
  };
}, jge = Cge, Rge = Tge, Nge = qge, Pge = function(e, t) {
  var o = {
    defs: {},
    shortcuts: {},
    enabled: []
  }, r = Nge(e.utils.assign({}, o, t || {}));
  e.renderer.rules.emoji = jge, e.core.ruler.after(
    "linkify",
    "emoji",
    Rge(e, r.defs, r.shortcuts, r.scanRE, r.replaceRE)
  );
}, Ige = Lge, Oge = Ege, Fge = Pge, Mge = function(e, t) {
  var o = {
    defs: Ige,
    shortcuts: Oge,
    enabled: []
  }, r = e.utils.assign({}, o, t || {});
  Fge(e, r);
}, ln = function(e, t, o) {
  function r(f) {
    return f.trim().split(" ", 2)[0] === t;
  }
  function s(f, m, S, L, _) {
    return f[m].nesting === 1 && f[m].attrJoin("class", t), _.renderToken(f, m, S, L, _);
  }
  o = o || {};
  var a = 3, c = o.marker || ":", l = c.charCodeAt(0), i = c.length, p = o.validate || r, h = o.render || s;
  function d(f, m, S, L) {
    var _, k, w, E, y, u, g, x, b = !1, v = f.bMarks[m] + f.tShift[m], A = f.eMarks[m];
    if (l !== f.src.charCodeAt(v))
      return !1;
    for (_ = v + 1; _ <= A && c[(_ - v) % i] === f.src[_]; _++)
      ;
    if (w = Math.floor((_ - v) / i), w < a || (_ -= (_ - v) % i, E = f.src.slice(v, _), y = f.src.slice(_, A), !p(y, E)))
      return !1;
    if (L)
      return !0;
    for (k = m; k++, !(k >= S || (v = f.bMarks[k] + f.tShift[k], A = f.eMarks[k], v < A && f.sCount[k] < f.blkIndent)); )
      if (l === f.src.charCodeAt(v) && !(f.sCount[k] - f.blkIndent >= 4)) {
        for (_ = v + 1; _ <= A && c[(_ - v) % i] === f.src[_]; _++)
          ;
        if (!(Math.floor((_ - v) / i) < w) && (_ -= (_ - v) % i, _ = f.skipSpaces(_), !(_ < A))) {
          b = !0;
          break;
        }
      }
    return g = f.parentType, x = f.lineMax, f.parentType = "container", f.lineMax = k, u = f.push("container_" + t + "_open", "div", 1), u.markup = E, u.block = !0, u.info = y, u.map = [m, k], f.md.block.tokenize(f, m + 1, k), u = f.push("container_" + t + "_close", "div", -1), u.markup = f.src.slice(v, _), u.block = !0, f.parentType = g, f.lineMax = x, f.line = k + (b ? 1 : 0), !0;
  }
  e.block.ruler.before("fence", "container_" + t, d, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), e.renderer.rules["container_" + t + "_open"] = h, e.renderer.rules["container_" + t + "_close"] = h;
};
let Bge = (n) => crypto.getRandomValues(new Uint8Array(n)), zge = (n, e, t) => {
  let o = (2 << Math.log(n.length - 1) / Math.LN2) - 1, r = -~(1.6 * o * e / n.length);
  return (s = e) => {
    let a = "";
    for (; ; ) {
      let c = t(r), l = r;
      for (; l--; )
        if (a += n[c[l] & o] || "", a.length === s)
          return a;
    }
  };
}, $ge = (n, e = 21) => zge(n, e, Bge), Xt = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += "-" : e += "_", e), "");
const Jn = /^[a-z]+:/i, Gge = /^pathname:\/\//, Fo = Symbol("vue-md-shiki-component"), Uge = () => [
  ..."abap,actionscript-3,ada,apache,apex,apl,applescript,ara,asm,astro,awk,ballerina,bat,batch,berry,be,bibtex,bicep,blade,c,cadence,cdc,clarity,clojure,clj,cmake,cobol,codeql,ql,coffee,cpp,crystal,csharp,c#,cs,css,cue,d,dart,dax,diff,docker,dream-maker,elixir,elm,erb,erlang,erl,fish,fsharp,f#,fs,gherkin,git-commit,git-rebase,glsl,gnuplot,go,graphql,groovy,hack,haml,handlebars,hbs,haskell,hs,hcl,hlsl,html,http,imba,ini,properties,java,javascript,js,jinja-html,jison,json,json5,jsonc,jsonnet,jssm,fsl,jsx,julia,kotlin,latex,less,liquid,lisp,logo,lua,make,makefile,markdown,md,marko,matlab,mdx,mermaid,nginx,nim,nix,objective-c,objc,objective-cpp,ocaml,pascal,perl,php,plsql,postcss,powerquery,powershell,ps,ps1,prisma,prolog,proto,pug,jade,puppet,purescript,python,py,r,raku,perl6,razor,rel,riscv,rst,ruby,rb,rust,rs,sas,sass,scala,scheme,scss,shaderlab,shader,shellscript,bash,console,sh,shell,zsh,smalltalk,solidity,sparql,sql,ssh-config,stata,stylus,styl,svelte,swift,system-verilog,tasl,tcl,tex,toml,tsx,turtle,twig,typescript,ts,v,vb,cmd,verilog,vhdl,viml,vim,vimscript,vue-html,vue,wasm,wenyan,文言,wgsl,xml,xsl,yaml,yml,zenscript".split(
    ","
  ),
  ...Object.keys(Mo)
], Mo = {
  "C++": "cpp",
  "C#": "csharp"
};
function Hge(n) {
  const e = n.renderer.rules.fence;
  n.renderer.rules.fence = (...t) => {
    const [o, r] = t, s = o[r];
    s.info = s.info.replace(/\[.*\]/, "");
    let a = Bo(s.info);
    Uge().includes(a) || (a = "plainText");
    const l = e(...t);
    return `<div class="language-${a}">${l}</div>`;
  };
}
function Vge(n) {
  var e;
  return ((e = n.match(/\[(.*)\]/)) == null ? void 0 : e[1]) || Bo(n) || "txt";
}
const Bo = (n) => n.trim().replace(/:(no-)?line-numbers({| |$).*/, "").replace(/(-vue|{| ).*$/, "").replace(/^vue-html$/, "template"), Wge = (n) => {
  n.use(...He("tip", "TIP", n)).use(...He("info", "INFO", n)).use(...He("warning", "WARNING", n)).use(...He("danger", "DANGER", n)).use(...He("details", "Details", n)).use(ln, "v-pre", {
    render: (e, t) => e[t].nesting === 1 ? `<div v-pre>
` : `</div>
`
  }).use(ln, "raw", {
    render: (e, t) => e[t].nesting === 1 ? `<div class="vp-raw">
` : `</div>
`
  }).use(...Zge());
};
function He(n, e, t) {
  return [
    ln,
    n,
    {
      render(o, r) {
        const s = o[r], a = s.info.trim().slice(n.length).trim();
        if (s.nesting === 1) {
          const c = t.renderInline(a || e);
          return n === "details" ? `<details class="${n} custom-block"><summary>${c}</summary>
` : `<div class="${n} custom-block"><p class="custom-block-title">${c}</p>
`;
        } else
          return n === "details" ? `</details>
` : `</div>
`;
      }
    }
  ];
}
function Zge() {
  return [
    ln,
    "code-group",
    {
      render(n, e) {
        if (n[e].nesting === 1) {
          const t = Xt(5);
          let o = "", r = 'checked="checked"';
          for (let s = e + 1; !(n[s].nesting === -1 && n[s].type === "container_code-group_close"); ++s)
            if (n[s].type === "fence" && n[s].tag === "code") {
              const a = Vge(n[s].info), c = Xt(7);
              o += `<input type="radio" name="group-${t}" id="tab-${c}" ${r}><label for="tab-${c}">${a}</label>`, r && (n[s].info += " active", r = "");
            }
          return `<div class="vp-code-group"><div class="tabs">${o}</div><div class="blocks">
`;
        }
        return `</div></div>
`;
      }
    }
  ];
}
var Fe = {}, Jge = {
  get exports() {
    return Fe;
  },
  set exports(n) {
    Fe = n;
  }
};
(function(n, e) {
  (function(t, o) {
    n.exports = o();
  })(fo, () => {
    return t = { 770: function(r, s, a) {
      var c = this && this.__importDefault || function(L) {
        return L && L.__esModule ? L : { default: L };
      };
      Object.defineProperty(s, "__esModule", { value: !0 }), s.setDefaultDebugCall = s.createOnigScanner = s.createOnigString = s.loadWASM = s.OnigScanner = s.OnigString = void 0;
      const l = c(a(418));
      let i = null, p = !1;
      class h {
        static _utf8ByteLength(_) {
          let k = 0;
          for (let w = 0, E = _.length; w < E; w++) {
            const y = _.charCodeAt(w);
            let u = y, g = !1;
            if (y >= 55296 && y <= 56319 && w + 1 < E) {
              const x = _.charCodeAt(w + 1);
              x >= 56320 && x <= 57343 && (u = 65536 + (y - 55296 << 10) | x - 56320, g = !0);
            }
            k += u <= 127 ? 1 : u <= 2047 ? 2 : u <= 65535 ? 3 : 4, g && w++;
          }
          return k;
        }
        constructor(_) {
          const k = _.length, w = h._utf8ByteLength(_), E = w !== k, y = E ? new Uint32Array(k + 1) : null;
          E && (y[k] = w);
          const u = E ? new Uint32Array(w + 1) : null;
          E && (u[w] = k);
          const g = new Uint8Array(w);
          let x = 0;
          for (let b = 0; b < k; b++) {
            const v = _.charCodeAt(b);
            let A = v, C = !1;
            if (v >= 55296 && v <= 56319 && b + 1 < k) {
              const D = _.charCodeAt(b + 1);
              D >= 56320 && D <= 57343 && (A = 65536 + (v - 55296 << 10) | D - 56320, C = !0);
            }
            E && (y[b] = x, C && (y[b + 1] = x), A <= 127 ? u[x + 0] = b : A <= 2047 ? (u[x + 0] = b, u[x + 1] = b) : A <= 65535 ? (u[x + 0] = b, u[x + 1] = b, u[x + 2] = b) : (u[x + 0] = b, u[x + 1] = b, u[x + 2] = b, u[x + 3] = b)), A <= 127 ? g[x++] = A : A <= 2047 ? (g[x++] = 192 | (1984 & A) >>> 6, g[x++] = 128 | (63 & A) >>> 0) : A <= 65535 ? (g[x++] = 224 | (61440 & A) >>> 12, g[x++] = 128 | (4032 & A) >>> 6, g[x++] = 128 | (63 & A) >>> 0) : (g[x++] = 240 | (1835008 & A) >>> 18, g[x++] = 128 | (258048 & A) >>> 12, g[x++] = 128 | (4032 & A) >>> 6, g[x++] = 128 | (63 & A) >>> 0), C && b++;
          }
          this.utf16Length = k, this.utf8Length = w, this.utf16Value = _, this.utf8Value = g, this.utf16OffsetToUtf8 = y, this.utf8OffsetToUtf16 = u;
        }
        createString(_) {
          const k = _._omalloc(this.utf8Length);
          return _.HEAPU8.set(this.utf8Value, k), k;
        }
      }
      class d {
        constructor(_) {
          if (this.id = ++d.LAST_ID, !i)
            throw new Error("Must invoke loadWASM first.");
          this._onigBinding = i, this.content = _;
          const k = new h(_);
          this.utf16Length = k.utf16Length, this.utf8Length = k.utf8Length, this.utf16OffsetToUtf8 = k.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = k.utf8OffsetToUtf16, this.utf8Length < 1e4 && !d._sharedPtrInUse ? (d._sharedPtr || (d._sharedPtr = i._omalloc(1e4)), d._sharedPtrInUse = !0, i.HEAPU8.set(k.utf8Value, d._sharedPtr), this.ptr = d._sharedPtr) : this.ptr = k.createString(i);
        }
        convertUtf8OffsetToUtf16(_) {
          return this.utf8OffsetToUtf16 ? _ < 0 ? 0 : _ > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[_] : _;
        }
        convertUtf16OffsetToUtf8(_) {
          return this.utf16OffsetToUtf8 ? _ < 0 ? 0 : _ > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[_] : _;
        }
        dispose() {
          this.ptr === d._sharedPtr ? d._sharedPtrInUse = !1 : this._onigBinding._ofree(this.ptr);
        }
      }
      s.OnigString = d, d.LAST_ID = 0, d._sharedPtr = 0, d._sharedPtrInUse = !1;
      class f {
        constructor(_) {
          if (!i)
            throw new Error("Must invoke loadWASM first.");
          const k = [], w = [];
          for (let g = 0, x = _.length; g < x; g++) {
            const b = new h(_[g]);
            k[g] = b.createString(i), w[g] = b.utf8Length;
          }
          const E = i._omalloc(4 * _.length);
          i.HEAPU32.set(k, E / 4);
          const y = i._omalloc(4 * _.length);
          i.HEAPU32.set(w, y / 4);
          const u = i._createOnigScanner(E, y, _.length);
          for (let g = 0, x = _.length; g < x; g++)
            i._ofree(k[g]);
          i._ofree(y), i._ofree(E), u === 0 && function(g) {
            throw new Error(g.UTF8ToString(g._getLastOnigError()));
          }(i), this._onigBinding = i, this._ptr = u;
        }
        dispose() {
          this._onigBinding._freeOnigScanner(this._ptr);
        }
        findNextMatchSync(_, k, w) {
          let E = p, y = 0;
          if (typeof w == "number" ? (8 & w && (E = !0), y = w) : typeof w == "boolean" && (E = w), typeof _ == "string") {
            _ = new d(_);
            const u = this._findNextMatchSync(_, k, E, y);
            return _.dispose(), u;
          }
          return this._findNextMatchSync(_, k, E, y);
        }
        _findNextMatchSync(_, k, w, E) {
          const y = this._onigBinding;
          let u;
          if (u = w ? y._findNextOnigScannerMatchDbg(this._ptr, _.id, _.ptr, _.utf8Length, _.convertUtf16OffsetToUtf8(k), E) : y._findNextOnigScannerMatch(this._ptr, _.id, _.ptr, _.utf8Length, _.convertUtf16OffsetToUtf8(k), E), u === 0)
            return null;
          const g = y.HEAPU32;
          let x = u / 4;
          const b = g[x++], v = g[x++];
          let A = [];
          for (let C = 0; C < v; C++) {
            const D = _.convertUtf8OffsetToUtf16(g[x++]), T = _.convertUtf8OffsetToUtf16(g[x++]);
            A[C] = { start: D, end: T, length: T - D };
          }
          return { index: b, captureIndices: A };
        }
      }
      s.OnigScanner = f;
      let m = !1, S = null;
      s.loadWASM = function(L) {
        if (m)
          return S;
        let _, k, w, E;
        if (m = !0, function(y) {
          return typeof y.instantiator == "function";
        }(L))
          _ = L.instantiator, k = L.print;
        else {
          let y;
          (function(u) {
            return u.data !== void 0;
          })(L) ? (y = L.data, k = L.print) : y = L, _ = function(u) {
            return typeof Response < "u" && u instanceof Response;
          }(y) ? typeof WebAssembly.instantiateStreaming == "function" ? function(u) {
            return (g) => WebAssembly.instantiateStreaming(u, g);
          }(y) : function(u) {
            return async (g) => {
              const x = await u.arrayBuffer();
              return WebAssembly.instantiate(x, g);
            };
          }(y) : function(u) {
            return (g) => WebAssembly.instantiate(u, g);
          }(y);
        }
        return S = new Promise((y, u) => {
          w = y, E = u;
        }), function(y, u, g, x) {
          (0, l.default)({ print: u, instantiateWasm: (b, v) => {
            if (typeof performance > "u") {
              const A = () => Date.now();
              b.env.emscripten_get_now = A, b.wasi_snapshot_preview1.emscripten_get_now = A;
            }
            return y(b).then((A) => v(A.instance), x), {};
          } }).then((b) => {
            i = b, g();
          });
        }(_, k, w, E), S;
      }, s.createOnigString = function(L) {
        return new d(L);
      }, s.createOnigScanner = function(L) {
        return new f(L);
      }, s.setDefaultDebugCall = function(L) {
        p = L;
      };
    }, 418: (r) => {
      var s = (typeof document < "u" && document.currentScript && document.currentScript.src, function(a) {
        var c, l, i = (a = a || {}) !== void 0 ? a : {};
        i.ready = new Promise(function(N, P) {
          c = N, l = P;
        });
        var p, h = Object.assign({}, i), d = !1, f = "";
        function m(N) {
          return i.locateFile ? i.locateFile(N, f) : f + N;
        }
        p = function(N) {
          let P;
          return typeof readbuffer == "function" ? new Uint8Array(readbuffer(N)) : (P = read(N, "binary"), E(typeof P == "object"), P);
        }, typeof scriptArgs < "u" && scriptArgs, typeof onig_print < "u" && (typeof console > "u" && (console = {}), console.log = onig_print, console.warn = console.error = typeof printErr < "u" ? printErr : onig_print);
        var S, L, _ = i.print || console.log.bind(console), k = i.printErr || console.warn.bind(console);
        Object.assign(i, h), h = null, i.arguments && i.arguments, i.thisProgram && i.thisProgram, i.quit && i.quit, i.wasmBinary && (S = i.wasmBinary), i.noExitRuntime, typeof WebAssembly != "object" && $("no native wasm support detected");
        var w = !1;
        function E(N, P) {
          N || $(P);
        }
        var y, u, g, x = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
        function b(N, P, X) {
          for (var se = P + X, W = P; N[W] && !(W >= se); )
            ++W;
          if (W - P > 16 && N.buffer && x)
            return x.decode(N.subarray(P, W));
          for (var H = ""; P < W; ) {
            var K = N[P++];
            if (128 & K) {
              var Re = 63 & N[P++];
              if ((224 & K) != 192) {
                var Ne = 63 & N[P++];
                if ((K = (240 & K) == 224 ? (15 & K) << 12 | Re << 6 | Ne : (7 & K) << 18 | Re << 12 | Ne << 6 | 63 & N[P++]) < 65536)
                  H += String.fromCharCode(K);
                else {
                  var at = K - 65536;
                  H += String.fromCharCode(55296 | at >> 10, 56320 | 1023 & at);
                }
              } else
                H += String.fromCharCode((31 & K) << 6 | Re);
            } else
              H += String.fromCharCode(K);
          }
          return H;
        }
        function v(N, P) {
          return N ? b(u, N, P) : "";
        }
        function A(N) {
          y = N, i.HEAP8 = new Int8Array(N), i.HEAP16 = new Int16Array(N), i.HEAP32 = new Int32Array(N), i.HEAPU8 = u = new Uint8Array(N), i.HEAPU16 = new Uint16Array(N), i.HEAPU32 = g = new Uint32Array(N), i.HEAPF32 = new Float32Array(N), i.HEAPF64 = new Float64Array(N);
        }
        i.INITIAL_MEMORY;
        var C = [], D = [], T = [];
        function q() {
          if (i.preRun)
            for (typeof i.preRun == "function" && (i.preRun = [i.preRun]); i.preRun.length; )
              M(i.preRun.shift());
          he(C);
        }
        function R() {
          he(D);
        }
        function F() {
          if (i.postRun)
            for (typeof i.postRun == "function" && (i.postRun = [i.postRun]); i.postRun.length; )
              Z(i.postRun.shift());
          he(T);
        }
        function M(N) {
          C.unshift(N);
        }
        function O(N) {
          D.unshift(N);
        }
        function Z(N) {
          T.unshift(N);
        }
        var J = 0, V = null;
        function G(N) {
          J++, i.monitorRunDependencies && i.monitorRunDependencies(J);
        }
        function z(N) {
          if (J--, i.monitorRunDependencies && i.monitorRunDependencies(J), J == 0 && V) {
            var P = V;
            V = null, P();
          }
        }
        function $(N) {
          i.onAbort && i.onAbort(N), k(N = "Aborted(" + N + ")"), w = !0, N += ". Build with -sASSERTIONS for more info.";
          var P = new WebAssembly.RuntimeError(N);
          throw l(P), P;
        }
        var Y, j, Q = "data:application/octet-stream;base64,";
        function U(N) {
          return N.startsWith(Q);
        }
        function oe(N) {
          try {
            if (N == Y && S)
              return new Uint8Array(S);
            if (p)
              return p(N);
            throw "both async and sync fetching of the wasm failed";
          } catch (P) {
            $(P);
          }
        }
        function ke() {
          return S || !d || typeof fetch != "function" ? Promise.resolve().then(function() {
            return oe(Y);
          }) : fetch(Y, { credentials: "same-origin" }).then(function(N) {
            if (!N.ok)
              throw "failed to load wasm binary file at '" + Y + "'";
            return N.arrayBuffer();
          }).catch(function() {
            return oe(Y);
          });
        }
        function Ue() {
          var N = { env: xe, wasi_snapshot_preview1: xe };
          function P(W, H) {
            var K = W.exports;
            i.asm = K, A((L = i.asm.memory).buffer), i.asm.__indirect_function_table, O(i.asm.__wasm_call_ctors), z();
          }
          function X(W) {
            P(W.instance);
          }
          function se(W) {
            return ke().then(function(H) {
              return WebAssembly.instantiate(H, N);
            }).then(function(H) {
              return H;
            }).then(W, function(H) {
              k("failed to asynchronously prepare wasm: " + H), $(H);
            });
          }
          if (G(), i.instantiateWasm)
            try {
              return i.instantiateWasm(N, P);
            } catch (W) {
              k("Module.instantiateWasm callback failed with error: " + W), l(W);
            }
          return (S || typeof WebAssembly.instantiateStreaming != "function" || U(Y) || typeof fetch != "function" ? se(X) : fetch(Y, { credentials: "same-origin" }).then(function(W) {
            return WebAssembly.instantiateStreaming(W, N).then(X, function(H) {
              return k("wasm streaming compile failed: " + H), k("falling back to ArrayBuffer instantiation"), se(X);
            });
          })).catch(l), {};
        }
        function he(N) {
          for (; N.length > 0; )
            N.shift()(i);
        }
        function fe(N, P, X) {
          u.copyWithin(N, P, P + X);
        }
        function qe(N) {
          try {
            return L.grow(N - y.byteLength + 65535 >>> 16), A(L.buffer), 1;
          } catch {
          }
        }
        function we(N) {
          var P, X = u.length, se = 2147483648;
          if ((N >>>= 0) > se)
            return !1;
          for (var W = 1; W <= 4; W *= 2) {
            var H = X * (1 + 0.2 / W);
            if (H = Math.min(H, N + 100663296), qe(Math.min(se, (P = Math.max(N, H)) + (65536 - P % 65536) % 65536)))
              return !0;
          }
          return !1;
        }
        U(Y = "onig.wasm") || (Y = m(Y)), j = typeof dateNow < "u" ? dateNow : () => performance.now();
        var ye = [null, [], []];
        function ve(N, P) {
          var X = ye[N];
          P === 0 || P === 10 ? ((N === 1 ? _ : k)(b(X, 0)), X.length = 0) : X.push(P);
        }
        function me(N, P, X, se) {
          for (var W = 0, H = 0; H < X; H++) {
            var K = g[P >> 2], Re = g[P + 4 >> 2];
            P += 8;
            for (var Ne = 0; Ne < Re; Ne++)
              ve(N, u[K + Ne]);
            W += Re;
          }
          return g[se >> 2] = W, 0;
        }
        var ee, xe = { emscripten_get_now: j, emscripten_memcpy_big: fe, emscripten_resize_heap: we, fd_write: me };
        function je(N) {
          function P() {
            ee || (ee = !0, i.calledRun = !0, w || (R(), c(i), i.onRuntimeInitialized && i.onRuntimeInitialized(), F()));
          }
          J > 0 || (q(), J > 0 || (i.setStatus ? (i.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              i.setStatus("");
            }, 1), P();
          }, 1)) : P()));
        }
        if (Ue(), i.___wasm_call_ctors = function() {
          return (i.___wasm_call_ctors = i.asm.__wasm_call_ctors).apply(null, arguments);
        }, i.___errno_location = function() {
          return (i.___errno_location = i.asm.__errno_location).apply(null, arguments);
        }, i._omalloc = function() {
          return (i._omalloc = i.asm.omalloc).apply(null, arguments);
        }, i._ofree = function() {
          return (i._ofree = i.asm.ofree).apply(null, arguments);
        }, i._getLastOnigError = function() {
          return (i._getLastOnigError = i.asm.getLastOnigError).apply(null, arguments);
        }, i._createOnigScanner = function() {
          return (i._createOnigScanner = i.asm.createOnigScanner).apply(null, arguments);
        }, i._freeOnigScanner = function() {
          return (i._freeOnigScanner = i.asm.freeOnigScanner).apply(null, arguments);
        }, i._findNextOnigScannerMatch = function() {
          return (i._findNextOnigScannerMatch = i.asm.findNextOnigScannerMatch).apply(null, arguments);
        }, i._findNextOnigScannerMatchDbg = function() {
          return (i._findNextOnigScannerMatchDbg = i.asm.findNextOnigScannerMatchDbg).apply(null, arguments);
        }, i.stackSave = function() {
          return (i.stackSave = i.asm.stackSave).apply(null, arguments);
        }, i.stackRestore = function() {
          return (i.stackRestore = i.asm.stackRestore).apply(null, arguments);
        }, i.stackAlloc = function() {
          return (i.stackAlloc = i.asm.stackAlloc).apply(null, arguments);
        }, i.dynCall_jiji = function() {
          return (i.dynCall_jiji = i.asm.dynCall_jiji).apply(null, arguments);
        }, i.UTF8ToString = v, V = function N() {
          ee || je(), ee || (V = N);
        }, i.preInit)
          for (typeof i.preInit == "function" && (i.preInit = [i.preInit]); i.preInit.length > 0; )
            i.preInit.pop()();
        return je(), a.ready;
      });
      r.exports = s;
    } }, o = {}, function r(s) {
      var a = o[s];
      if (a !== void 0)
        return a.exports;
      var c = o[s] = { exports: {} };
      return t[s].call(c.exports, c, c.exports, r), c.exports;
    }(770);
    var t, o;
  });
})(Jge);
var un = {}, Qge = {
  get exports() {
    return un;
  },
  set exports(n) {
    un = n;
  }
};
(function(n, e) {
  (function(t, o) {
    n.exports = o();
  })(fo, function() {
    return (() => {
      var t = { 350: (r, s) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.UseOnigurumaFindOptions = s.DebugFlags = void 0, s.DebugFlags = { InDebugMode: typeof process < "u" && !!process.env.VSCODE_TEXTMATE_DEBUG }, s.UseOnigurumaFindOptions = !1;
      }, 36: (r, s) => {
        var a;
        Object.defineProperty(s, "__esModule", { value: !0 }), s.toOptionalTokenType = s.EncodedTokenAttributes = void 0, (a = s.EncodedTokenAttributes || (s.EncodedTokenAttributes = {})).toBinaryStr = function(c) {
          let l = c.toString(2);
          for (; l.length < 32; )
            l = "0" + l;
          return l;
        }, a.print = function(c) {
          const l = a.getLanguageId(c), i = a.getTokenType(c), p = a.getFontStyle(c), h = a.getForeground(c), d = a.getBackground(c);
          console.log({ languageId: l, tokenType: i, fontStyle: p, foreground: h, background: d });
        }, a.getLanguageId = function(c) {
          return (255 & c) >>> 0;
        }, a.getTokenType = function(c) {
          return (768 & c) >>> 8;
        }, a.containsBalancedBrackets = function(c) {
          return (1024 & c) != 0;
        }, a.getFontStyle = function(c) {
          return (30720 & c) >>> 11;
        }, a.getForeground = function(c) {
          return (16744448 & c) >>> 15;
        }, a.getBackground = function(c) {
          return (4278190080 & c) >>> 24;
        }, a.set = function(c, l, i, p, h, d, f) {
          let m = a.getLanguageId(c), S = a.getTokenType(c), L = a.containsBalancedBrackets(c) ? 1 : 0, _ = a.getFontStyle(c), k = a.getForeground(c), w = a.getBackground(c);
          return l !== 0 && (m = l), i !== 8 && (S = i), p !== null && (L = p ? 1 : 0), h !== -1 && (_ = h), d !== 0 && (k = d), f !== 0 && (w = f), (m << 0 | S << 8 | L << 10 | _ << 11 | k << 15 | w << 24) >>> 0;
        }, s.toOptionalTokenType = function(c) {
          return c;
        };
      }, 996: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.BasicScopeAttributesProvider = s.BasicScopeAttributes = void 0;
        const c = a(878);
        class l {
          constructor(d, f) {
            this.languageId = d, this.tokenType = f;
          }
        }
        s.BasicScopeAttributes = l;
        class i {
          constructor(d, f) {
            this._getBasicScopeAttributes = new c.CachedFn((m) => {
              const S = this._scopeToLanguage(m), L = this._toStandardTokenType(m);
              return new l(S, L);
            }), this._defaultAttributes = new l(d, 8), this._embeddedLanguagesMatcher = new p(Object.entries(f || {}));
          }
          getDefaultAttributes() {
            return this._defaultAttributes;
          }
          getBasicScopeAttributes(d) {
            return d === null ? i._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(d);
          }
          _scopeToLanguage(d) {
            return this._embeddedLanguagesMatcher.match(d) || 0;
          }
          _toStandardTokenType(d) {
            const f = d.match(i.STANDARD_TOKEN_TYPE_REGEXP);
            if (!f)
              return 8;
            switch (f[1]) {
              case "comment":
                return 1;
              case "string":
                return 2;
              case "regex":
                return 3;
              case "meta.embedded":
                return 0;
            }
            throw new Error("Unexpected match for standard token type!");
          }
        }
        s.BasicScopeAttributesProvider = i, i._NULL_SCOPE_METADATA = new l(0, 0), i.STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
        class p {
          constructor(d) {
            if (d.length === 0)
              this.values = null, this.scopesRegExp = null;
            else {
              this.values = new Map(d);
              const f = d.map(([m, S]) => c.escapeRegExpCharacters(m));
              f.sort(), f.reverse(), this.scopesRegExp = new RegExp(`^((${f.join(")|(")}))($|\\.)`, "");
            }
          }
          match(d) {
            if (!this.scopesRegExp)
              return;
            const f = d.match(this.scopesRegExp);
            return f ? this.values.get(f[1]) : void 0;
          }
        }
      }, 947: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.LineTokens = s.BalancedBracketSelectors = s.StateStack = s.AttributedScopeStack = s.Grammar = s.createGrammar = void 0;
        const c = a(350), l = a(36), i = a(736), p = a(44), h = a(792), d = a(583), f = a(878), m = a(996), S = a(47);
        function L(x, b, v, A, C) {
          const D = i.createMatchers(b, _), T = h.RuleFactory.getCompiledRuleId(v, A, C.repository);
          for (const q of D)
            x.push({ debugSelector: b, matcher: q.matcher, ruleId: T, grammar: C, priority: q.priority });
        }
        function _(x, b) {
          if (b.length < x.length)
            return !1;
          let v = 0;
          return x.every((A) => {
            for (let C = v; C < b.length; C++)
              if (k(b[C], A))
                return v = C + 1, !0;
            return !1;
          });
        }
        function k(x, b) {
          if (!x)
            return !1;
          if (x === b)
            return !0;
          const v = b.length;
          return x.length > v && x.substr(0, v) === b && x[v] === ".";
        }
        s.createGrammar = function(x, b, v, A, C, D, T, q) {
          return new w(x, b, v, A, C, D, T, q);
        };
        class w {
          constructor(b, v, A, C, D, T, q, R) {
            if (this._rootScopeName = b, this.balancedBracketSelectors = T, this._onigLib = R, this._basicScopeAttributesProvider = new m.BasicScopeAttributesProvider(A, C), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = q, this._grammar = E(v, null), this._injections = null, this._tokenTypeMatchers = [], D)
              for (const F of Object.keys(D)) {
                const M = i.createMatchers(F, _);
                for (const O of M)
                  this._tokenTypeMatchers.push({ matcher: O.matcher, type: D[F] });
              }
          }
          get themeProvider() {
            return this._grammarRepository;
          }
          dispose() {
            for (const b of this._ruleId2desc)
              b && b.dispose();
          }
          createOnigScanner(b) {
            return this._onigLib.createOnigScanner(b);
          }
          createOnigString(b) {
            return this._onigLib.createOnigString(b);
          }
          getMetadataForScope(b) {
            return this._basicScopeAttributesProvider.getBasicScopeAttributes(b);
          }
          _collectInjections() {
            const b = [], v = this._rootScopeName, A = ((C) => C === this._rootScopeName ? this._grammar : this.getExternalGrammar(C))(v);
            if (A) {
              const C = A.injections;
              if (C)
                for (let T in C)
                  L(b, T, C[T], this, A);
              const D = this._grammarRepository.injections(v);
              D && D.forEach((T) => {
                const q = this.getExternalGrammar(T);
                if (q) {
                  const R = q.injectionSelector;
                  R && L(b, R, q, this, q);
                }
              });
            }
            return b.sort((C, D) => C.priority - D.priority), b;
          }
          getInjections() {
            if (this._injections === null && (this._injections = this._collectInjections(), c.DebugFlags.InDebugMode && this._injections.length > 0)) {
              console.log(`Grammar ${this._rootScopeName} contains the following injections:`);
              for (const b of this._injections)
                console.log(`  - ${b.debugSelector}`);
            }
            return this._injections;
          }
          registerRule(b) {
            const v = ++this._lastRuleId, A = b(h.ruleIdFromNumber(v));
            return this._ruleId2desc[v] = A, A;
          }
          getRule(b) {
            return this._ruleId2desc[h.ruleIdToNumber(b)];
          }
          getExternalGrammar(b, v) {
            if (this._includedGrammars[b])
              return this._includedGrammars[b];
            if (this._grammarRepository) {
              const A = this._grammarRepository.lookup(b);
              if (A)
                return this._includedGrammars[b] = E(A, v && v.$base), this._includedGrammars[b];
            }
          }
          tokenizeLine(b, v, A = 0) {
            const C = this._tokenize(b, v, !1, A);
            return { tokens: C.lineTokens.getResult(C.ruleStack, C.lineLength), ruleStack: C.ruleStack, stoppedEarly: C.stoppedEarly };
          }
          tokenizeLine2(b, v, A = 0) {
            const C = this._tokenize(b, v, !0, A);
            return { tokens: C.lineTokens.getBinaryResult(C.ruleStack, C.lineLength), ruleStack: C.ruleStack, stoppedEarly: C.stoppedEarly };
          }
          _tokenize(b, v, A, C) {
            let D;
            if (this._rootId === -1 && (this._rootId = h.RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository)), v && v !== u.NULL)
              D = !1, v.reset();
            else {
              D = !0;
              const M = this._basicScopeAttributesProvider.getDefaultAttributes(), O = this.themeProvider.getDefaults(), Z = l.EncodedTokenAttributes.set(0, M.languageId, M.tokenType, null, O.fontStyle, O.foregroundId, O.backgroundId), J = this.getRule(this._rootId).getName(null, null);
              let V;
              V = J ? y.createRootAndLookUpScopeName(J, Z, this) : y.createRoot("unknown", Z), v = new u(null, this._rootId, -1, -1, !1, null, V, V);
            }
            b += `
`;
            const T = this.createOnigString(b), q = T.content.length, R = new g(A, b, this._tokenTypeMatchers, this.balancedBracketSelectors), F = S._tokenizeString(this, T, D, 0, v, R, !0, C);
            return p.disposeOnigString(T), { lineLength: q, lineTokens: R, ruleStack: F.stack, stoppedEarly: F.stoppedEarly };
          }
        }
        function E(x, b) {
          return (x = f.clone(x)).repository = x.repository || {}, x.repository.$self = { $vscodeTextmateLocation: x.$vscodeTextmateLocation, patterns: x.patterns, name: x.scopeName }, x.repository.$base = b || x.repository.$self, x;
        }
        s.Grammar = w;
        class y {
          constructor(b, v, A) {
            this.parent = b, this.scopePath = v, this.tokenAttributes = A;
          }
          static createRoot(b, v) {
            return new y(null, new d.ScopeStack(null, b), v);
          }
          static createRootAndLookUpScopeName(b, v, A) {
            const C = A.getMetadataForScope(b), D = new d.ScopeStack(null, b), T = A.themeProvider.themeMatch(D), q = y.mergeAttributes(v, C, T);
            return new y(null, D, q);
          }
          get scopeName() {
            return this.scopePath.scopeName;
          }
          equals(b) {
            return y._equals(this, b);
          }
          static _equals(b, v) {
            for (; ; ) {
              if (b === v || !b && !v)
                return !0;
              if (!b || !v || b.scopeName !== v.scopeName || b.tokenAttributes !== v.tokenAttributes)
                return !1;
              b = b.parent, v = v.parent;
            }
          }
          static mergeAttributes(b, v, A) {
            let C = -1, D = 0, T = 0;
            return A !== null && (C = A.fontStyle, D = A.foregroundId, T = A.backgroundId), l.EncodedTokenAttributes.set(b, v.languageId, v.tokenType, null, C, D, T);
          }
          pushAttributed(b, v) {
            if (b === null)
              return this;
            if (b.indexOf(" ") === -1)
              return y._pushAttributed(this, b, v);
            const A = b.split(/ /g);
            let C = this;
            for (const D of A)
              C = y._pushAttributed(C, D, v);
            return C;
          }
          static _pushAttributed(b, v, A) {
            const C = A.getMetadataForScope(v), D = b.scopePath.push(v), T = A.themeProvider.themeMatch(D), q = y.mergeAttributes(b.tokenAttributes, C, T);
            return new y(b, D, q);
          }
          getScopeNames() {
            return this.scopePath.getSegments();
          }
        }
        s.AttributedScopeStack = y;
        class u {
          constructor(b, v, A, C, D, T, q, R) {
            this.parent = b, this.ruleId = v, this.beginRuleCapturedEOL = D, this.endRule = T, this.nameScopesList = q, this.contentNameScopesList = R, this._stackElementBrand = void 0, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = A, this._anchorPos = C;
          }
          equals(b) {
            return b !== null && u._equals(this, b);
          }
          static _equals(b, v) {
            return b === v || !!this._structuralEquals(b, v) && b.contentNameScopesList.equals(v.contentNameScopesList);
          }
          static _structuralEquals(b, v) {
            for (; ; ) {
              if (b === v || !b && !v)
                return !0;
              if (!b || !v || b.depth !== v.depth || b.ruleId !== v.ruleId || b.endRule !== v.endRule)
                return !1;
              b = b.parent, v = v.parent;
            }
          }
          clone() {
            return this;
          }
          static _reset(b) {
            for (; b; )
              b._enterPos = -1, b._anchorPos = -1, b = b.parent;
          }
          reset() {
            u._reset(this);
          }
          pop() {
            return this.parent;
          }
          safePop() {
            return this.parent ? this.parent : this;
          }
          push(b, v, A, C, D, T, q) {
            return new u(this, b, v, A, C, D, T, q);
          }
          getEnterPos() {
            return this._enterPos;
          }
          getAnchorPos() {
            return this._anchorPos;
          }
          getRule(b) {
            return b.getRule(this.ruleId);
          }
          toString() {
            const b = [];
            return this._writeString(b, 0), "[" + b.join(",") + "]";
          }
          _writeString(b, v) {
            return this.parent && (v = this.parent._writeString(b, v)), b[v++] = `(${this.ruleId}, TODO-${this.nameScopesList}, TODO-${this.contentNameScopesList})`, v;
          }
          withContentNameScopesList(b) {
            return this.contentNameScopesList === b ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, b);
          }
          withEndRule(b) {
            return this.endRule === b ? this : new u(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, b, this.nameScopesList, this.contentNameScopesList);
          }
          hasSameRuleAs(b) {
            let v = this;
            for (; v && v._enterPos === b._enterPos; ) {
              if (v.ruleId === b.ruleId)
                return !0;
              v = v.parent;
            }
            return !1;
          }
        }
        s.StateStack = u, u.NULL = new u(null, 0, 0, 0, !1, null, null, null), s.BalancedBracketSelectors = class {
          constructor(x, b) {
            this.allowAny = !1, this.balancedBracketScopes = x.flatMap((v) => v === "*" ? (this.allowAny = !0, []) : i.createMatchers(v, _).map((A) => A.matcher)), this.unbalancedBracketScopes = b.flatMap((v) => i.createMatchers(v, _).map((A) => A.matcher));
          }
          get matchesAlways() {
            return this.allowAny && this.unbalancedBracketScopes.length === 0;
          }
          get matchesNever() {
            return this.balancedBracketScopes.length === 0 && !this.allowAny;
          }
          match(x) {
            for (const b of this.unbalancedBracketScopes)
              if (b(x))
                return !1;
            for (const b of this.balancedBracketScopes)
              if (b(x))
                return !0;
            return this.allowAny;
          }
        };
        class g {
          constructor(b, v, A, C) {
            this.balancedBracketSelectors = C, this._emitBinaryTokens = b, this._tokenTypeOverrides = A, c.DebugFlags.InDebugMode ? this._lineText = v : this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
          }
          produce(b, v) {
            this.produceFromScopes(b.contentNameScopesList, v);
          }
          produceFromScopes(b, v) {
            var C;
            if (this._lastTokenEndIndex >= v)
              return;
            if (this._emitBinaryTokens) {
              let D = b.tokenAttributes, T = !1;
              if ((C = this.balancedBracketSelectors) != null && C.matchesAlways && (T = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
                const q = b.getScopeNames();
                for (const R of this._tokenTypeOverrides)
                  R.matcher(q) && (D = l.EncodedTokenAttributes.set(D, 0, l.toOptionalTokenType(R.type), null, -1, 0, 0));
                this.balancedBracketSelectors && (T = this.balancedBracketSelectors.match(q));
              }
              if (T && (D = l.EncodedTokenAttributes.set(D, 0, 8, T, -1, 0, 0)), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === D)
                return void (this._lastTokenEndIndex = v);
              if (c.DebugFlags.InDebugMode) {
                const q = b.getScopeNames();
                console.log("  token: |" + this._lineText.substring(this._lastTokenEndIndex, v).replace(/\n$/, "\\n") + "|");
                for (let R = 0; R < q.length; R++)
                  console.log("      * " + q[R]);
              }
              return this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(D), void (this._lastTokenEndIndex = v);
            }
            const A = b.getScopeNames();
            if (c.DebugFlags.InDebugMode) {
              console.log("  token: |" + this._lineText.substring(this._lastTokenEndIndex, v).replace(/\n$/, "\\n") + "|");
              for (let D = 0; D < A.length; D++)
                console.log("      * " + A[D]);
            }
            this._tokens.push({ startIndex: this._lastTokenEndIndex, endIndex: v, scopes: A }), this._lastTokenEndIndex = v;
          }
          getResult(b, v) {
            return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === v - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(b, v), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
          }
          getBinaryResult(b, v) {
            this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === v - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(b, v), this._binaryTokens[this._binaryTokens.length - 2] = 0);
            const A = new Uint32Array(this._binaryTokens.length);
            for (let C = 0, D = this._binaryTokens.length; C < D; C++)
              A[C] = this._binaryTokens[C];
            return A;
          }
        }
        s.LineTokens = g;
      }, 965: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.parseInclude = s.TopLevelRepositoryReference = s.TopLevelReference = s.RelativeReference = s.SelfReference = s.BaseReference = s.ScopeDependencyProcessor = s.ExternalReferenceCollector = s.TopLevelRepositoryRuleReference = s.TopLevelRuleReference = void 0;
        const c = a(878);
        class l {
          constructor(u) {
            this.scopeName = u;
          }
          toKey() {
            return this.scopeName;
          }
        }
        s.TopLevelRuleReference = l;
        class i {
          constructor(u, g) {
            this.scopeName = u, this.ruleName = g;
          }
          toKey() {
            return `${this.scopeName}#${this.ruleName}`;
          }
        }
        s.TopLevelRepositoryRuleReference = i;
        class p {
          constructor() {
            this._references = [], this._seenReferenceKeys = /* @__PURE__ */ new Set(), this.visitedRule = /* @__PURE__ */ new Set();
          }
          get references() {
            return this._references;
          }
          add(u) {
            const g = u.toKey();
            this._seenReferenceKeys.has(g) || (this._seenReferenceKeys.add(g), this._references.push(u));
          }
        }
        function h(y, u, g, x) {
          const b = g.lookup(y.scopeName);
          if (!b) {
            if (y.scopeName === u)
              throw new Error(`No grammar provided for <${u}>`);
            return;
          }
          const v = g.lookup(u);
          y instanceof l ? f({ baseGrammar: v, selfGrammar: b }, x) : d(y.ruleName, { baseGrammar: v, selfGrammar: b, repository: b.repository }, x);
          const A = g.injections(y.scopeName);
          if (A)
            for (const C of A)
              x.add(new l(C));
        }
        function d(y, u, g) {
          u.repository && u.repository[y] && m([u.repository[y]], u, g);
        }
        function f(y, u) {
          y.selfGrammar.patterns && Array.isArray(y.selfGrammar.patterns) && m(y.selfGrammar.patterns, { ...y, repository: y.selfGrammar.repository }, u), y.selfGrammar.injections && m(Object.values(y.selfGrammar.injections), { ...y, repository: y.selfGrammar.repository }, u);
        }
        function m(y, u, g) {
          for (const x of y) {
            if (g.visitedRule.has(x))
              continue;
            g.visitedRule.add(x);
            const b = x.repository ? c.mergeObjects({}, u.repository, x.repository) : u.repository;
            Array.isArray(x.patterns) && m(x.patterns, { ...u, repository: b }, g);
            const v = x.include;
            if (!v)
              continue;
            const A = E(v);
            switch (A.kind) {
              case 0:
                f({ ...u, selfGrammar: u.baseGrammar }, g);
                break;
              case 1:
                f(u, g);
                break;
              case 2:
                d(A.ruleName, { ...u, repository: b }, g);
                break;
              case 3:
              case 4:
                const C = A.scopeName === u.selfGrammar.scopeName ? u.selfGrammar : A.scopeName === u.baseGrammar.scopeName ? u.baseGrammar : void 0;
                if (C) {
                  const D = { baseGrammar: u.baseGrammar, selfGrammar: C, repository: b };
                  A.kind === 4 ? d(A.ruleName, D, g) : f(D, g);
                } else
                  A.kind === 4 ? g.add(new i(A.scopeName, A.ruleName)) : g.add(new l(A.scopeName));
            }
          }
        }
        s.ExternalReferenceCollector = p, s.ScopeDependencyProcessor = class {
          constructor(y, u) {
            this.repo = y, this.initialScopeName = u, this.seenFullScopeRequests = /* @__PURE__ */ new Set(), this.seenPartialScopeRequests = /* @__PURE__ */ new Set(), this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new l(this.initialScopeName)];
          }
          processQueue() {
            const y = this.Q;
            this.Q = [];
            const u = new p();
            for (const g of y)
              h(g, this.initialScopeName, this.repo, u);
            for (const g of u.references)
              if (g instanceof l) {
                if (this.seenFullScopeRequests.has(g.scopeName))
                  continue;
                this.seenFullScopeRequests.add(g.scopeName), this.Q.push(g);
              } else {
                if (this.seenFullScopeRequests.has(g.scopeName) || this.seenPartialScopeRequests.has(g.toKey()))
                  continue;
                this.seenPartialScopeRequests.add(g.toKey()), this.Q.push(g);
              }
          }
        };
        class S {
          constructor() {
            this.kind = 0;
          }
        }
        s.BaseReference = S;
        class L {
          constructor() {
            this.kind = 1;
          }
        }
        s.SelfReference = L;
        class _ {
          constructor(u) {
            this.ruleName = u, this.kind = 2;
          }
        }
        s.RelativeReference = _;
        class k {
          constructor(u) {
            this.scopeName = u, this.kind = 3;
          }
        }
        s.TopLevelReference = k;
        class w {
          constructor(u, g) {
            this.scopeName = u, this.ruleName = g, this.kind = 4;
          }
        }
        function E(y) {
          if (y === "$base")
            return new S();
          if (y === "$self")
            return new L();
          const u = y.indexOf("#");
          if (u === -1)
            return new k(y);
          if (u === 0)
            return new _(y.substring(1));
          {
            const g = y.substring(0, u), x = y.substring(u + 1);
            return new w(g, x);
          }
        }
        s.TopLevelRepositoryReference = w, s.parseInclude = E;
      }, 391: function(r, s, a) {
        var c = this && this.__createBinding || (Object.create ? function(i, p, h, d) {
          d === void 0 && (d = h), Object.defineProperty(i, d, { enumerable: !0, get: function() {
            return p[h];
          } });
        } : function(i, p, h, d) {
          d === void 0 && (d = h), i[d] = p[h];
        }), l = this && this.__exportStar || function(i, p) {
          for (var h in i)
            h === "default" || Object.prototype.hasOwnProperty.call(p, h) || c(p, i, h);
        };
        Object.defineProperty(s, "__esModule", { value: !0 }), l(a(947), s);
      }, 47: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.LocalStackElement = s._tokenizeString = void 0;
        const c = a(350), l = a(44), i = a(792), p = a(878);
        class h {
          constructor(w, E) {
            this.stack = w, this.stoppedEarly = E;
          }
        }
        function d(k, w, E, y, u, g, x, b) {
          const v = w.content.length;
          let A = !1, C = -1;
          if (x) {
            const q = function(R, F, M, O, Z, J) {
              let V = Z.beginRuleCapturedEOL ? 0 : -1;
              const G = [];
              for (let z = Z; z; z = z.pop()) {
                const $ = z.getRule(R);
                $ instanceof i.BeginWhileRule && G.push({ rule: $, stack: z });
              }
              for (let z = G.pop(); z; z = G.pop()) {
                const { ruleScanner: $, findOptions: Y } = m(z.rule, R, z.stack.endRule, M, O === V), j = $.findNextMatchSync(F, O, Y);
                if (c.DebugFlags.InDebugMode && (console.log("  scanning for while rule"), console.log($.toString())), !j) {
                  c.DebugFlags.InDebugMode && console.log("  popping " + z.rule.debugName + " - " + z.rule.debugWhileRegExp), Z = z.stack.pop();
                  break;
                }
                if (j.ruleId !== i.whileRuleId) {
                  Z = z.stack.pop();
                  break;
                }
                j.captureIndices && j.captureIndices.length && (J.produce(z.stack, j.captureIndices[0].start), L(R, F, M, z.stack, J, z.rule.whileCaptures, j.captureIndices), J.produce(z.stack, j.captureIndices[0].end), V = j.captureIndices[0].end, j.captureIndices[0].end > O && (O = j.captureIndices[0].end, M = !1));
              }
              return { stack: Z, linePos: O, anchorPosition: V, isFirstLine: M };
            }(k, w, E, y, u, g);
            u = q.stack, y = q.linePos, E = q.isFirstLine, C = q.anchorPosition;
          }
          const D = Date.now();
          for (; !A; ) {
            if (b !== 0 && Date.now() - D > b)
              return new h(u, !0);
            T();
          }
          return new h(u, !1);
          function T() {
            c.DebugFlags.InDebugMode && (console.log(""), console.log(`@@scanNext ${y}: |${w.content.substr(y).replace(/\n$/, "\\n")}|`));
            const q = function(O, Z, J, V, G, z) {
              const $ = function(oe, ke, Ue, he, fe, qe) {
                const we = fe.getRule(oe), { ruleScanner: ye, findOptions: ve } = f(we, oe, fe.endRule, Ue, he === qe);
                let me = 0;
                c.DebugFlags.InDebugMode && (me = p.performanceNow());
                const ee = ye.findNextMatchSync(ke, he, ve);
                if (c.DebugFlags.InDebugMode) {
                  const xe = p.performanceNow() - me;
                  xe > 5 && console.warn(`Rule ${we.debugName} (${we.id}) matching took ${xe} against '${ke}'`), console.log(`  scanning for (linePos: ${he}, anchorPosition: ${qe})`), console.log(ye.toString()), ee && console.log(`matched rule id: ${ee.ruleId} from ${ee.captureIndices[0].start} to ${ee.captureIndices[0].end}`);
                }
                return ee ? { captureIndices: ee.captureIndices, matchedRuleId: ee.ruleId } : null;
              }(O, Z, J, V, G, z), Y = O.getInjections();
              if (Y.length === 0)
                return $;
              const j = function(oe, ke, Ue, he, fe, qe, we) {
                let ye, ve = Number.MAX_VALUE, me = null, ee = 0;
                const xe = qe.contentNameScopesList.getScopeNames();
                for (let je = 0, N = oe.length; je < N; je++) {
                  const P = oe[je];
                  if (!P.matcher(xe))
                    continue;
                  const X = ke.getRule(P.ruleId), { ruleScanner: se, findOptions: W } = f(X, ke, null, he, fe === we), H = se.findNextMatchSync(Ue, fe, W);
                  if (!H)
                    continue;
                  c.DebugFlags.InDebugMode && (console.log(`  matched injection: ${P.debugSelector}`), console.log(se.toString()));
                  const K = H.captureIndices[0].start;
                  if (!(K >= ve) && (ve = K, me = H.captureIndices, ye = H.ruleId, ee = P.priority, ve === fe))
                    break;
                }
                return me ? { priorityMatch: ee === -1, captureIndices: me, matchedRuleId: ye } : null;
              }(Y, O, Z, J, V, G, z);
              if (!j)
                return $;
              if (!$)
                return j;
              const Q = $.captureIndices[0].start, U = j.captureIndices[0].start;
              return U < Q || j.priorityMatch && U === Q ? j : $;
            }(k, w, E, y, u, C);
            if (!q)
              return c.DebugFlags.InDebugMode && console.log("  no more matches."), g.produce(u, v), void (A = !0);
            const R = q.captureIndices, F = q.matchedRuleId, M = !!(R && R.length > 0) && R[0].end > y;
            if (F === i.endRuleId) {
              const O = u.getRule(k);
              c.DebugFlags.InDebugMode && console.log("  popping " + O.debugName + " - " + O.debugEndRegExp), g.produce(u, R[0].start), u = u.withContentNameScopesList(u.nameScopesList), L(k, w, E, u, g, O.endCaptures, R), g.produce(u, R[0].end);
              const Z = u;
              if (u = u.parent, C = Z.getAnchorPos(), !M && Z.getEnterPos() === y)
                return c.DebugFlags.InDebugMode && console.error("[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing"), u = Z, g.produce(u, v), void (A = !0);
            } else {
              const O = k.getRule(F);
              g.produce(u, R[0].start);
              const Z = u, J = O.getName(w.content, R), V = u.contentNameScopesList.pushAttributed(J, k);
              if (u = u.push(F, y, C, R[0].end === v, null, V, V), O instanceof i.BeginEndRule) {
                const G = O;
                c.DebugFlags.InDebugMode && console.log("  pushing " + G.debugName + " - " + G.debugBeginRegExp), L(k, w, E, u, g, G.beginCaptures, R), g.produce(u, R[0].end), C = R[0].end;
                const z = G.getContentName(w.content, R), $ = V.pushAttributed(z, k);
                if (u = u.withContentNameScopesList($), G.endHasBackReferences && (u = u.withEndRule(G.getEndWithResolvedBackReferences(w.content, R))), !M && Z.hasSameRuleAs(u))
                  return c.DebugFlags.InDebugMode && console.error("[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), u = u.pop(), g.produce(u, v), void (A = !0);
              } else if (O instanceof i.BeginWhileRule) {
                const G = O;
                c.DebugFlags.InDebugMode && console.log("  pushing " + G.debugName), L(k, w, E, u, g, G.beginCaptures, R), g.produce(u, R[0].end), C = R[0].end;
                const z = G.getContentName(w.content, R), $ = V.pushAttributed(z, k);
                if (u = u.withContentNameScopesList($), G.whileHasBackReferences && (u = u.withEndRule(G.getWhileWithResolvedBackReferences(w.content, R))), !M && Z.hasSameRuleAs(u))
                  return c.DebugFlags.InDebugMode && console.error("[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), u = u.pop(), g.produce(u, v), void (A = !0);
              } else {
                const G = O;
                if (c.DebugFlags.InDebugMode && console.log("  matched " + G.debugName + " - " + G.debugMatchRegExp), L(k, w, E, u, g, G.captures, R), g.produce(u, R[0].end), u = u.pop(), !M)
                  return c.DebugFlags.InDebugMode && console.error("[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping"), u = u.safePop(), g.produce(u, v), void (A = !0);
              }
            }
            R[0].end > y && (y = R[0].end, E = !1);
          }
        }
        function f(k, w, E, y, u) {
          return c.UseOnigurumaFindOptions ? { ruleScanner: k.compile(w, E), findOptions: S(y, u) } : { ruleScanner: k.compileAG(w, E, y, u), findOptions: 0 };
        }
        function m(k, w, E, y, u) {
          return c.UseOnigurumaFindOptions ? { ruleScanner: k.compileWhile(w, E), findOptions: S(y, u) } : { ruleScanner: k.compileWhileAG(w, E, y, u), findOptions: 0 };
        }
        function S(k, w) {
          let E = 0;
          return k || (E |= 1), w || (E |= 4), E;
        }
        function L(k, w, E, y, u, g, x) {
          if (g.length === 0)
            return;
          const b = w.content, v = Math.min(g.length, x.length), A = [], C = x[0].end;
          for (let D = 0; D < v; D++) {
            const T = g[D];
            if (T === null)
              continue;
            const q = x[D];
            if (q.length === 0)
              continue;
            if (q.start > C)
              break;
            for (; A.length > 0 && A[A.length - 1].endPos <= q.start; )
              u.produceFromScopes(A[A.length - 1].scopes, A[A.length - 1].endPos), A.pop();
            if (A.length > 0 ? u.produceFromScopes(A[A.length - 1].scopes, q.start) : u.produce(y, q.start), T.retokenizeCapturedWithRuleId) {
              const F = T.getName(b, x), M = y.contentNameScopesList.pushAttributed(F, k), O = T.getContentName(b, x), Z = M.pushAttributed(O, k), J = y.push(T.retokenizeCapturedWithRuleId, q.start, -1, !1, null, M, Z), V = k.createOnigString(b.substring(0, q.end));
              d(k, V, E && q.start === 0, q.start, J, u, !1, 0), l.disposeOnigString(V);
              continue;
            }
            const R = T.getName(b, x);
            if (R !== null) {
              const F = (A.length > 0 ? A[A.length - 1].scopes : y.contentNameScopesList).pushAttributed(R, k);
              A.push(new _(F, q.end));
            }
          }
          for (; A.length > 0; )
            u.produceFromScopes(A[A.length - 1].scopes, A[A.length - 1].endPos), A.pop();
        }
        s._tokenizeString = d;
        class _ {
          constructor(w, E) {
            this.scopes = w, this.endPos = E;
          }
        }
        s.LocalStackElement = _;
      }, 974: (r, s) => {
        function a(p, h) {
          throw new Error("Near offset " + p.pos + ": " + h + " ~~~" + p.source.substr(p.pos, 50) + "~~~");
        }
        Object.defineProperty(s, "__esModule", { value: !0 }), s.parseJSON = void 0, s.parseJSON = function(p, h, d) {
          let f = new c(p), m = new l(), S = 0, L = null, _ = [], k = [];
          function w() {
            _.push(S), k.push(L);
          }
          function E() {
            S = _.pop(), L = k.pop();
          }
          function y(u) {
            a(f, u);
          }
          for (; i(f, m); ) {
            if (S === 0) {
              if (L !== null && y("too many constructs in root"), m.type === 3) {
                L = {}, d && (L.$vscodeTextmateLocation = m.toLocation(h)), w(), S = 1;
                continue;
              }
              if (m.type === 2) {
                L = [], w(), S = 4;
                continue;
              }
              y("unexpected token in root");
            }
            if (S === 2) {
              if (m.type === 5) {
                E();
                continue;
              }
              if (m.type === 7) {
                S = 3;
                continue;
              }
              y("expected , or }");
            }
            if (S === 1 || S === 3) {
              if (S === 1 && m.type === 5) {
                E();
                continue;
              }
              if (m.type === 1) {
                let u = m.value;
                if (i(f, m) && m.type === 6 || y("expected colon"), i(f, m) || y("expected value"), S = 2, m.type === 1) {
                  L[u] = m.value;
                  continue;
                }
                if (m.type === 8) {
                  L[u] = null;
                  continue;
                }
                if (m.type === 9) {
                  L[u] = !0;
                  continue;
                }
                if (m.type === 10) {
                  L[u] = !1;
                  continue;
                }
                if (m.type === 11) {
                  L[u] = parseFloat(m.value);
                  continue;
                }
                if (m.type === 2) {
                  let g = [];
                  L[u] = g, w(), S = 4, L = g;
                  continue;
                }
                if (m.type === 3) {
                  let g = {};
                  d && (g.$vscodeTextmateLocation = m.toLocation(h)), L[u] = g, w(), S = 1, L = g;
                  continue;
                }
              }
              y("unexpected token in dict");
            }
            if (S === 5) {
              if (m.type === 4) {
                E();
                continue;
              }
              if (m.type === 7) {
                S = 6;
                continue;
              }
              y("expected , or ]");
            }
            if (S === 4 || S === 6) {
              if (S === 4 && m.type === 4) {
                E();
                continue;
              }
              if (S = 5, m.type === 1) {
                L.push(m.value);
                continue;
              }
              if (m.type === 8) {
                L.push(null);
                continue;
              }
              if (m.type === 9) {
                L.push(!0);
                continue;
              }
              if (m.type === 10) {
                L.push(!1);
                continue;
              }
              if (m.type === 11) {
                L.push(parseFloat(m.value));
                continue;
              }
              if (m.type === 2) {
                let u = [];
                L.push(u), w(), S = 4, L = u;
                continue;
              }
              if (m.type === 3) {
                let u = {};
                d && (u.$vscodeTextmateLocation = m.toLocation(h)), L.push(u), w(), S = 1, L = u;
                continue;
              }
              y("unexpected token in array");
            }
            y("unknown state");
          }
          return k.length !== 0 && y("unclosed constructs"), L;
        };
        class c {
          constructor(h) {
            this.source = h, this.pos = 0, this.len = h.length, this.line = 1, this.char = 0;
          }
        }
        class l {
          constructor() {
            this.value = null, this.type = 0, this.offset = -1, this.len = -1, this.line = -1, this.char = -1;
          }
          toLocation(h) {
            return { filename: h, line: this.line, char: this.char };
          }
        }
        function i(p, h) {
          h.value = null, h.type = 0, h.offset = -1, h.len = -1, h.line = -1, h.char = -1;
          let d, f = p.source, m = p.pos, S = p.len, L = p.line, _ = p.char;
          for (; ; ) {
            if (m >= S)
              return !1;
            if (d = f.charCodeAt(m), d !== 32 && d !== 9 && d !== 13) {
              if (d !== 10)
                break;
              m++, L++, _ = 0;
            } else
              m++, _++;
          }
          if (h.offset = m, h.line = L, h.char = _, d === 34) {
            for (h.type = 1, m++, _++; ; ) {
              if (m >= S)
                return !1;
              if (d = f.charCodeAt(m), m++, _++, d !== 92) {
                if (d === 34)
                  break;
              } else
                m++, _++;
            }
            h.value = f.substring(h.offset + 1, m - 1).replace(/\\u([0-9A-Fa-f]{4})/g, (k, w) => String.fromCodePoint(parseInt(w, 16))).replace(/\\(.)/g, (k, w) => {
              switch (w) {
                case '"':
                  return '"';
                case "\\":
                  return "\\";
                case "/":
                  return "/";
                case "b":
                  return "\b";
                case "f":
                  return "\f";
                case "n":
                  return `
`;
                case "r":
                  return "\r";
                case "t":
                  return "	";
                default:
                  a(p, "invalid escape sequence");
              }
              throw new Error("unreachable");
            });
          } else if (d === 91)
            h.type = 2, m++, _++;
          else if (d === 123)
            h.type = 3, m++, _++;
          else if (d === 93)
            h.type = 4, m++, _++;
          else if (d === 125)
            h.type = 5, m++, _++;
          else if (d === 58)
            h.type = 6, m++, _++;
          else if (d === 44)
            h.type = 7, m++, _++;
          else if (d === 110) {
            if (h.type = 8, m++, _++, d = f.charCodeAt(m), d !== 117 || (m++, _++, d = f.charCodeAt(m), d !== 108) || (m++, _++, d = f.charCodeAt(m), d !== 108))
              return !1;
            m++, _++;
          } else if (d === 116) {
            if (h.type = 9, m++, _++, d = f.charCodeAt(m), d !== 114 || (m++, _++, d = f.charCodeAt(m), d !== 117) || (m++, _++, d = f.charCodeAt(m), d !== 101))
              return !1;
            m++, _++;
          } else if (d === 102) {
            if (h.type = 10, m++, _++, d = f.charCodeAt(m), d !== 97 || (m++, _++, d = f.charCodeAt(m), d !== 108) || (m++, _++, d = f.charCodeAt(m), d !== 115) || (m++, _++, d = f.charCodeAt(m), d !== 101))
              return !1;
            m++, _++;
          } else
            for (h.type = 11; ; ) {
              if (m >= S)
                return !1;
              if (d = f.charCodeAt(m), !(d === 46 || d >= 48 && d <= 57 || d === 101 || d === 69 || d === 45 || d === 43))
                break;
              m++, _++;
            }
          return h.len = m - h.offset, h.value === null && (h.value = f.substr(h.offset, h.len)), p.pos = m, p.line = L, p.char = _, !0;
        }
      }, 787: function(r, s, a) {
        var c = this && this.__createBinding || (Object.create ? function(m, S, L, _) {
          _ === void 0 && (_ = L), Object.defineProperty(m, _, { enumerable: !0, get: function() {
            return S[L];
          } });
        } : function(m, S, L, _) {
          _ === void 0 && (_ = L), m[_] = S[L];
        }), l = this && this.__exportStar || function(m, S) {
          for (var L in m)
            L === "default" || Object.prototype.hasOwnProperty.call(S, L) || c(S, m, L);
        };
        Object.defineProperty(s, "__esModule", { value: !0 }), s.parseRawGrammar = s.INITIAL = s.Registry = void 0;
        const i = a(391), p = a(50), h = a(652), d = a(583), f = a(965);
        l(a(44), s), s.Registry = class {
          constructor(m) {
            this._options = m, this._syncRegistry = new h.SyncRegistry(d.Theme.createFromRawTheme(m.theme, m.colorMap), m.onigLib), this._ensureGrammarCache = /* @__PURE__ */ new Map();
          }
          dispose() {
            this._syncRegistry.dispose();
          }
          setTheme(m, S) {
            this._syncRegistry.setTheme(d.Theme.createFromRawTheme(m, S));
          }
          getColorMap() {
            return this._syncRegistry.getColorMap();
          }
          loadGrammarWithEmbeddedLanguages(m, S, L) {
            return this.loadGrammarWithConfiguration(m, S, { embeddedLanguages: L });
          }
          loadGrammarWithConfiguration(m, S, L) {
            return this._loadGrammar(m, S, L.embeddedLanguages, L.tokenTypes, new i.BalancedBracketSelectors(L.balancedBracketSelectors || [], L.unbalancedBracketSelectors || []));
          }
          loadGrammar(m) {
            return this._loadGrammar(m, 0, null, null, null);
          }
          async _loadGrammar(m, S, L, _, k) {
            const w = new f.ScopeDependencyProcessor(this._syncRegistry, m);
            for (; w.Q.length > 0; )
              await Promise.all(w.Q.map((E) => this._loadSingleGrammar(E.scopeName))), w.processQueue();
            return this._grammarForScopeName(m, S, L, _, k);
          }
          async _loadSingleGrammar(m) {
            return this._ensureGrammarCache.has(m) || this._ensureGrammarCache.set(m, this._doLoadSingleGrammar(m)), this._ensureGrammarCache.get(m);
          }
          async _doLoadSingleGrammar(m) {
            const S = await this._options.loadGrammar(m);
            if (S) {
              const L = typeof this._options.getInjections == "function" ? this._options.getInjections(m) : void 0;
              this._syncRegistry.addGrammar(S, L);
            }
          }
          async addGrammar(m, S = [], L = 0, _ = null) {
            return this._syncRegistry.addGrammar(m, S), await this._grammarForScopeName(m.scopeName, L, _);
          }
          _grammarForScopeName(m, S = 0, L = null, _ = null, k = null) {
            return this._syncRegistry.grammarForScopeName(m, S, L, _, k);
          }
        }, s.INITIAL = i.StateStack.NULL, s.parseRawGrammar = p.parseRawGrammar;
      }, 736: (r, s) => {
        function a(c) {
          return !!c && !!c.match(/[\w\.:]+/);
        }
        Object.defineProperty(s, "__esModule", { value: !0 }), s.createMatchers = void 0, s.createMatchers = function(c, l) {
          const i = [], p = function(m) {
            let S = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, L = S.exec(m);
            return { next: () => {
              if (!L)
                return null;
              const _ = L[0];
              return L = S.exec(m), _;
            } };
          }(c);
          let h = p.next();
          for (; h !== null; ) {
            let m = 0;
            if (h.length === 2 && h.charAt(1) === ":") {
              switch (h.charAt(0)) {
                case "R":
                  m = 1;
                  break;
                case "L":
                  m = -1;
                  break;
                default:
                  console.log(`Unknown priority ${h} in scope selector`);
              }
              h = p.next();
            }
            let S = f();
            if (i.push({ matcher: S, priority: m }), h !== ",")
              break;
            h = p.next();
          }
          return i;
          function d() {
            if (h === "-") {
              h = p.next();
              const m = d();
              return (S) => !!m && !m(S);
            }
            if (h === "(") {
              h = p.next();
              const m = function() {
                const S = [];
                let L = f();
                for (; L && (S.push(L), h === "|" || h === ","); ) {
                  do
                    h = p.next();
                  while (h === "|" || h === ",");
                  L = f();
                }
                return (_) => S.some((k) => k(_));
              }();
              return h === ")" && (h = p.next()), m;
            }
            if (a(h)) {
              const m = [];
              do
                m.push(h), h = p.next();
              while (a(h));
              return (S) => l(m, S);
            }
            return null;
          }
          function f() {
            const m = [];
            let S = d();
            for (; S; )
              m.push(S), S = d();
            return (L) => m.every((_) => _(L));
          }
        };
      }, 44: (r, s) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.disposeOnigString = void 0, s.disposeOnigString = function(a) {
          typeof a.dispose == "function" && a.dispose();
        };
      }, 50: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.parseRawGrammar = void 0;
        const c = a(69), l = a(350), i = a(974);
        s.parseRawGrammar = function(p, h = null) {
          return h !== null && /\.json$/.test(h) ? (d = p, f = h, l.DebugFlags.InDebugMode ? i.parseJSON(d, f, !0) : JSON.parse(d)) : function(m, S) {
            return l.DebugFlags.InDebugMode ? c.parseWithLocation(m, S, "$vscodeTextmateLocation") : c.parsePLIST(m);
          }(p, h);
          var d, f;
        };
      }, 69: (r, s) => {
        function a(c, l, i) {
          const p = c.length;
          let h = 0, d = 1, f = 0;
          function m(j) {
            if (i === null)
              h += j;
            else
              for (; j > 0; )
                c.charCodeAt(h) === 10 ? (h++, d++, f = 0) : (h++, f++), j--;
          }
          function S(j) {
            i === null ? h = j : m(j - h);
          }
          function L() {
            for (; h < p; ) {
              let j = c.charCodeAt(h);
              if (j !== 32 && j !== 9 && j !== 13 && j !== 10)
                break;
              m(1);
            }
          }
          function _(j) {
            return c.substr(h, j.length) === j && (m(j.length), !0);
          }
          function k(j) {
            let Q = c.indexOf(j, h);
            S(Q !== -1 ? Q + j.length : p);
          }
          function w(j) {
            let Q = c.indexOf(j, h);
            if (Q !== -1) {
              let U = c.substring(h, Q);
              return S(Q + j.length), U;
            }
            {
              let U = c.substr(h);
              return S(p), U;
            }
          }
          p > 0 && c.charCodeAt(0) === 65279 && (h = 1);
          let E = 0, y = null, u = [], g = [], x = null;
          function b(j, Q) {
            u.push(E), g.push(y), E = j, y = Q;
          }
          function v() {
            if (u.length === 0)
              return A("illegal state stack");
            E = u.pop(), y = g.pop();
          }
          function A(j) {
            throw new Error("Near offset " + h + ": " + j + " ~~~" + c.substr(h, 50) + "~~~");
          }
          const C = function() {
            if (x === null)
              return A("missing <key>");
            let j = {};
            i !== null && (j[i] = { filename: l, line: d, char: f }), y[x] = j, x = null, b(1, j);
          }, D = function() {
            if (x === null)
              return A("missing <key>");
            let j = [];
            y[x] = j, x = null, b(2, j);
          }, T = function() {
            let j = {};
            i !== null && (j[i] = { filename: l, line: d, char: f }), y.push(j), b(1, j);
          }, q = function() {
            let j = [];
            y.push(j), b(2, j);
          };
          function R() {
            if (E !== 1)
              return A("unexpected </dict>");
            v();
          }
          function F() {
            return E === 1 || E !== 2 ? A("unexpected </array>") : void v();
          }
          function M(j) {
            if (E === 1) {
              if (x === null)
                return A("missing <key>");
              y[x] = j, x = null;
            } else
              E === 2 ? y.push(j) : y = j;
          }
          function O(j) {
            if (isNaN(j))
              return A("cannot parse float");
            if (E === 1) {
              if (x === null)
                return A("missing <key>");
              y[x] = j, x = null;
            } else
              E === 2 ? y.push(j) : y = j;
          }
          function Z(j) {
            if (isNaN(j))
              return A("cannot parse integer");
            if (E === 1) {
              if (x === null)
                return A("missing <key>");
              y[x] = j, x = null;
            } else
              E === 2 ? y.push(j) : y = j;
          }
          function J(j) {
            if (E === 1) {
              if (x === null)
                return A("missing <key>");
              y[x] = j, x = null;
            } else
              E === 2 ? y.push(j) : y = j;
          }
          function V(j) {
            if (E === 1) {
              if (x === null)
                return A("missing <key>");
              y[x] = j, x = null;
            } else
              E === 2 ? y.push(j) : y = j;
          }
          function G(j) {
            if (E === 1) {
              if (x === null)
                return A("missing <key>");
              y[x] = j, x = null;
            } else
              E === 2 ? y.push(j) : y = j;
          }
          function z() {
            let j = w(">"), Q = !1;
            return j.charCodeAt(j.length - 1) === 47 && (Q = !0, j = j.substring(0, j.length - 1)), { name: j.trim(), isClosed: Q };
          }
          function $(j) {
            if (j.isClosed)
              return "";
            let Q = w("</");
            return k(">"), Q.replace(/&#([0-9]+);/g, function(U, oe) {
              return String.fromCodePoint(parseInt(oe, 10));
            }).replace(/&#x([0-9a-f]+);/g, function(U, oe) {
              return String.fromCodePoint(parseInt(oe, 16));
            }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function(U) {
              switch (U) {
                case "&amp;":
                  return "&";
                case "&lt;":
                  return "<";
                case "&gt;":
                  return ">";
                case "&quot;":
                  return '"';
                case "&apos;":
                  return "'";
              }
              return U;
            });
          }
          for (; h < p && (L(), !(h >= p)); ) {
            const j = c.charCodeAt(h);
            if (m(1), j !== 60)
              return A("expected <");
            if (h >= p)
              return A("unexpected end of input");
            const Q = c.charCodeAt(h);
            if (Q === 63) {
              m(1), k("?>");
              continue;
            }
            if (Q === 33) {
              if (m(1), _("--")) {
                k("-->");
                continue;
              }
              k(">");
              continue;
            }
            if (Q === 47) {
              if (m(1), L(), _("plist")) {
                k(">");
                continue;
              }
              if (_("dict")) {
                k(">"), R();
                continue;
              }
              if (_("array")) {
                k(">"), F();
                continue;
              }
              return A("unexpected closed tag");
            }
            let U = z();
            switch (U.name) {
              case "dict":
                E === 1 ? C() : E === 2 ? T() : (y = {}, i !== null && (y[i] = { filename: l, line: d, char: f }), b(1, y)), U.isClosed && R();
                continue;
              case "array":
                E === 1 ? D() : E === 2 ? q() : (y = [], b(2, y)), U.isClosed && F();
                continue;
              case "key":
                Y = $(U), E !== 1 ? A("unexpected <key>") : x !== null ? A("too many <key>") : x = Y;
                continue;
              case "string":
                M($(U));
                continue;
              case "real":
                O(parseFloat($(U)));
                continue;
              case "integer":
                Z(parseInt($(U), 10));
                continue;
              case "date":
                J(new Date($(U)));
                continue;
              case "data":
                V($(U));
                continue;
              case "true":
                $(U), G(!0);
                continue;
              case "false":
                $(U), G(!1);
                continue;
            }
            if (!/^plist/.test(U.name))
              return A("unexpected opened tag " + U.name);
          }
          var Y;
          return y;
        }
        Object.defineProperty(s, "__esModule", { value: !0 }), s.parsePLIST = s.parseWithLocation = void 0, s.parseWithLocation = function(c, l, i) {
          return a(c, l, i);
        }, s.parsePLIST = function(c) {
          return a(c, null, null);
        };
      }, 652: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.SyncRegistry = void 0;
        const c = a(391);
        s.SyncRegistry = class {
          constructor(l, i) {
            this._onigLibPromise = i, this._grammars = /* @__PURE__ */ new Map(), this._rawGrammars = /* @__PURE__ */ new Map(), this._injectionGrammars = /* @__PURE__ */ new Map(), this._theme = l;
          }
          dispose() {
            for (const l of this._grammars.values())
              l.dispose();
          }
          setTheme(l) {
            this._theme = l;
          }
          getColorMap() {
            return this._theme.getColorMap();
          }
          addGrammar(l, i) {
            this._rawGrammars.set(l.scopeName, l), i && this._injectionGrammars.set(l.scopeName, i);
          }
          lookup(l) {
            return this._rawGrammars.get(l);
          }
          injections(l) {
            return this._injectionGrammars.get(l);
          }
          getDefaults() {
            return this._theme.getDefaults();
          }
          themeMatch(l) {
            return this._theme.match(l);
          }
          async grammarForScopeName(l, i, p, h, d) {
            if (!this._grammars.has(l)) {
              let f = this._rawGrammars.get(l);
              if (!f)
                return null;
              this._grammars.set(l, c.createGrammar(l, f, i, p, h, d, this, await this._onigLibPromise));
            }
            return this._grammars.get(l);
          }
        };
      }, 792: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.CompiledRule = s.RegExpSourceList = s.RegExpSource = s.RuleFactory = s.BeginWhileRule = s.BeginEndRule = s.IncludeOnlyRule = s.MatchRule = s.CaptureRule = s.Rule = s.ruleIdToNumber = s.ruleIdFromNumber = s.whileRuleId = s.endRuleId = void 0;
        const c = a(878), l = a(965), i = /\\(\d+)/, p = /\\(\d+)/g;
        s.endRuleId = -1, s.whileRuleId = -2, s.ruleIdFromNumber = function(y) {
          return y;
        }, s.ruleIdToNumber = function(y) {
          return y;
        };
        class h {
          constructor(u, g, x, b) {
            this.$location = u, this.id = g, this._name = x || null, this._nameIsCapturing = c.RegexSource.hasCaptures(this._name), this._contentName = b || null, this._contentNameIsCapturing = c.RegexSource.hasCaptures(this._contentName);
          }
          get debugName() {
            const u = this.$location ? `${c.basename(this.$location.filename)}:${this.$location.line}` : "unknown";
            return `${this.constructor.name}#${this.id} @ ${u}`;
          }
          getName(u, g) {
            return this._nameIsCapturing && this._name !== null && u !== null && g !== null ? c.RegexSource.replaceCaptures(this._name, u, g) : this._name;
          }
          getContentName(u, g) {
            return this._contentNameIsCapturing && this._contentName !== null ? c.RegexSource.replaceCaptures(this._contentName, u, g) : this._contentName;
          }
        }
        s.Rule = h;
        class d extends h {
          constructor(u, g, x, b, v) {
            super(u, g, x, b), this.retokenizeCapturedWithRuleId = v;
          }
          dispose() {
          }
          collectPatterns(u, g) {
            throw new Error("Not supported!");
          }
          compile(u, g) {
            throw new Error("Not supported!");
          }
          compileAG(u, g, x, b) {
            throw new Error("Not supported!");
          }
        }
        s.CaptureRule = d;
        class f extends h {
          constructor(u, g, x, b, v) {
            super(u, g, x, null), this._match = new k(b, this.id), this.captures = v, this._cachedCompiledPatterns = null;
          }
          dispose() {
            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
          }
          get debugMatchRegExp() {
            return `${this._match.source}`;
          }
          collectPatterns(u, g) {
            g.push(this._match);
          }
          compile(u, g) {
            return this._getCachedCompiledPatterns(u).compile(u);
          }
          compileAG(u, g, x, b) {
            return this._getCachedCompiledPatterns(u).compileAG(u, x, b);
          }
          _getCachedCompiledPatterns(u) {
            return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new w(), this.collectPatterns(u, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
          }
        }
        s.MatchRule = f;
        class m extends h {
          constructor(u, g, x, b, v) {
            super(u, g, x, b), this.patterns = v.patterns, this.hasMissingPatterns = v.hasMissingPatterns, this._cachedCompiledPatterns = null;
          }
          dispose() {
            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
          }
          collectPatterns(u, g) {
            for (const x of this.patterns)
              u.getRule(x).collectPatterns(u, g);
          }
          compile(u, g) {
            return this._getCachedCompiledPatterns(u).compile(u);
          }
          compileAG(u, g, x, b) {
            return this._getCachedCompiledPatterns(u).compileAG(u, x, b);
          }
          _getCachedCompiledPatterns(u) {
            return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new w(), this.collectPatterns(u, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
          }
        }
        s.IncludeOnlyRule = m;
        class S extends h {
          constructor(u, g, x, b, v, A, C, D, T, q) {
            super(u, g, x, b), this._begin = new k(v, this.id), this.beginCaptures = A, this._end = new k(C || "￿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = D, this.applyEndPatternLast = T || !1, this.patterns = q.patterns, this.hasMissingPatterns = q.hasMissingPatterns, this._cachedCompiledPatterns = null;
          }
          dispose() {
            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
          }
          get debugBeginRegExp() {
            return `${this._begin.source}`;
          }
          get debugEndRegExp() {
            return `${this._end.source}`;
          }
          getEndWithResolvedBackReferences(u, g) {
            return this._end.resolveBackReferences(u, g);
          }
          collectPatterns(u, g) {
            g.push(this._begin);
          }
          compile(u, g) {
            return this._getCachedCompiledPatterns(u, g).compile(u);
          }
          compileAG(u, g, x, b) {
            return this._getCachedCompiledPatterns(u, g).compileAG(u, x, b);
          }
          _getCachedCompiledPatterns(u, g) {
            if (!this._cachedCompiledPatterns) {
              this._cachedCompiledPatterns = new w();
              for (const x of this.patterns)
                u.getRule(x).collectPatterns(u, this._cachedCompiledPatterns);
              this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
            }
            return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, g) : this._cachedCompiledPatterns.setSource(0, g)), this._cachedCompiledPatterns;
          }
        }
        s.BeginEndRule = S;
        class L extends h {
          constructor(u, g, x, b, v, A, C, D, T) {
            super(u, g, x, b), this._begin = new k(v, this.id), this.beginCaptures = A, this.whileCaptures = D, this._while = new k(C, s.whileRuleId), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = T.patterns, this.hasMissingPatterns = T.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
          }
          dispose() {
            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
          }
          get debugBeginRegExp() {
            return `${this._begin.source}`;
          }
          get debugWhileRegExp() {
            return `${this._while.source}`;
          }
          getWhileWithResolvedBackReferences(u, g) {
            return this._while.resolveBackReferences(u, g);
          }
          collectPatterns(u, g) {
            g.push(this._begin);
          }
          compile(u, g) {
            return this._getCachedCompiledPatterns(u).compile(u);
          }
          compileAG(u, g, x, b) {
            return this._getCachedCompiledPatterns(u).compileAG(u, x, b);
          }
          _getCachedCompiledPatterns(u) {
            if (!this._cachedCompiledPatterns) {
              this._cachedCompiledPatterns = new w();
              for (const g of this.patterns)
                u.getRule(g).collectPatterns(u, this._cachedCompiledPatterns);
            }
            return this._cachedCompiledPatterns;
          }
          compileWhile(u, g) {
            return this._getCachedCompiledWhilePatterns(u, g).compile(u);
          }
          compileWhileAG(u, g, x, b) {
            return this._getCachedCompiledWhilePatterns(u, g).compileAG(u, x, b);
          }
          _getCachedCompiledWhilePatterns(u, g) {
            return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new w(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, g || "￿"), this._cachedCompiledWhilePatterns;
          }
        }
        s.BeginWhileRule = L;
        class _ {
          static createCaptureRule(u, g, x, b, v) {
            return u.registerRule((A) => new d(g, A, x, b, v));
          }
          static getCompiledRuleId(u, g, x) {
            return u.id || g.registerRule((b) => {
              if (u.id = b, u.match)
                return new f(u.$vscodeTextmateLocation, u.id, u.name, u.match, _._compileCaptures(u.captures, g, x));
              if (u.begin === void 0) {
                u.repository && (x = c.mergeObjects({}, x, u.repository));
                let v = u.patterns;
                return v === void 0 && u.include && (v = [{ include: u.include }]), new m(u.$vscodeTextmateLocation, u.id, u.name, u.contentName, _._compilePatterns(v, g, x));
              }
              return u.while ? new L(u.$vscodeTextmateLocation, u.id, u.name, u.contentName, u.begin, _._compileCaptures(u.beginCaptures || u.captures, g, x), u.while, _._compileCaptures(u.whileCaptures || u.captures, g, x), _._compilePatterns(u.patterns, g, x)) : new S(u.$vscodeTextmateLocation, u.id, u.name, u.contentName, u.begin, _._compileCaptures(u.beginCaptures || u.captures, g, x), u.end, _._compileCaptures(u.endCaptures || u.captures, g, x), u.applyEndPatternLast, _._compilePatterns(u.patterns, g, x));
            }), u.id;
          }
          static _compileCaptures(u, g, x) {
            let b = [];
            if (u) {
              let v = 0;
              for (const A in u) {
                if (A === "$vscodeTextmateLocation")
                  continue;
                const C = parseInt(A, 10);
                C > v && (v = C);
              }
              for (let A = 0; A <= v; A++)
                b[A] = null;
              for (const A in u) {
                if (A === "$vscodeTextmateLocation")
                  continue;
                const C = parseInt(A, 10);
                let D = 0;
                u[A].patterns && (D = _.getCompiledRuleId(u[A], g, x)), b[C] = _.createCaptureRule(g, u[A].$vscodeTextmateLocation, u[A].name, u[A].contentName, D);
              }
            }
            return b;
          }
          static _compilePatterns(u, g, x) {
            let b = [];
            if (u)
              for (let v = 0, A = u.length; v < A; v++) {
                const C = u[v];
                let D = -1;
                if (C.include) {
                  const T = l.parseInclude(C.include);
                  switch (T.kind) {
                    case 0:
                    case 1:
                      D = _.getCompiledRuleId(x[C.include], g, x);
                      break;
                    case 2:
                      let q = x[T.ruleName];
                      q && (D = _.getCompiledRuleId(q, g, x));
                      break;
                    case 3:
                    case 4:
                      const R = T.scopeName, F = T.kind === 4 ? T.ruleName : null, M = g.getExternalGrammar(R, x);
                      if (M)
                        if (F) {
                          let O = M.repository[F];
                          O && (D = _.getCompiledRuleId(O, g, M.repository));
                        } else
                          D = _.getCompiledRuleId(M.repository.$self, g, M.repository);
                  }
                } else
                  D = _.getCompiledRuleId(C, g, x);
                if (D !== -1) {
                  const T = g.getRule(D);
                  let q = !1;
                  if ((T instanceof m || T instanceof S || T instanceof L) && T.hasMissingPatterns && T.patterns.length === 0 && (q = !0), q)
                    continue;
                  b.push(D);
                }
              }
            return { patterns: b, hasMissingPatterns: (u ? u.length : 0) !== b.length };
          }
        }
        s.RuleFactory = _;
        class k {
          constructor(u, g) {
            if (u) {
              const x = u.length;
              let b = 0, v = [], A = !1;
              for (let C = 0; C < x; C++)
                if (u.charAt(C) === "\\" && C + 1 < x) {
                  const D = u.charAt(C + 1);
                  D === "z" ? (v.push(u.substring(b, C)), v.push("$(?!\\n)(?<!\\n)"), b = C + 2) : D !== "A" && D !== "G" || (A = !0), C++;
                }
              this.hasAnchor = A, b === 0 ? this.source = u : (v.push(u.substring(b, x)), this.source = v.join(""));
            } else
              this.hasAnchor = !1, this.source = u;
            this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = g, this.hasBackReferences = i.test(this.source);
          }
          clone() {
            return new k(this.source, this.ruleId);
          }
          setSource(u) {
            this.source !== u && (this.source = u, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
          }
          resolveBackReferences(u, g) {
            let x = g.map((b) => u.substring(b.start, b.end));
            return p.lastIndex = 0, this.source.replace(p, (b, v) => c.escapeRegExpCharacters(x[parseInt(v, 10)] || ""));
          }
          _buildAnchorCache() {
            let u, g, x, b, v = [], A = [], C = [], D = [];
            for (u = 0, g = this.source.length; u < g; u++)
              x = this.source.charAt(u), v[u] = x, A[u] = x, C[u] = x, D[u] = x, x === "\\" && u + 1 < g && (b = this.source.charAt(u + 1), b === "A" ? (v[u + 1] = "￿", A[u + 1] = "￿", C[u + 1] = "A", D[u + 1] = "A") : b === "G" ? (v[u + 1] = "￿", A[u + 1] = "G", C[u + 1] = "￿", D[u + 1] = "G") : (v[u + 1] = b, A[u + 1] = b, C[u + 1] = b, D[u + 1] = b), u++);
            return { A0_G0: v.join(""), A0_G1: A.join(""), A1_G0: C.join(""), A1_G1: D.join("") };
          }
          resolveAnchors(u, g) {
            return this.hasAnchor && this._anchorCache ? u ? g ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : g ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0 : this.source;
          }
        }
        s.RegExpSource = k;
        class w {
          constructor() {
            this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = { A0_G0: null, A0_G1: null, A1_G0: null, A1_G1: null };
          }
          dispose() {
            this._disposeCaches();
          }
          _disposeCaches() {
            this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
          }
          push(u) {
            this._items.push(u), this._hasAnchors = this._hasAnchors || u.hasAnchor;
          }
          unshift(u) {
            this._items.unshift(u), this._hasAnchors = this._hasAnchors || u.hasAnchor;
          }
          length() {
            return this._items.length;
          }
          setSource(u, g) {
            this._items[u].source !== g && (this._disposeCaches(), this._items[u].setSource(g));
          }
          compile(u) {
            if (!this._cached) {
              let g = this._items.map((x) => x.source);
              this._cached = new E(u, g, this._items.map((x) => x.ruleId));
            }
            return this._cached;
          }
          compileAG(u, g, x) {
            return this._hasAnchors ? g ? x ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(u, g, x)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(u, g, x)), this._anchorCache.A1_G0) : x ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(u, g, x)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(u, g, x)), this._anchorCache.A0_G0) : this.compile(u);
          }
          _resolveAnchors(u, g, x) {
            let b = this._items.map((v) => v.resolveAnchors(g, x));
            return new E(u, b, this._items.map((v) => v.ruleId));
          }
        }
        s.RegExpSourceList = w;
        class E {
          constructor(u, g, x) {
            this.regExps = g, this.rules = x, this.scanner = u.createOnigScanner(g);
          }
          dispose() {
            typeof this.scanner.dispose == "function" && this.scanner.dispose();
          }
          toString() {
            const u = [];
            for (let g = 0, x = this.rules.length; g < x; g++)
              u.push("   - " + this.rules[g] + ": " + this.regExps[g]);
            return u.join(`
`);
          }
          findNextMatchSync(u, g, x) {
            const b = this.scanner.findNextMatchSync(u, g, x);
            return b ? { ruleId: this.rules[b.index], captureIndices: b.captureIndices } : null;
          }
        }
        s.CompiledRule = E;
      }, 583: (r, s, a) => {
        Object.defineProperty(s, "__esModule", { value: !0 }), s.ThemeTrieElement = s.ThemeTrieElementRule = s.ColorMap = s.fontStyleToString = s.ParsedThemeRule = s.parseTheme = s.StyleAttributes = s.ScopeStack = s.Theme = void 0;
        const c = a(878);
        class l {
          constructor(k, w, E) {
            this._colorMap = k, this._defaults = w, this._root = E, this._cachedMatchRoot = new c.CachedFn((y) => this._root.match(y));
          }
          static createFromRawTheme(k, w) {
            return this.createFromParsedTheme(d(k), w);
          }
          static createFromParsedTheme(k, w) {
            return function(E, y) {
              E.sort((C, D) => {
                let T = c.strcmp(C.scope, D.scope);
                return T !== 0 ? T : (T = c.strArrCmp(C.parentScopes, D.parentScopes), T !== 0 ? T : C.index - D.index);
              });
              let u = 0, g = "#000000", x = "#ffffff";
              for (; E.length >= 1 && E[0].scope === ""; ) {
                let C = E.shift();
                C.fontStyle !== -1 && (u = C.fontStyle), C.foreground !== null && (g = C.foreground), C.background !== null && (x = C.background);
              }
              let b = new m(y), v = new h(u, b.getId(g), b.getId(x)), A = new L(new S(0, null, -1, 0, 0), []);
              for (let C = 0, D = E.length; C < D; C++) {
                let T = E[C];
                A.insert(0, T.scope, T.parentScopes, T.fontStyle, b.getId(T.foreground), b.getId(T.background));
              }
              return new l(b, v, A);
            }(k, w);
          }
          getColorMap() {
            return this._colorMap.getColorMap();
          }
          getDefaults() {
            return this._defaults;
          }
          match(k) {
            if (k === null)
              return this._defaults;
            const w = k.scopeName, E = this._cachedMatchRoot.get(w).find((y) => function(u, g) {
              if (g === null)
                return !0;
              let x = 0, b = g[x];
              for (; u; ) {
                if (p(u.scopeName, b)) {
                  if (x++, x === g.length)
                    return !0;
                  b = g[x];
                }
                u = u.parent;
              }
              return !1;
            }(k.parent, y.parentScopes));
            return E ? new h(E.fontStyle, E.foreground, E.background) : null;
          }
        }
        s.Theme = l;
        class i {
          constructor(k, w) {
            this.parent = k, this.scopeName = w;
          }
          static from(...k) {
            let w = null;
            for (let E = 0; E < k.length; E++)
              w = new i(w, k[E]);
            return w;
          }
          push(k) {
            return new i(this, k);
          }
          getSegments() {
            let k = this;
            const w = [];
            for (; k; )
              w.push(k.scopeName), k = k.parent;
            return w.reverse(), w;
          }
          toString() {
            return this.getSegments().join(" ");
          }
        }
        function p(_, k) {
          return k === _ || _.startsWith(k) && _[k.length] === ".";
        }
        s.ScopeStack = i;
        class h {
          constructor(k, w, E) {
            this.fontStyle = k, this.foregroundId = w, this.backgroundId = E;
          }
        }
        function d(_) {
          if (!_)
            return [];
          if (!_.settings || !Array.isArray(_.settings))
            return [];
          let k = _.settings, w = [], E = 0;
          for (let y = 0, u = k.length; y < u; y++) {
            let g, x = k[y];
            if (!x.settings)
              continue;
            if (typeof x.scope == "string") {
              let C = x.scope;
              C = C.replace(/^[,]+/, ""), C = C.replace(/[,]+$/, ""), g = C.split(",");
            } else
              g = Array.isArray(x.scope) ? x.scope : [""];
            let b = -1;
            if (typeof x.settings.fontStyle == "string") {
              b = 0;
              let C = x.settings.fontStyle.split(" ");
              for (let D = 0, T = C.length; D < T; D++)
                switch (C[D]) {
                  case "italic":
                    b |= 1;
                    break;
                  case "bold":
                    b |= 2;
                    break;
                  case "underline":
                    b |= 4;
                    break;
                  case "strikethrough":
                    b |= 8;
                }
            }
            let v = null;
            typeof x.settings.foreground == "string" && c.isValidHexColor(x.settings.foreground) && (v = x.settings.foreground);
            let A = null;
            typeof x.settings.background == "string" && c.isValidHexColor(x.settings.background) && (A = x.settings.background);
            for (let C = 0, D = g.length; C < D; C++) {
              let T = g[C].trim().split(" "), q = T[T.length - 1], R = null;
              T.length > 1 && (R = T.slice(0, T.length - 1), R.reverse()), w[E++] = new f(q, R, y, b, v, A);
            }
          }
          return w;
        }
        s.StyleAttributes = h, s.parseTheme = d;
        class f {
          constructor(k, w, E, y, u, g) {
            this.scope = k, this.parentScopes = w, this.index = E, this.fontStyle = y, this.foreground = u, this.background = g;
          }
        }
        s.ParsedThemeRule = f, s.fontStyleToString = function(_) {
          if (_ === -1)
            return "not set";
          let k = "";
          return 1 & _ && (k += "italic "), 2 & _ && (k += "bold "), 4 & _ && (k += "underline "), 8 & _ && (k += "strikethrough "), k === "" && (k = "none"), k.trim();
        };
        class m {
          constructor(k) {
            if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(k)) {
              this._isFrozen = !0;
              for (let w = 0, E = k.length; w < E; w++)
                this._color2id[k[w]] = w, this._id2color[w] = k[w];
            } else
              this._isFrozen = !1;
          }
          getId(k) {
            if (k === null)
              return 0;
            k = k.toUpperCase();
            let w = this._color2id[k];
            if (w)
              return w;
            if (this._isFrozen)
              throw new Error(`Missing color in color map - ${k}`);
            return w = ++this._lastColorId, this._color2id[k] = w, this._id2color[w] = k, w;
          }
          getColorMap() {
            return this._id2color.slice(0);
          }
        }
        s.ColorMap = m;
        class S {
          constructor(k, w, E, y, u) {
            this.scopeDepth = k, this.parentScopes = w, this.fontStyle = E, this.foreground = y, this.background = u;
          }
          clone() {
            return new S(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
          }
          static cloneArr(k) {
            let w = [];
            for (let E = 0, y = k.length; E < y; E++)
              w[E] = k[E].clone();
            return w;
          }
          acceptOverwrite(k, w, E, y) {
            this.scopeDepth > k ? console.log("how did this happen?") : this.scopeDepth = k, w !== -1 && (this.fontStyle = w), E !== 0 && (this.foreground = E), y !== 0 && (this.background = y);
          }
        }
        s.ThemeTrieElementRule = S;
        class L {
          constructor(k, w = [], E = {}) {
            this._mainRule = k, this._children = E, this._rulesWithParentScopes = w;
          }
          static _sortBySpecificity(k) {
            return k.length === 1 || k.sort(this._cmpBySpecificity), k;
          }
          static _cmpBySpecificity(k, w) {
            if (k.scopeDepth === w.scopeDepth) {
              const E = k.parentScopes, y = w.parentScopes;
              let u = E === null ? 0 : E.length, g = y === null ? 0 : y.length;
              if (u === g)
                for (let x = 0; x < u; x++) {
                  const b = E[x].length, v = y[x].length;
                  if (b !== v)
                    return v - b;
                }
              return g - u;
            }
            return w.scopeDepth - k.scopeDepth;
          }
          match(k) {
            if (k === "")
              return L._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
            let w, E, y = k.indexOf(".");
            return y === -1 ? (w = k, E = "") : (w = k.substring(0, y), E = k.substring(y + 1)), this._children.hasOwnProperty(w) ? this._children[w].match(E) : L._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
          }
          insert(k, w, E, y, u, g) {
            if (w === "")
              return void this._doInsertHere(k, E, y, u, g);
            let x, b, v, A = w.indexOf(".");
            A === -1 ? (x = w, b = "") : (x = w.substring(0, A), b = w.substring(A + 1)), this._children.hasOwnProperty(x) ? v = this._children[x] : (v = new L(this._mainRule.clone(), S.cloneArr(this._rulesWithParentScopes)), this._children[x] = v), v.insert(k + 1, b, E, y, u, g);
          }
          _doInsertHere(k, w, E, y, u) {
            if (w !== null) {
              for (let g = 0, x = this._rulesWithParentScopes.length; g < x; g++) {
                let b = this._rulesWithParentScopes[g];
                if (c.strArrCmp(b.parentScopes, w) === 0)
                  return void b.acceptOverwrite(k, E, y, u);
              }
              E === -1 && (E = this._mainRule.fontStyle), y === 0 && (y = this._mainRule.foreground), u === 0 && (u = this._mainRule.background), this._rulesWithParentScopes.push(new S(k, w, E, y, u));
            } else
              this._mainRule.acceptOverwrite(k, E, y, u);
          }
        }
        s.ThemeTrieElement = L;
      }, 878: (r, s) => {
        function a(i) {
          return Array.isArray(i) ? function(p) {
            let h = [];
            for (let d = 0, f = p.length; d < f; d++)
              h[d] = a(p[d]);
            return h;
          }(i) : typeof i == "object" ? function(p) {
            let h = {};
            for (let d in p)
              h[d] = a(p[d]);
            return h;
          }(i) : i;
        }
        Object.defineProperty(s, "__esModule", { value: !0 }), s.performanceNow = s.CachedFn = s.escapeRegExpCharacters = s.isValidHexColor = s.strArrCmp = s.strcmp = s.RegexSource = s.basename = s.mergeObjects = s.clone = void 0, s.clone = function(i) {
          return a(i);
        }, s.mergeObjects = function(i, ...p) {
          return p.forEach((h) => {
            for (let d in h)
              i[d] = h[d];
          }), i;
        }, s.basename = function i(p) {
          const h = ~p.lastIndexOf("/") || ~p.lastIndexOf("\\");
          return h === 0 ? p : ~h == p.length - 1 ? i(p.substring(0, p.length - 1)) : p.substr(1 + ~h);
        };
        let c = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g;
        function l(i, p) {
          return i < p ? -1 : i > p ? 1 : 0;
        }
        s.RegexSource = class {
          static hasCaptures(i) {
            return i !== null && (c.lastIndex = 0, c.test(i));
          }
          static replaceCaptures(i, p, h) {
            return i.replace(c, (d, f, m, S) => {
              let L = h[parseInt(f || m, 10)];
              if (!L)
                return d;
              {
                let _ = p.substring(L.start, L.end);
                for (; _[0] === "."; )
                  _ = _.substring(1);
                switch (S) {
                  case "downcase":
                    return _.toLowerCase();
                  case "upcase":
                    return _.toUpperCase();
                  default:
                    return _;
                }
              }
            });
          }
        }, s.strcmp = l, s.strArrCmp = function(i, p) {
          if (i === null && p === null)
            return 0;
          if (!i)
            return -1;
          if (!p)
            return 1;
          let h = i.length, d = p.length;
          if (h === d) {
            for (let f = 0; f < h; f++) {
              let m = l(i[f], p[f]);
              if (m !== 0)
                return m;
            }
            return 0;
          }
          return h - d;
        }, s.isValidHexColor = function(i) {
          return !!(/^#[0-9a-f]{6}$/i.test(i) || /^#[0-9a-f]{8}$/i.test(i) || /^#[0-9a-f]{3}$/i.test(i) || /^#[0-9a-f]{4}$/i.test(i));
        }, s.escapeRegExpCharacters = function(i) {
          return i.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
        }, s.CachedFn = class {
          constructor(i) {
            this.fn = i, this.cache = /* @__PURE__ */ new Map();
          }
          get(i) {
            if (this.cache.has(i))
              return this.cache.get(i);
            const p = this.fn(i);
            return this.cache.set(i, p), p;
          }
        }, s.performanceNow = typeof performance > "u" ? function() {
          return Date.now();
        } : function() {
          return performance.now();
        };
      } }, o = {};
      return function r(s) {
        var a = o[s];
        if (a !== void 0)
          return a.exports;
        var c = o[s] = { exports: {} };
        return t[s].call(c.exports, c, c.exports, r), c.exports;
      }(787);
    })();
  });
})(Qge);
const vn = [
  {
    id: "abap",
    scopeName: "source.abap",
    path: "abap.tmLanguage.json",
    samplePath: "abap.sample"
  },
  {
    id: "actionscript-3",
    scopeName: "source.actionscript.3",
    path: "actionscript-3.tmLanguage.json",
    samplePath: "actionscript-3.sample"
  },
  {
    id: "ada",
    scopeName: "source.ada",
    path: "ada.tmLanguage.json",
    samplePath: "ada.sample"
  },
  {
    id: "apache",
    scopeName: "source.apacheconf",
    path: "apache.tmLanguage.json"
  },
  {
    id: "apex",
    scopeName: "source.apex",
    path: "apex.tmLanguage.json",
    samplePath: "apex.sample"
  },
  {
    id: "apl",
    scopeName: "source.apl",
    path: "apl.tmLanguage.json",
    embeddedLangs: ["html", "xml", "css", "javascript", "json"]
  },
  {
    id: "applescript",
    scopeName: "source.applescript",
    path: "applescript.tmLanguage.json",
    samplePath: "applescript.sample"
  },
  {
    id: "ara",
    scopeName: "source.ara",
    path: "ara.tmLanguage.json",
    samplePath: "ara.sample"
  },
  {
    id: "asm",
    scopeName: "source.asm.x86_64",
    path: "asm.tmLanguage.json",
    samplePath: "asm.sample"
  },
  {
    id: "astro",
    scopeName: "source.astro",
    path: "astro.tmLanguage.json",
    samplePath: "astro.sample",
    embeddedLangs: ["json", "javascript", "typescript", "stylus", "sass", "css", "scss", "less", "postcss", "tsx"]
  },
  {
    id: "awk",
    scopeName: "source.awk",
    path: "awk.tmLanguage.json",
    samplePath: "awk.sample"
  },
  {
    id: "ballerina",
    scopeName: "source.ballerina",
    path: "ballerina.tmLanguage.json",
    samplePath: "ballerina.sample"
  },
  {
    id: "bat",
    scopeName: "source.batchfile",
    path: "bat.tmLanguage.json",
    samplePath: "bat.sample",
    aliases: ["batch"]
  },
  {
    id: "berry",
    scopeName: "source.berry",
    path: "berry.tmLanguage.json",
    samplePath: "berry.sample",
    aliases: ["be"]
  },
  {
    id: "bibtex",
    scopeName: "text.bibtex",
    path: "bibtex.tmLanguage.json"
  },
  {
    id: "bicep",
    scopeName: "source.bicep",
    path: "bicep.tmLanguage.json",
    samplePath: "bicep.sample"
  },
  {
    id: "blade",
    scopeName: "text.html.php.blade",
    path: "blade.tmLanguage.json",
    samplePath: "blade.sample",
    embeddedLangs: ["html", "xml", "sql", "javascript", "json", "css"]
  },
  {
    id: "c",
    scopeName: "source.c",
    path: "c.tmLanguage.json",
    samplePath: "c.sample"
  },
  {
    id: "cadence",
    scopeName: "source.cadence",
    path: "cadence.tmLanguage.json",
    samplePath: "cadence.sample",
    aliases: ["cdc"]
  },
  {
    id: "clarity",
    scopeName: "source.clar",
    path: "clarity.tmLanguage.json",
    samplePath: "clarity.sample"
  },
  {
    id: "clojure",
    scopeName: "source.clojure",
    path: "clojure.tmLanguage.json",
    samplePath: "clojure.sample",
    aliases: ["clj"]
  },
  {
    id: "cmake",
    scopeName: "source.cmake",
    path: "cmake.tmLanguage.json",
    samplePath: "cmake.sample"
  },
  {
    id: "cobol",
    scopeName: "source.cobol",
    path: "cobol.tmLanguage.json",
    samplePath: "cobol.sample",
    embeddedLangs: ["sql", "html", "java"]
  },
  {
    id: "codeql",
    scopeName: "source.ql",
    path: "codeql.tmLanguage.json",
    samplePath: "codeql.sample",
    aliases: ["ql"],
    embeddedLangs: ["markdown"]
  },
  {
    id: "coffee",
    scopeName: "source.coffee",
    path: "coffee.tmLanguage.json",
    samplePath: "coffee.sample",
    embeddedLangs: ["javascript"]
  },
  {
    id: "cpp",
    scopeName: "source.cpp",
    path: "cpp.tmLanguage.json",
    samplePath: "cpp.sample",
    embeddedLangs: ["glsl", "sql"]
  },
  {
    id: "crystal",
    scopeName: "source.crystal",
    path: "crystal.tmLanguage.json",
    samplePath: "crystal.sample",
    embeddedLangs: ["html", "sql", "css", "c", "javascript", "shellscript"]
  },
  {
    id: "csharp",
    scopeName: "source.cs",
    path: "csharp.tmLanguage.json",
    samplePath: "csharp.sample",
    aliases: ["c#", "cs"]
  },
  {
    id: "css",
    scopeName: "source.css",
    path: "css.tmLanguage.json",
    samplePath: "css.sample"
  },
  {
    id: "cue",
    scopeName: "source.cue",
    path: "cue.tmLanguage.json",
    samplePath: "cue.sample"
  },
  {
    id: "d",
    scopeName: "source.d",
    path: "d.tmLanguage.json",
    samplePath: "d.sample"
  },
  {
    id: "dart",
    scopeName: "source.dart",
    path: "dart.tmLanguage.json",
    samplePath: "dart.sample"
  },
  {
    id: "dax",
    scopeName: "source.dax",
    path: "dax.tmLanguage.json",
    samplePath: "dax.sample"
  },
  {
    id: "diff",
    scopeName: "source.diff",
    path: "diff.tmLanguage.json",
    samplePath: "diff.sample"
  },
  {
    id: "docker",
    scopeName: "source.dockerfile",
    path: "docker.tmLanguage.json",
    samplePath: "docker.sample"
  },
  {
    id: "dream-maker",
    scopeName: "source.dm",
    path: "dream-maker.tmLanguage.json"
  },
  {
    id: "elixir",
    scopeName: "source.elixir",
    path: "elixir.tmLanguage.json",
    samplePath: "elixir.sample",
    embeddedLangs: ["html"]
  },
  {
    id: "elm",
    scopeName: "source.elm",
    path: "elm.tmLanguage.json",
    samplePath: "elm.sample",
    embeddedLangs: ["glsl"]
  },
  {
    id: "erb",
    scopeName: "text.html.erb",
    path: "erb.tmLanguage.json",
    samplePath: "erb.sample",
    embeddedLangs: ["html", "ruby"]
  },
  {
    id: "erlang",
    scopeName: "source.erlang",
    path: "erlang.tmLanguage.json",
    samplePath: "erlang.sample",
    aliases: ["erl"]
  },
  {
    id: "fish",
    scopeName: "source.fish",
    path: "fish.tmLanguage.json",
    samplePath: "fish.sample"
  },
  {
    id: "fsharp",
    scopeName: "source.fsharp",
    path: "fsharp.tmLanguage.json",
    samplePath: "fsharp.sample",
    aliases: ["f#", "fs"],
    embeddedLangs: ["markdown"]
  },
  {
    id: "gherkin",
    scopeName: "text.gherkin.feature",
    path: "gherkin.tmLanguage.json"
  },
  {
    id: "git-commit",
    scopeName: "text.git-commit",
    path: "git-commit.tmLanguage.json",
    embeddedLangs: ["diff"]
  },
  {
    id: "git-rebase",
    scopeName: "text.git-rebase",
    path: "git-rebase.tmLanguage.json",
    embeddedLangs: ["shellscript"]
  },
  {
    id: "glsl",
    scopeName: "source.glsl",
    path: "glsl.tmLanguage.json",
    samplePath: "glsl.sample",
    embeddedLangs: ["c"]
  },
  {
    id: "gnuplot",
    scopeName: "source.gnuplot",
    path: "gnuplot.tmLanguage.json"
  },
  {
    id: "go",
    scopeName: "source.go",
    path: "go.tmLanguage.json",
    samplePath: "go.sample"
  },
  {
    id: "graphql",
    scopeName: "source.graphql",
    path: "graphql.tmLanguage.json",
    embeddedLangs: ["javascript", "typescript", "jsx", "tsx"]
  },
  {
    id: "groovy",
    scopeName: "source.groovy",
    path: "groovy.tmLanguage.json"
  },
  {
    id: "hack",
    scopeName: "source.hack",
    path: "hack.tmLanguage.json",
    embeddedLangs: ["html", "sql"]
  },
  {
    id: "haml",
    scopeName: "text.haml",
    path: "haml.tmLanguage.json",
    embeddedLangs: ["ruby", "javascript", "sass", "coffee", "markdown", "css"]
  },
  {
    id: "handlebars",
    scopeName: "text.html.handlebars",
    path: "handlebars.tmLanguage.json",
    aliases: ["hbs"],
    embeddedLangs: ["html", "css", "javascript", "yaml"]
  },
  {
    id: "haskell",
    scopeName: "source.haskell",
    path: "haskell.tmLanguage.json",
    aliases: ["hs"]
  },
  {
    id: "hcl",
    scopeName: "source.hcl",
    path: "hcl.tmLanguage.json",
    samplePath: "hcl.sample"
  },
  {
    id: "hlsl",
    scopeName: "source.hlsl",
    path: "hlsl.tmLanguage.json"
  },
  {
    id: "html",
    scopeName: "text.html.basic",
    path: "html.tmLanguage.json",
    samplePath: "html.sample",
    embeddedLangs: ["javascript", "css"]
  },
  {
    id: "http",
    scopeName: "source.http",
    path: "http.tmLanguage.json",
    samplePath: "http.sample",
    embeddedLangs: ["shellscript", "json", "xml", "graphql"]
  },
  {
    id: "imba",
    scopeName: "source.imba",
    path: "imba.tmLanguage.json",
    samplePath: "imba.sample"
  },
  {
    id: "ini",
    scopeName: "source.ini",
    path: "ini.tmLanguage.json",
    aliases: ["properties"]
  },
  {
    id: "java",
    scopeName: "source.java",
    path: "java.tmLanguage.json",
    samplePath: "java.sample"
  },
  {
    id: "javascript",
    scopeName: "source.js",
    path: "javascript.tmLanguage.json",
    samplePath: "javascript.sample",
    aliases: ["js"]
  },
  {
    id: "jinja-html",
    scopeName: "text.html.jinja",
    path: "jinja-html.tmLanguage.json",
    embeddedLangs: ["html"]
  },
  {
    id: "jison",
    scopeName: "source.jison",
    path: "jison.tmLanguage.json",
    samplePath: "jison.sample",
    embeddedLangs: ["javascript"]
  },
  {
    id: "json",
    scopeName: "source.json",
    path: "json.tmLanguage.json"
  },
  {
    id: "json5",
    scopeName: "source.json5",
    path: "json5.tmLanguage.json",
    samplePath: "json5.sample"
  },
  {
    id: "jsonc",
    scopeName: "source.json.comments",
    path: "jsonc.tmLanguage.json"
  },
  {
    id: "jsonnet",
    scopeName: "source.jsonnet",
    path: "jsonnet.tmLanguage.json"
  },
  {
    id: "jssm",
    scopeName: "source.jssm",
    path: "jssm.tmLanguage.json",
    samplePath: "jssm.sample",
    aliases: ["fsl"]
  },
  {
    id: "jsx",
    scopeName: "source.js.jsx",
    path: "jsx.tmLanguage.json"
  },
  {
    id: "julia",
    scopeName: "source.julia",
    path: "julia.tmLanguage.json",
    embeddedLangs: ["cpp", "python", "javascript", "r", "sql"]
  },
  {
    id: "kotlin",
    scopeName: "source.kotlin",
    path: "kotlin.tmLanguage.json"
  },
  {
    id: "latex",
    scopeName: "text.tex.latex",
    path: "latex.tmLanguage.json",
    embeddedLangs: ["tex", "css", "haskell", "html", "xml", "java", "lua", "julia", "ruby", "javascript", "typescript", "python", "yaml", "rust", "scala", "gnuplot"]
  },
  {
    id: "less",
    scopeName: "source.css.less",
    path: "less.tmLanguage.json",
    embeddedLangs: ["css"]
  },
  {
    id: "liquid",
    scopeName: "text.html.liquid",
    path: "liquid.tmLanguage.json",
    samplePath: "liquid.sample",
    embeddedLangs: ["html", "css", "json", "javascript"]
  },
  {
    id: "lisp",
    scopeName: "source.lisp",
    path: "lisp.tmLanguage.json"
  },
  {
    id: "logo",
    scopeName: "source.logo",
    path: "logo.tmLanguage.json"
  },
  {
    id: "lua",
    scopeName: "source.lua",
    path: "lua.tmLanguage.json",
    embeddedLangs: ["c"]
  },
  {
    id: "make",
    scopeName: "source.makefile",
    path: "make.tmLanguage.json",
    aliases: ["makefile"]
  },
  {
    id: "markdown",
    scopeName: "text.html.markdown",
    path: "markdown.tmLanguage.json",
    aliases: ["md"],
    embeddedLangs: ["css", "html", "ini", "java", "lua", "make", "perl", "r", "ruby", "php", "sql", "vb", "xml", "xsl", "yaml", "bat", "clojure", "coffee", "c", "cpp", "diff", "docker", "git-commit", "git-rebase", "go", "groovy", "pug", "javascript", "json", "jsonc", "less", "objective-c", "swift", "scss", "raku", "powershell", "python", "julia", "rust", "scala", "shellscript", "typescript", "tsx", "csharp", "fsharp", "dart", "handlebars", "erlang", "elixir", "latex", "bibtex"]
  },
  {
    id: "marko",
    scopeName: "text.marko",
    path: "marko.tmLanguage.json",
    embeddedLangs: ["css", "less", "scss", "typescript"]
  },
  {
    id: "matlab",
    scopeName: "source.matlab",
    path: "matlab.tmLanguage.json"
  },
  {
    id: "mdx",
    scopeName: "text.html.markdown.jsx",
    path: "mdx.tmLanguage.json",
    embeddedLangs: ["jsx", "markdown"]
  },
  {
    id: "mermaid",
    scopeName: "source.mermaid",
    path: "mermaid.tmLanguage.json"
  },
  {
    id: "nginx",
    scopeName: "source.nginx",
    path: "nginx.tmLanguage.json",
    embeddedLangs: ["lua"]
  },
  {
    id: "nim",
    scopeName: "source.nim",
    path: "nim.tmLanguage.json",
    embeddedLangs: ["c", "html", "xml", "javascript", "css", "glsl", "markdown"]
  },
  {
    id: "nix",
    scopeName: "source.nix",
    path: "nix.tmLanguage.json"
  },
  {
    id: "objective-c",
    scopeName: "source.objc",
    path: "objective-c.tmLanguage.json",
    aliases: ["objc"]
  },
  {
    id: "objective-cpp",
    scopeName: "source.objcpp",
    path: "objective-cpp.tmLanguage.json"
  },
  {
    id: "ocaml",
    scopeName: "source.ocaml",
    path: "ocaml.tmLanguage.json"
  },
  {
    id: "pascal",
    scopeName: "source.pascal",
    path: "pascal.tmLanguage.json"
  },
  {
    id: "perl",
    scopeName: "source.perl",
    path: "perl.tmLanguage.json",
    embeddedLangs: ["html", "xml", "css", "javascript", "sql"]
  },
  {
    id: "php",
    scopeName: "source.php",
    path: "php.tmLanguage.json",
    embeddedLangs: ["html", "xml", "sql", "javascript", "json", "css"]
  },
  {
    id: "plsql",
    scopeName: "source.plsql.oracle",
    path: "plsql.tmLanguage.json"
  },
  {
    id: "postcss",
    scopeName: "source.css.postcss",
    path: "postcss.tmLanguage.json"
  },
  {
    id: "powerquery",
    scopeName: "source.powerquery",
    path: "powerquery.tmLanguage.json",
    samplePath: "powerquery.sample"
  },
  {
    id: "powershell",
    scopeName: "source.powershell",
    path: "powershell.tmLanguage.json",
    aliases: ["ps", "ps1"]
  },
  {
    id: "prisma",
    scopeName: "source.prisma",
    path: "prisma.tmLanguage.json",
    samplePath: "prisma.sample"
  },
  {
    id: "prolog",
    scopeName: "source.prolog",
    path: "prolog.tmLanguage.json"
  },
  {
    id: "proto",
    scopeName: "source.proto",
    path: "proto.tmLanguage.json",
    samplePath: "proto.sample"
  },
  {
    id: "pug",
    scopeName: "text.pug",
    path: "pug.tmLanguage.json",
    aliases: ["jade"],
    embeddedLangs: ["javascript", "css", "sass", "scss", "stylus", "coffee", "html"]
  },
  {
    id: "puppet",
    scopeName: "source.puppet",
    path: "puppet.tmLanguage.json"
  },
  {
    id: "purescript",
    scopeName: "source.purescript",
    path: "purescript.tmLanguage.json"
  },
  {
    id: "python",
    scopeName: "source.python",
    path: "python.tmLanguage.json",
    samplePath: "python.sample",
    aliases: ["py"]
  },
  {
    id: "r",
    scopeName: "source.r",
    path: "r.tmLanguage.json"
  },
  {
    id: "raku",
    scopeName: "source.perl.6",
    path: "raku.tmLanguage.json",
    aliases: ["perl6"]
  },
  {
    id: "razor",
    scopeName: "text.aspnetcorerazor",
    path: "razor.tmLanguage.json",
    embeddedLangs: ["html", "csharp"]
  },
  {
    id: "rel",
    scopeName: "source.rel",
    path: "rel.tmLanguage.json",
    samplePath: "rel.sample"
  },
  {
    id: "riscv",
    scopeName: "source.riscv",
    path: "riscv.tmLanguage.json"
  },
  {
    id: "rst",
    scopeName: "source.rst",
    path: "rst.tmLanguage.json",
    embeddedLangs: ["cpp", "python", "javascript", "shellscript", "yaml", "cmake", "ruby"]
  },
  {
    id: "ruby",
    scopeName: "source.ruby",
    path: "ruby.tmLanguage.json",
    samplePath: "ruby.sample",
    aliases: ["rb"],
    embeddedLangs: ["html", "xml", "sql", "css", "c", "javascript", "shellscript", "lua"]
  },
  {
    id: "rust",
    scopeName: "source.rust",
    path: "rust.tmLanguage.json",
    aliases: ["rs"]
  },
  {
    id: "sas",
    scopeName: "source.sas",
    path: "sas.tmLanguage.json",
    embeddedLangs: ["sql"]
  },
  {
    id: "sass",
    scopeName: "source.sass",
    path: "sass.tmLanguage.json"
  },
  {
    id: "scala",
    scopeName: "source.scala",
    path: "scala.tmLanguage.json"
  },
  {
    id: "scheme",
    scopeName: "source.scheme",
    path: "scheme.tmLanguage.json"
  },
  {
    id: "scss",
    scopeName: "source.css.scss",
    path: "scss.tmLanguage.json",
    embeddedLangs: ["css"]
  },
  {
    id: "shaderlab",
    scopeName: "source.shaderlab",
    path: "shaderlab.tmLanguage.json",
    aliases: ["shader"],
    embeddedLangs: ["hlsl"]
  },
  {
    id: "shellscript",
    scopeName: "source.shell",
    path: "shellscript.tmLanguage.json",
    aliases: ["bash", "console", "sh", "shell", "zsh"]
  },
  {
    id: "smalltalk",
    scopeName: "source.smalltalk",
    path: "smalltalk.tmLanguage.json"
  },
  {
    id: "solidity",
    scopeName: "source.solidity",
    path: "solidity.tmLanguage.json"
  },
  {
    id: "sparql",
    scopeName: "source.sparql",
    path: "sparql.tmLanguage.json",
    samplePath: "sparql.sample",
    embeddedLangs: ["turtle"]
  },
  {
    id: "sql",
    scopeName: "source.sql",
    path: "sql.tmLanguage.json"
  },
  {
    id: "ssh-config",
    scopeName: "source.ssh-config",
    path: "ssh-config.tmLanguage.json"
  },
  {
    id: "stata",
    scopeName: "source.stata",
    path: "stata.tmLanguage.json",
    samplePath: "stata.sample",
    embeddedLangs: ["sql"]
  },
  {
    id: "stylus",
    scopeName: "source.stylus",
    path: "stylus.tmLanguage.json",
    aliases: ["styl"]
  },
  {
    id: "svelte",
    scopeName: "source.svelte",
    path: "svelte.tmLanguage.json",
    embeddedLangs: ["javascript", "typescript", "coffee", "stylus", "sass", "css", "scss", "less", "postcss", "pug", "markdown"]
  },
  {
    id: "swift",
    scopeName: "source.swift",
    path: "swift.tmLanguage.json"
  },
  {
    id: "system-verilog",
    scopeName: "source.systemverilog",
    path: "system-verilog.tmLanguage.json"
  },
  {
    id: "tasl",
    scopeName: "source.tasl",
    path: "tasl.tmLanguage.json",
    samplePath: "tasl.sample"
  },
  {
    id: "tcl",
    scopeName: "source.tcl",
    path: "tcl.tmLanguage.json"
  },
  {
    id: "tex",
    scopeName: "text.tex",
    path: "tex.tmLanguage.json",
    embeddedLangs: ["r"]
  },
  {
    id: "toml",
    scopeName: "source.toml",
    path: "toml.tmLanguage.json"
  },
  {
    id: "tsx",
    scopeName: "source.tsx",
    path: "tsx.tmLanguage.json",
    samplePath: "tsx.sample"
  },
  {
    id: "turtle",
    scopeName: "source.turtle",
    path: "turtle.tmLanguage.json",
    samplePath: "turtle.sample"
  },
  {
    id: "twig",
    scopeName: "text.html.twig",
    path: "twig.tmLanguage.json",
    embeddedLangs: ["css", "javascript", "php", "python", "ruby"]
  },
  {
    id: "typescript",
    scopeName: "source.ts",
    path: "typescript.tmLanguage.json",
    aliases: ["ts"]
  },
  {
    id: "v",
    scopeName: "source.v",
    path: "v.tmLanguage.json",
    samplePath: "v.sample"
  },
  {
    id: "vb",
    scopeName: "source.asp.vb.net",
    path: "vb.tmLanguage.json",
    aliases: ["cmd"]
  },
  {
    id: "verilog",
    scopeName: "source.verilog",
    path: "verilog.tmLanguage.json"
  },
  {
    id: "vhdl",
    scopeName: "source.vhdl",
    path: "vhdl.tmLanguage.json"
  },
  {
    id: "viml",
    scopeName: "source.viml",
    path: "viml.tmLanguage.json",
    aliases: ["vim", "vimscript"]
  },
  {
    id: "vue-html",
    scopeName: "text.html.vue-html",
    path: "vue-html.tmLanguage.json",
    embeddedLangs: ["vue", "javascript"]
  },
  {
    id: "vue",
    scopeName: "source.vue",
    path: "vue.tmLanguage.json",
    embeddedLangs: ["html", "markdown", "pug", "stylus", "sass", "css", "scss", "less", "javascript", "typescript", "jsx", "tsx", "json", "jsonc", "json5", "yaml", "toml", "graphql"]
  },
  {
    id: "wasm",
    scopeName: "source.wat",
    path: "wasm.tmLanguage.json"
  },
  {
    id: "wenyan",
    scopeName: "source.wenyan",
    path: "wenyan.tmLanguage.json",
    aliases: ["文言"]
  },
  {
    id: "wgsl",
    scopeName: "source.wgsl",
    path: "wgsl.tmLanguage.json",
    samplePath: "wgsl.sample"
  },
  {
    id: "xml",
    scopeName: "text.xml",
    path: "xml.tmLanguage.json",
    embeddedLangs: ["java"]
  },
  {
    id: "xsl",
    scopeName: "text.xml.xsl",
    path: "xsl.tmLanguage.json",
    embeddedLangs: ["xml"]
  },
  {
    id: "yaml",
    scopeName: "source.yaml",
    path: "yaml.tmLanguage.json",
    aliases: ["yml"]
  },
  {
    id: "zenscript",
    scopeName: "source.zenscript",
    path: "zenscript.tmLanguage.json",
    samplePath: "zenscript.sample"
  }
];
var _e = /* @__PURE__ */ ((n) => (n[n.NotSet = -1] = "NotSet", n[n.None = 0] = "None", n[n.Italic = 1] = "Italic", n[n.Bold = 2] = "Bold", n[n.Underline = 4] = "Underline", n))(_e || {});
class ne {
  static toBinaryStr(e) {
    let t = e.toString(2);
    for (; t.length < 32; )
      t = "0" + t;
    return t;
  }
  static printMetadata(e) {
    let t = ne.getLanguageId(e), o = ne.getTokenType(e), r = ne.getFontStyle(e), s = ne.getForeground(e), a = ne.getBackground(e);
    console.log({
      languageId: t,
      tokenType: o,
      fontStyle: r,
      foreground: s,
      background: a
    });
  }
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static getFontStyle(e) {
    return (e & 14336) >>> 11;
  }
  static getForeground(e) {
    return (e & 8372224) >>> 15;
  }
  static getBackground(e) {
    return (e & 4286578688) >>> 24;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static set(e, t, o, r, s, a) {
    let c = ne.getLanguageId(e), l = ne.getTokenType(e), i = ne.getFontStyle(e), p = ne.getForeground(e), h = ne.getBackground(e), d = ne.containsBalancedBrackets(
      e
    ) ? 1 : 0;
    return t !== 0 && (c = t), o !== 0 && (l = o === 8 ? 0 : o), r !== -1 && (i = r), s !== 0 && (p = s), a !== 0 && (h = a), (c << 0 | l << 8 | i << 11 | d << 10 | p << 15 | h << 24) >>> 0;
  }
}
function Yge(n) {
  return n.endsWith("/") || n.endsWith("\\") ? n.slice(0, -1) : n;
}
function Xge(n) {
  return n.startsWith("./") ? n.slice(2) : n;
}
function zo(n) {
  const e = n.split(/[\/\\]/g);
  return e.slice(0, e.length - 1);
}
function $o(...n) {
  return n.map(Yge).map(Xge).join("/");
}
function Kge(n, e) {
  const t = /* @__PURE__ */ new Map();
  for (const o of n) {
    const r = e(o);
    t.has(r) ? t.get(r).push(o) : t.set(r, [o]);
  }
  return t;
}
function e_e(n, e = !1) {
  const t = n.length;
  let o = 0, r = "", s = 0, a = 16, c = 0, l = 0, i = 0, p = 0, h = 0;
  function d(w, E) {
    let y = 0, u = 0;
    for (; y < w || !E; ) {
      let g = n.charCodeAt(o);
      if (g >= 48 && g <= 57)
        u = u * 16 + g - 48;
      else if (g >= 65 && g <= 70)
        u = u * 16 + g - 65 + 10;
      else if (g >= 97 && g <= 102)
        u = u * 16 + g - 97 + 10;
      else
        break;
      o++, y++;
    }
    return y < w && (u = -1), u;
  }
  function f(w) {
    o = w, r = "", s = 0, a = 16, h = 0;
  }
  function m() {
    let w = o;
    if (n.charCodeAt(o) === 48)
      o++;
    else
      for (o++; o < n.length && Ie(n.charCodeAt(o)); )
        o++;
    if (o < n.length && n.charCodeAt(o) === 46)
      if (o++, o < n.length && Ie(n.charCodeAt(o)))
        for (o++; o < n.length && Ie(n.charCodeAt(o)); )
          o++;
      else
        return h = 3, n.substring(w, o);
    let E = o;
    if (o < n.length && (n.charCodeAt(o) === 69 || n.charCodeAt(o) === 101))
      if (o++, (o < n.length && n.charCodeAt(o) === 43 || n.charCodeAt(o) === 45) && o++, o < n.length && Ie(n.charCodeAt(o))) {
        for (o++; o < n.length && Ie(n.charCodeAt(o)); )
          o++;
        E = o;
      } else
        h = 3;
    return n.substring(w, E);
  }
  function S() {
    let w = "", E = o;
    for (; ; ) {
      if (o >= t) {
        w += n.substring(E, o), h = 2;
        break;
      }
      const y = n.charCodeAt(o);
      if (y === 34) {
        w += n.substring(E, o), o++;
        break;
      }
      if (y === 92) {
        if (w += n.substring(E, o), o++, o >= t) {
          h = 2;
          break;
        }
        switch (n.charCodeAt(o++)) {
          case 34:
            w += '"';
            break;
          case 92:
            w += "\\";
            break;
          case 47:
            w += "/";
            break;
          case 98:
            w += "\b";
            break;
          case 102:
            w += "\f";
            break;
          case 110:
            w += `
`;
            break;
          case 114:
            w += "\r";
            break;
          case 116:
            w += "	";
            break;
          case 117:
            const g = d(4, !0);
            g >= 0 ? w += String.fromCharCode(g) : h = 4;
            break;
          default:
            h = 5;
        }
        E = o;
        continue;
      }
      if (y >= 0 && y <= 31)
        if (Ve(y)) {
          w += n.substring(E, o), h = 2;
          break;
        } else
          h = 6;
      o++;
    }
    return w;
  }
  function L() {
    if (r = "", h = 0, s = o, l = c, p = i, o >= t)
      return s = t, a = 17;
    let w = n.charCodeAt(o);
    if (Fn(w)) {
      do
        o++, r += String.fromCharCode(w), w = n.charCodeAt(o);
      while (Fn(w));
      return a = 15;
    }
    if (Ve(w))
      return o++, r += String.fromCharCode(w), w === 13 && n.charCodeAt(o) === 10 && (o++, r += `
`), c++, i = o, a = 14;
    switch (w) {
      case 123:
        return o++, a = 1;
      case 125:
        return o++, a = 2;
      case 91:
        return o++, a = 3;
      case 93:
        return o++, a = 4;
      case 58:
        return o++, a = 6;
      case 44:
        return o++, a = 5;
      case 34:
        return o++, r = S(), a = 10;
      case 47:
        const E = o - 1;
        if (n.charCodeAt(o + 1) === 47) {
          for (o += 2; o < t && !Ve(n.charCodeAt(o)); )
            o++;
          return r = n.substring(E, o), a = 12;
        }
        if (n.charCodeAt(o + 1) === 42) {
          o += 2;
          const y = t - 1;
          let u = !1;
          for (; o < y; ) {
            const g = n.charCodeAt(o);
            if (g === 42 && n.charCodeAt(o + 1) === 47) {
              o += 2, u = !0;
              break;
            }
            o++, Ve(g) && (g === 13 && n.charCodeAt(o) === 10 && o++, c++, i = o);
          }
          return u || (o++, h = 1), r = n.substring(E, o), a = 13;
        }
        return r += String.fromCharCode(w), o++, a = 16;
      case 45:
        if (r += String.fromCharCode(w), o++, o === t || !Ie(n.charCodeAt(o)))
          return a = 16;
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return r += m(), a = 11;
      default:
        for (; o < t && _(w); )
          o++, w = n.charCodeAt(o);
        if (s !== o) {
          switch (r = n.substring(s, o), r) {
            case "true":
              return a = 8;
            case "false":
              return a = 9;
            case "null":
              return a = 7;
          }
          return a = 16;
        }
        return r += String.fromCharCode(w), o++, a = 16;
    }
  }
  function _(w) {
    if (Fn(w) || Ve(w))
      return !1;
    switch (w) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return !1;
    }
    return !0;
  }
  function k() {
    let w;
    do
      w = L();
    while (w >= 12 && w <= 15);
    return w;
  }
  return {
    setPosition: f,
    getPosition: () => o,
    scan: e ? k : L,
    getToken: () => a,
    getTokenValue: () => r,
    getTokenOffset: () => s,
    getTokenLength: () => o - s,
    getTokenStartLine: () => l,
    getTokenStartCharacter: () => s - p,
    getTokenError: () => h
  };
}
function Fn(n) {
  return n === 32 || n === 9;
}
function Ve(n) {
  return n === 10 || n === 13;
}
function Ie(n) {
  return n >= 48 && n <= 57;
}
var Kt;
(function(n) {
  n[n.lineFeed = 10] = "lineFeed", n[n.carriageReturn = 13] = "carriageReturn", n[n.space = 32] = "space", n[n._0 = 48] = "_0", n[n._1 = 49] = "_1", n[n._2 = 50] = "_2", n[n._3 = 51] = "_3", n[n._4 = 52] = "_4", n[n._5 = 53] = "_5", n[n._6 = 54] = "_6", n[n._7 = 55] = "_7", n[n._8 = 56] = "_8", n[n._9 = 57] = "_9", n[n.a = 97] = "a", n[n.b = 98] = "b", n[n.c = 99] = "c", n[n.d = 100] = "d", n[n.e = 101] = "e", n[n.f = 102] = "f", n[n.g = 103] = "g", n[n.h = 104] = "h", n[n.i = 105] = "i", n[n.j = 106] = "j", n[n.k = 107] = "k", n[n.l = 108] = "l", n[n.m = 109] = "m", n[n.n = 110] = "n", n[n.o = 111] = "o", n[n.p = 112] = "p", n[n.q = 113] = "q", n[n.r = 114] = "r", n[n.s = 115] = "s", n[n.t = 116] = "t", n[n.u = 117] = "u", n[n.v = 118] = "v", n[n.w = 119] = "w", n[n.x = 120] = "x", n[n.y = 121] = "y", n[n.z = 122] = "z", n[n.A = 65] = "A", n[n.B = 66] = "B", n[n.C = 67] = "C", n[n.D = 68] = "D", n[n.E = 69] = "E", n[n.F = 70] = "F", n[n.G = 71] = "G", n[n.H = 72] = "H", n[n.I = 73] = "I", n[n.J = 74] = "J", n[n.K = 75] = "K", n[n.L = 76] = "L", n[n.M = 77] = "M", n[n.N = 78] = "N", n[n.O = 79] = "O", n[n.P = 80] = "P", n[n.Q = 81] = "Q", n[n.R = 82] = "R", n[n.S = 83] = "S", n[n.T = 84] = "T", n[n.U = 85] = "U", n[n.V = 86] = "V", n[n.W = 87] = "W", n[n.X = 88] = "X", n[n.Y = 89] = "Y", n[n.Z = 90] = "Z", n[n.asterisk = 42] = "asterisk", n[n.backslash = 92] = "backslash", n[n.closeBrace = 125] = "closeBrace", n[n.closeBracket = 93] = "closeBracket", n[n.colon = 58] = "colon", n[n.comma = 44] = "comma", n[n.dot = 46] = "dot", n[n.doubleQuote = 34] = "doubleQuote", n[n.minus = 45] = "minus", n[n.openBrace = 123] = "openBrace", n[n.openBracket = 91] = "openBracket", n[n.plus = 43] = "plus", n[n.slash = 47] = "slash", n[n.formFeed = 12] = "formFeed", n[n.tab = 9] = "tab";
})(Kt || (Kt = {}));
var pn;
(function(n) {
  n.DEFAULT = {
    allowTrailingComma: !1
  };
})(pn || (pn = {}));
function n_e(n, e = [], t = pn.DEFAULT) {
  let o = null, r = [];
  const s = [];
  function a(l) {
    Array.isArray(r) ? r.push(l) : o !== null && (r[o] = l);
  }
  return t_e(n, {
    onObjectBegin: () => {
      const l = {};
      a(l), s.push(r), r = l, o = null;
    },
    onObjectProperty: (l) => {
      o = l;
    },
    onObjectEnd: () => {
      r = s.pop();
    },
    onArrayBegin: () => {
      const l = [];
      a(l), s.push(r), r = l, o = null;
    },
    onArrayEnd: () => {
      r = s.pop();
    },
    onLiteralValue: a,
    onError: (l, i, p) => {
      e.push({ error: l, offset: i, length: p });
    }
  }, t), r[0];
}
function t_e(n, e, t = pn.DEFAULT) {
  const o = e_e(n, !1), r = [];
  function s(C) {
    return C ? () => C(o.getTokenOffset(), o.getTokenLength(), o.getTokenStartLine(), o.getTokenStartCharacter()) : () => !0;
  }
  function a(C) {
    return C ? () => C(o.getTokenOffset(), o.getTokenLength(), o.getTokenStartLine(), o.getTokenStartCharacter(), () => r.slice()) : () => !0;
  }
  function c(C) {
    return C ? (D) => C(D, o.getTokenOffset(), o.getTokenLength(), o.getTokenStartLine(), o.getTokenStartCharacter()) : () => !0;
  }
  function l(C) {
    return C ? (D) => C(D, o.getTokenOffset(), o.getTokenLength(), o.getTokenStartLine(), o.getTokenStartCharacter(), () => r.slice()) : () => !0;
  }
  const i = a(e.onObjectBegin), p = l(e.onObjectProperty), h = s(e.onObjectEnd), d = a(e.onArrayBegin), f = s(e.onArrayEnd), m = l(e.onLiteralValue), S = c(e.onSeparator), L = s(e.onComment), _ = c(e.onError), k = t && t.disallowComments, w = t && t.allowTrailingComma;
  function E() {
    for (; ; ) {
      const C = o.scan();
      switch (o.getTokenError()) {
        case 4:
          y(
            14
            /* ParseErrorCode.InvalidUnicode */
          );
          break;
        case 5:
          y(
            15
            /* ParseErrorCode.InvalidEscapeCharacter */
          );
          break;
        case 3:
          y(
            13
            /* ParseErrorCode.UnexpectedEndOfNumber */
          );
          break;
        case 1:
          k || y(
            11
            /* ParseErrorCode.UnexpectedEndOfComment */
          );
          break;
        case 2:
          y(
            12
            /* ParseErrorCode.UnexpectedEndOfString */
          );
          break;
        case 6:
          y(
            16
            /* ParseErrorCode.InvalidCharacter */
          );
          break;
      }
      switch (C) {
        case 12:
        case 13:
          k ? y(
            10
            /* ParseErrorCode.InvalidCommentToken */
          ) : L();
          break;
        case 16:
          y(
            1
            /* ParseErrorCode.InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return C;
      }
    }
  }
  function y(C, D = [], T = []) {
    if (_(C), D.length + T.length > 0) {
      let q = o.getToken();
      for (; q !== 17; ) {
        if (D.indexOf(q) !== -1) {
          E();
          break;
        } else if (T.indexOf(q) !== -1)
          break;
        q = E();
      }
    }
  }
  function u(C) {
    const D = o.getTokenValue();
    return C ? m(D) : (p(D), r.push(D)), E(), !0;
  }
  function g() {
    switch (o.getToken()) {
      case 11:
        const C = o.getTokenValue();
        let D = Number(C);
        isNaN(D) && (y(
          2
          /* ParseErrorCode.InvalidNumberFormat */
        ), D = 0), m(D);
        break;
      case 7:
        m(null);
        break;
      case 8:
        m(!0);
        break;
      case 9:
        m(!1);
        break;
      default:
        return !1;
    }
    return E(), !0;
  }
  function x() {
    return o.getToken() !== 10 ? (y(3, [], [
      2,
      5
      /* SyntaxKind.CommaToken */
    ]), !1) : (u(!1), o.getToken() === 6 ? (S(":"), E(), A() || y(4, [], [
      2,
      5
      /* SyntaxKind.CommaToken */
    ])) : y(5, [], [
      2,
      5
      /* SyntaxKind.CommaToken */
    ]), r.pop(), !0);
  }
  function b() {
    i(), E();
    let C = !1;
    for (; o.getToken() !== 2 && o.getToken() !== 17; ) {
      if (o.getToken() === 5) {
        if (C || y(4, [], []), S(","), E(), o.getToken() === 2 && w)
          break;
      } else
        C && y(6, [], []);
      x() || y(4, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]), C = !0;
    }
    return h(), o.getToken() !== 2 ? y(7, [
      2
      /* SyntaxKind.CloseBraceToken */
    ], []) : E(), !0;
  }
  function v() {
    d(), E();
    let C = !0, D = !1;
    for (; o.getToken() !== 4 && o.getToken() !== 17; ) {
      if (o.getToken() === 5) {
        if (D || y(4, [], []), S(","), E(), o.getToken() === 4 && w)
          break;
      } else
        D && y(6, [], []);
      C ? (r.push(0), C = !1) : r[r.length - 1]++, A() || y(4, [], [
        4,
        5
        /* SyntaxKind.CommaToken */
      ]), D = !0;
    }
    return f(), C || r.pop(), o.getToken() !== 4 ? y(8, [
      4
      /* SyntaxKind.CloseBracketToken */
    ], []) : E(), !0;
  }
  function A() {
    switch (o.getToken()) {
      case 3:
        return v();
      case 1:
        return b();
      case 10:
        return u(!0);
      default:
        return g();
    }
  }
  return E(), o.getToken() === 17 ? t.allowEmptyContent ? !0 : (y(4, [], []), !1) : A() ? (o.getToken() !== 17 && y(9, [], []), !0) : (y(4, [], []), !1);
}
var eo;
(function(n) {
  n[n.None = 0] = "None", n[n.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment", n[n.UnexpectedEndOfString = 2] = "UnexpectedEndOfString", n[n.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber", n[n.InvalidUnicode = 4] = "InvalidUnicode", n[n.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter", n[n.InvalidCharacter = 6] = "InvalidCharacter";
})(eo || (eo = {}));
var no;
(function(n) {
  n[n.OpenBraceToken = 1] = "OpenBraceToken", n[n.CloseBraceToken = 2] = "CloseBraceToken", n[n.OpenBracketToken = 3] = "OpenBracketToken", n[n.CloseBracketToken = 4] = "CloseBracketToken", n[n.CommaToken = 5] = "CommaToken", n[n.ColonToken = 6] = "ColonToken", n[n.NullKeyword = 7] = "NullKeyword", n[n.TrueKeyword = 8] = "TrueKeyword", n[n.FalseKeyword = 9] = "FalseKeyword", n[n.StringLiteral = 10] = "StringLiteral", n[n.NumericLiteral = 11] = "NumericLiteral", n[n.LineCommentTrivia = 12] = "LineCommentTrivia", n[n.BlockCommentTrivia = 13] = "BlockCommentTrivia", n[n.LineBreakTrivia = 14] = "LineBreakTrivia", n[n.Trivia = 15] = "Trivia", n[n.Unknown = 16] = "Unknown", n[n.EOF = 17] = "EOF";
})(no || (no = {}));
const o_e = n_e;
var to;
(function(n) {
  n[n.InvalidSymbol = 1] = "InvalidSymbol", n[n.InvalidNumberFormat = 2] = "InvalidNumberFormat", n[n.PropertyNameExpected = 3] = "PropertyNameExpected", n[n.ValueExpected = 4] = "ValueExpected", n[n.ColonExpected = 5] = "ColonExpected", n[n.CommaExpected = 6] = "CommaExpected", n[n.CloseBraceExpected = 7] = "CloseBraceExpected", n[n.CloseBracketExpected = 8] = "CloseBracketExpected", n[n.EndOfFileExpected = 9] = "EndOfFileExpected", n[n.InvalidCommentToken = 10] = "InvalidCommentToken", n[n.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment", n[n.UnexpectedEndOfString = 12] = "UnexpectedEndOfString", n[n.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber", n[n.InvalidUnicode = 14] = "InvalidUnicode", n[n.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter", n[n.InvalidCharacter = 16] = "InvalidCharacter";
})(to || (to = {}));
const s_e = typeof self < "u" && typeof self.WorkerGlobalScope < "u", r_e = "process" in globalThis && typeof process < "u" && typeof process.release < "u" && process.release.name === "node", ct = s_e || !r_e;
let c_e = "";
const a_e = "dist/";
let Mn = null;
async function i_e(n) {
  if (!Mn) {
    let e;
    if (ct)
      e = Fe.loadWASM({
        data: await fetch(Go($o(...zo(n), "onig.wasm")))
      });
    else {
      const o = require("path").join(require.resolve("vscode-oniguruma"), "../onig.wasm"), s = require("fs").readFileSync(o).buffer;
      e = Fe.loadWASM(s);
    }
    Mn = e.then(() => ({
      createOnigScanner(t) {
        return Fe.createOnigScanner(t);
      },
      createOnigString(t) {
        return Fe.createOnigString(t);
      }
    }));
  }
  return Mn;
}
function Go(n) {
  if (ct)
    return `${c_e}${n}`;
  {
    const e = require("path");
    return e.isAbsolute(n) ? n : e.resolve(__dirname, "..", n);
  }
}
async function l_e(n) {
  const e = Go(n);
  return ct ? await fetch(e).then((t) => t.text()) : await require("fs").promises.readFile(e, "utf-8");
}
async function Uo(n) {
  const e = [], t = o_e(await l_e(n), e, {
    allowTrailingComma: !0
  });
  if (e.length)
    throw e[0];
  return t;
}
async function Ho(n) {
  let e = await Uo(n);
  const t = Vo(e);
  if (t.include) {
    const o = await Ho($o(...zo(n), t.include));
    o.settings && (t.settings = o.settings.concat(t.settings)), o.bg && !t.bg && (t.bg = o.bg), o.colors && (t.colors = { ...o.colors, ...t.colors }), delete t.include;
  }
  return t;
}
async function u_e(n) {
  return await Uo(n);
}
function p_e(n) {
  n.settings || (n.settings = []), !(n.settings[0] && n.settings[0].settings && !n.settings[0].scope) && n.settings.unshift({
    settings: {
      foreground: n.fg,
      background: n.bg
    }
  });
}
function Vo(n) {
  const e = n.type || "dark", t = {
    name: n.name,
    type: e,
    ...n,
    ...h_e(n)
  };
  return n.include && (t.include = n.include), n.tokenColors && (t.settings = n.tokenColors, delete t.tokenColors), p_e(t), t;
}
const oo = { light: "#333333", dark: "#bbbbbb" }, so = { light: "#fffffe", dark: "#1e1e1e" };
function h_e(n) {
  var s, a, c, l;
  let e, t, o = n.settings ? n.settings : n.tokenColors;
  const r = o ? o.find((i) => !i.name && !i.scope) : void 0;
  return (s = r == null ? void 0 : r.settings) != null && s.foreground && (e = r.settings.foreground), (a = r == null ? void 0 : r.settings) != null && a.background && (t = r.settings.background), !e && ((c = n == null ? void 0 : n.colors) != null && c["editor.foreground"]) && (e = n.colors["editor.foreground"]), !t && ((l = n == null ? void 0 : n.colors) != null && l["editor.background"]) && (t = n.colors["editor.background"]), e || (e = n.type === "light" ? oo.light : oo.dark), t || (t = n.type === "light" ? so.light : so.dark), {
    fg: e,
    bg: t
  };
}
class d_e {
  constructor(e, t) {
    this.languagesPath = "languages/", this.languageMap = {}, this.scopeToLangMap = {}, this._onigLibPromise = e, this._onigLibName = t;
  }
  get onigLib() {
    return this._onigLibPromise;
  }
  getOnigLibName() {
    return this._onigLibName;
  }
  getLangRegistration(e) {
    return this.languageMap[e];
  }
  async loadGrammar(e) {
    const t = this.scopeToLangMap[e];
    if (!t)
      return null;
    if (t.grammar)
      return t.grammar;
    const o = await u_e(
      vn.includes(t) ? `${this.languagesPath}${t.path}` : t.path
    );
    return t.grammar = o, o;
  }
  addLanguage(e) {
    this.languageMap[e.id] = e, e.aliases && e.aliases.forEach((t) => {
      this.languageMap[t] = e;
    }), this.scopeToLangMap[e.scopeName] = e;
  }
}
function f_e(n, e, t, o, r) {
  let s = t.split(/\r\n|\r|\n/), a = un.INITIAL, c = [], l = [];
  for (let i = 0, p = s.length; i < p; i++) {
    let h = s[i];
    if (h === "") {
      c = [], l.push([]);
      continue;
    }
    let d, f, m;
    r.includeExplanation && (d = o.tokenizeLine(h, a), f = d.tokens, m = 0);
    let S = o.tokenizeLine2(h, a), L = S.tokens.length / 2;
    for (let _ = 0; _ < L; _++) {
      let k = S.tokens[2 * _], w = _ + 1 < L ? S.tokens[2 * _ + 2] : h.length;
      if (k === w)
        continue;
      let E = S.tokens[2 * _ + 1], y = ne.getForeground(E), u = e[y], g = ne.getFontStyle(E), x = [];
      if (r.includeExplanation) {
        let b = 0;
        for (; k + b < w; ) {
          let v = f[m], A = h.substring(
            v.startIndex,
            v.endIndex
          );
          b += A.length, x.push({
            content: A,
            scopes: m_e(n, v.scopes)
          }), m++;
        }
      }
      c.push({
        content: h.substring(k, w),
        color: u,
        fontStyle: g,
        explanation: x
      });
    }
    l.push(c), c = [], a = S.ruleStack;
  }
  return l;
}
function m_e(n, e) {
  let t = [];
  for (let o = 0, r = e.length; o < r; o++) {
    let s = e.slice(0, o), a = e[o];
    t[o] = {
      scopeName: a,
      themeMatches: __e(n, a, s)
    };
  }
  return t;
}
function ro(n, e) {
  let t = n + ".";
  return n === e || e.substring(0, t.length) === t;
}
function g_e(n, e, t, o) {
  if (!ro(n, t))
    return !1;
  let r = e.length - 1, s = o.length - 1;
  for (; r >= 0 && s >= 0; )
    ro(e[r], o[s]) && r--, s--;
  return r === -1;
}
function __e(n, e, t) {
  let o = [], r = 0;
  for (let s = 0, a = n.settings.length; s < a; s++) {
    let c = n.settings[s], l;
    if (typeof c.scope == "string")
      l = c.scope.split(/,/).map((i) => i.trim());
    else if (Array.isArray(c.scope))
      l = c.scope;
    else
      continue;
    for (let i = 0, p = l.length; i < p; i++) {
      let d = l[i].split(/ /), f = d[d.length - 1], m = d.slice(0, d.length - 1);
      g_e(f, m, e, t) && (o[r++] = c, i = p);
    }
  }
  return o;
}
var Ce = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], Bn = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function b_e(n, e) {
  const t = n.indexOf("\x1B", e);
  if (t !== -1 && n[t + 1] === "[") {
    const o = n.indexOf("m", t);
    return {
      sequence: n.substring(t + 2, o).split(";"),
      startPosition: t,
      position: o + 1
    };
  }
  return {
    position: n.length
  };
}
function co(n) {
  const e = n.shift();
  if (e === "2") {
    const t = n.splice(0, 3).map((o) => Number.parseInt(o));
    return t.length !== 3 || t.some((o) => Number.isNaN(o)) ? void 0 : {
      type: "rgb",
      rgb: t
    };
  } else if (e === "5") {
    const t = n.shift();
    if (t)
      return { type: "table", index: Number(t) };
  }
}
function k_e(n) {
  const e = [];
  for (; n.length > 0; ) {
    const t = n.shift();
    if (!t)
      continue;
    const o = Number.parseInt(t);
    if (!Number.isNaN(o))
      if (o === 0)
        e.push({ type: "resetAll" });
      else if (o <= 9)
        Bn[o] && e.push({
          type: "setDecoration",
          value: Bn[o]
        });
      else if (o <= 29) {
        const r = Bn[o - 20];
        r && e.push({
          type: "resetDecoration",
          value: r
        });
      } else if (o <= 37)
        e.push({
          type: "setForegroundColor",
          value: { type: "named", name: Ce[o - 30] }
        });
      else if (o === 38) {
        const r = co(n);
        r && e.push({
          type: "setForegroundColor",
          value: r
        });
      } else if (o === 39)
        e.push({
          type: "resetForegroundColor"
        });
      else if (o <= 47)
        e.push({
          type: "setBackgroundColor",
          value: { type: "named", name: Ce[o - 40] }
        });
      else if (o === 48) {
        const r = co(n);
        r && e.push({
          type: "setBackgroundColor",
          value: r
        });
      } else
        o === 49 ? e.push({
          type: "resetBackgroundColor"
        }) : o >= 90 && o <= 97 ? e.push({
          type: "setForegroundColor",
          value: { type: "named", name: Ce[o - 90 + 8] }
        }) : o >= 100 && o <= 107 && e.push({
          type: "setBackgroundColor",
          value: { type: "named", name: Ce[o - 100 + 8] }
        });
  }
  return e;
}
function w_e() {
  let n = null, e = null, t = /* @__PURE__ */ new Set();
  return {
    parse(o) {
      const r = [];
      let s = 0;
      do {
        const a = b_e(o, s), c = a.sequence ? o.substring(s, a.startPosition) : o.substring(s);
        if (c.length > 0 && r.push({
          value: c,
          foreground: n,
          background: e,
          decorations: new Set(t)
        }), a.sequence) {
          const l = k_e(a.sequence);
          for (const i of l)
            i.type === "resetAll" ? (n = null, e = null, t.clear()) : i.type === "resetForegroundColor" ? n = null : i.type === "resetBackgroundColor" ? e = null : i.type === "resetDecoration" && t.delete(i.value);
          for (const i of l)
            i.type === "setForegroundColor" ? n = i.value : i.type === "setBackgroundColor" ? e = i.value : i.type === "setDecoration" && t.add(i.value);
        }
        s = a.position;
      } while (s < o.length);
      return r;
    }
  };
}
var y_e = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function v_e(n = y_e) {
  function e(c) {
    return n[c];
  }
  function t(c) {
    return `#${c.map((l) => Math.max(0, Math.min(l, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let o;
  function r() {
    if (o)
      return o;
    o = [];
    for (let i = 0; i < Ce.length; i++)
      o.push(e(Ce[i]));
    let c = [0, 95, 135, 175, 215, 255];
    for (let i = 0; i < 6; i++)
      for (let p = 0; p < 6; p++)
        for (let h = 0; h < 6; h++)
          o.push(t([c[i], c[p], c[h]]));
    let l = 8;
    for (let i = 0; i < 24; i++, l += 10)
      o.push(t([l, l, l]));
    return o;
  }
  function s(c) {
    return r()[c];
  }
  function a(c) {
    switch (c.type) {
      case "named":
        return e(c.name);
      case "rgb":
        return t(c.rgb);
      case "table":
        return s(c.index);
    }
  }
  return {
    value: a
  };
}
function x_e(n, e) {
  const t = e.split(/\r?\n/), o = v_e(
    Object.fromEntries(
      Ce.map((s) => [
        s,
        n.colors[`terminal.ansi${s[0].toUpperCase()}${s.substring(1)}`]
      ])
    )
  ), r = w_e();
  return t.map(
    (s) => r.parse(s).map((a) => {
      let c;
      a.decorations.has("reverse") ? c = a.background ? o.value(a.background) : n.bg : c = a.foreground ? o.value(a.foreground) : n.fg, a.decorations.has("dim") && (c = A_e(c));
      let l = _e.None;
      return a.decorations.has("bold") && (l |= _e.Bold), a.decorations.has("italic") && (l |= _e.Italic), a.decorations.has("underline") && (l |= _e.Underline), {
        content: a.value,
        color: c,
        fontStyle: l
      };
    })
  );
}
function A_e(n) {
  const e = n.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (e)
    if (e[3]) {
      const t = Math.round(Number.parseInt(e[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${e[1]}${e[2]}${t}`;
    } else
      return e[2] ? `#${e[1]}${e[2]}80` : `#${Array.from(e[1]).map((t) => `${t}${t}`).join("")}80`;
  return n;
}
const S_e = {
  pre({ className: n, style: e, children: t }) {
    return `<pre class="${n}" style="${e}" tabindex="0">${t}</pre>`;
  },
  code({ children: n }) {
    return `<code>${n}</code>`;
  },
  line({ className: n, children: e }) {
    return `<span class="${n}">${e}</span>`;
  },
  token({ style: n, children: e }) {
    return `<span style="${n}">${e}</span>`;
  }
};
function ao(n, e = {}) {
  const t = e.bg || "#fff", o = Kge(e.lineOptions ?? [], (a) => a.line), r = e.elements || {};
  function s(a = "", c = {}, l) {
    const i = r[a] || S_e[a];
    return i ? (l = l.filter(Boolean), i({
      ...c,
      children: a === "code" ? l.join(`
`) : l.join("")
    })) : "";
  }
  return s(
    "pre",
    { className: "shiki " + (e.themeName || ""), style: `background-color: ${t}` },
    [
      e.langId ? `<div class="language-id">${e.langId}</div>` : "",
      s(
        "code",
        {},
        n.map((a, c) => {
          const l = c + 1, i = o.get(l) ?? [], p = C_e(i).join(" ");
          return s(
            "line",
            {
              className: p,
              lines: n,
              line: a,
              index: c
            },
            a.map((h, d) => {
              const f = [`color: ${h.color || e.fg}`];
              return h.fontStyle & _e.Italic && f.push("font-style: italic"), h.fontStyle & _e.Bold && f.push("font-weight: bold"), h.fontStyle & _e.Underline && f.push("text-decoration: underline"), s(
                "token",
                {
                  style: f.join("; "),
                  tokens: a,
                  token: h,
                  index: d
                },
                [E_e(h.content)]
              );
            })
          );
        })
      )
    ]
  );
}
const L_e = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function E_e(n) {
  return n.replace(/[&<>"']/g, (e) => L_e[e]);
}
function C_e(n) {
  const e = /* @__PURE__ */ new Set(["line"]);
  for (const t of n)
    for (const o of t.classes ?? [])
      e.add(o);
  return Array.from(e);
}
class T_e extends un.Registry {
  constructor(e) {
    super(e), this._resolver = e, this.themesPath = "themes/", this._resolvedThemes = {}, this._resolvedGrammars = {}, this._langGraph = /* @__PURE__ */ new Map(), this._langMap = vn.reduce((t, o) => (t[o.id] = o, t), {});
  }
  getTheme(e) {
    return typeof e == "string" ? this._resolvedThemes[e] : e;
  }
  async loadTheme(e) {
    return typeof e == "string" ? (this._resolvedThemes[e] || (this._resolvedThemes[e] = await Ho(`${this.themesPath}${e}.json`)), this._resolvedThemes[e]) : (e = Vo(e), e.name && (this._resolvedThemes[e.name] = e), e);
  }
  async loadThemes(e) {
    return await Promise.all(e.map((t) => this.loadTheme(t)));
  }
  getLoadedThemes() {
    return Object.keys(this._resolvedThemes);
  }
  getGrammar(e) {
    return this._resolvedGrammars[e];
  }
  async loadLanguage(e) {
    var s;
    const o = {
      embeddedLanguages: (s = e.embeddedLangs) == null ? void 0 : s.reduce(async (a, c, l) => {
        if (!this.getLoadedLanguages().includes(c) && this._resolver.getLangRegistration(c))
          return await this._resolver.loadGrammar(this._resolver.getLangRegistration(c).scopeName), a[this._resolver.getLangRegistration(c).scopeName] = l + 2, a;
      }, {}),
      balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
    }, r = await this.loadGrammarWithConfiguration(e.scopeName, 1, o);
    this._resolvedGrammars[e.id] = r, e.aliases && e.aliases.forEach((a) => {
      this._resolvedGrammars[a] = r;
    });
  }
  async loadLanguages(e) {
    for (const o of e)
      this.resolveEmbeddedLanguages(o);
    const t = Array.from(this._langGraph.values());
    for (const o of t)
      this._resolver.addLanguage(o);
    for (const o of t)
      await this.loadLanguage(o);
  }
  getLoadedLanguages() {
    return Object.keys(this._resolvedGrammars);
  }
  resolveEmbeddedLanguages(e) {
    if (this._langGraph.has(e.id) || this._langGraph.set(e.id, e), e.embeddedLangs)
      for (const t of e.embeddedLangs)
        this._langGraph.set(t, this._langMap[t]);
  }
}
function Wo(n) {
  return typeof n == "string" ? vn.find((e) => {
    var t;
    return e.id === n || ((t = e.aliases) == null ? void 0 : t.includes(n));
  }) : n;
}
function D_e(n) {
  var r;
  let e = vn, t = n.themes || [], o = (r = n.paths) != null && r.wasm ? n.paths.wasm.endsWith("/") ? n.paths.wasm : n.paths.wasm + "/" : a_e;
  return n.langs && (e = n.langs.map(Wo)), n.theme && t.unshift(n.theme), t.length || (t = ["nord"]), { _languages: e, _themes: t, _wasmPath: o };
}
async function q_e(n) {
  var x, b;
  const { _languages: e, _themes: t, _wasmPath: o } = D_e(n), r = new d_e(i_e(o), "vscode-oniguruma"), s = new T_e(r);
  (x = n.paths) != null && x.themes && (s.themesPath = n.paths.themes.endsWith("/") ? n.paths.themes : n.paths.themes + "/"), (b = n.paths) != null && b.languages && (r.languagesPath = n.paths.languages.endsWith("/") ? n.paths.languages : n.paths.languages + "/");
  const c = (await s.loadThemes(t))[0];
  let l;
  await s.loadLanguages(e);
  let i = {
    "#000001": "var(--shiki-color-text)",
    "#000002": "var(--shiki-color-background)",
    "#000004": "var(--shiki-token-constant)",
    "#000005": "var(--shiki-token-string)",
    "#000006": "var(--shiki-token-comment)",
    "#000007": "var(--shiki-token-keyword)",
    "#000008": "var(--shiki-token-parameter)",
    "#000009": "var(--shiki-token-function)",
    "#000010": "var(--shiki-token-string-expression)",
    "#000011": "var(--shiki-token-punctuation)",
    "#000012": "var(--shiki-token-link)"
  };
  function p(v) {
    i = v;
  }
  function h(v, A) {
    v.bg = i[v.bg] || v.bg, v.fg = i[v.fg] || v.fg, A.forEach((C, D) => {
      A[D] = i[C] || C;
    });
  }
  function d(v) {
    const A = v ? s.getTheme(v) : c;
    if (!A)
      throw Error(`No theme registration for ${v}`);
    (!l || l.name !== A.name) && (s.setTheme(A), l = A);
    const C = s.getColorMap();
    return A.type === "css" && h(A, C), { _theme: A, _colorMap: C };
  }
  function f(v) {
    const A = s.getGrammar(v);
    if (!A)
      throw Error(`No language registration for ${v}`);
    return { _grammar: A };
  }
  function m(v, A = "text", C, D = { includeExplanation: !0 }) {
    if (j_e(A))
      return [...v.split(/\r\n|\r|\n/).map((M) => [{ content: M }])];
    const { _grammar: T } = f(A), { _theme: q, _colorMap: R } = d(C);
    return f_e(q, R, v, T, D);
  }
  function S(v, A) {
    const { _theme: C } = d(A);
    return x_e(C, v);
  }
  function L(v, A = "text", C) {
    let D;
    typeof A == "object" ? D = A : D = {
      lang: A,
      theme: C
    };
    const T = m(v, D.lang, D.theme, {
      includeExplanation: !1
    }), { _theme: q } = d(D.theme);
    return ao(T, {
      fg: q.fg,
      bg: q.bg,
      lineOptions: D == null ? void 0 : D.lineOptions,
      themeName: q.name
    });
  }
  function _(v, A) {
    const C = S(v, A == null ? void 0 : A.theme), { _theme: D } = d(A == null ? void 0 : A.theme);
    return ao(C, {
      fg: D.fg,
      bg: D.bg,
      lineOptions: A == null ? void 0 : A.lineOptions,
      themeName: D.name
    });
  }
  async function k(v) {
    await s.loadTheme(v);
  }
  async function w(v) {
    const A = Wo(v);
    r.addLanguage(A), await s.loadLanguage(A);
  }
  function E() {
    return s.getLoadedThemes();
  }
  function y() {
    return s.getLoadedLanguages();
  }
  function u(v) {
    const { _theme: A } = d(v);
    return A.bg;
  }
  function g(v) {
    const { _theme: A } = d(v);
    return A.fg;
  }
  return {
    codeToThemedTokens: m,
    codeToHtml: L,
    ansiToThemedTokens: S,
    ansiToHtml: _,
    getTheme: (v) => d(v)._theme,
    loadTheme: k,
    loadLanguage: w,
    getBackgroundColor: u,
    getForegroundColor: g,
    getLoadedThemes: E,
    getLoadedLanguages: y,
    setColorReplacements: p
  };
}
function j_e(n) {
  return !n || ["plaintext", "txt", "text"].includes(n);
}
function xn(n, e = {}) {
  return ({ code: t }) => {
    const o = e.tagRegExp ?? /(?:\/\/|\/\*{1,2}) *\[!code ([\w+-]+)(?::(\d+))?] *(?:\*{1,2}\/)?/, r = [];
    return t = t.split(`
`).map((s, a) => {
      const [c, l, i] = s.match(o) ?? [];
      return !c || !Object.keys(n).includes(l) ? s : (Array.from({ length: Number(i ?? 1) }).forEach((p, h) => {
        r.push({
          line: a + h + 1,
          classes: n[l]
        });
      }), s.replace(o, ""));
    }).join(`
`), {
      code: t,
      lineOptions: r
    };
  };
}
function Qe(n, e, t) {
  const o = new RegExp(`<${t ?? "w+"}[^>]*class="([\\w+-:;\\/* ]*)"`);
  return e = Array.isArray(e) ? e : [e], n.replace(o, (r, s) => r.replace(s, `${s} ${e}`));
}
function R_e(n = {}) {
  const e = n.commonDiffClass ?? "diff", t = n.removedLinesClasses ?? ["remove"], o = n.removedLinesClasses ?? ["add"], r = n.removeLineTag ?? "--", s = n.addLineTag ?? "++", a = n.hasDiffClass ?? "has-diff";
  return {
    name: "diff",
    handler: xn({
      [r]: [e, ...t],
      [s]: [e, ...o]
    }, n),
    postProcess: ({ code: c }) => c.includes(e) ? Qe(c, a, "pre") : c
  };
}
function N_e(n = {}) {
  const e = n.hasFocusClass ?? "has-focus", t = n.hasFocusedLinesClass ?? "has-focused-lines", o = n.focusTag ?? "focus";
  return {
    name: "focus",
    handler: xn({
      [o]: [e]
    }, n),
    postProcess: ({ code: r }) => r.includes(e) ? Qe(r, t, "pre") : r
  };
}
function P_e(n = {}) {
  const e = n.hasHighlightClass ?? "has-highlight", t = n.hasHighlightedLinesClass ?? "has-highlighted-lines", o = n.highlightTag ?? "hl";
  return {
    name: "highlight",
    handler: xn({
      [o]: [e]
    }, n),
    postProcess: ({ code: r }) => r.includes(e) ? Qe(r, t, "pre") : r
  };
}
function I_e(n, e, t) {
  return n.reduce((o, r) => {
    var c;
    const { code: s, lineOptions: a } = ((c = r.handler) == null ? void 0 : c.call(r, {
      code: o.code,
      lang: t
    })) ?? o;
    return {
      code: s,
      lineOptions: [
        ...o.lineOptions,
        ...a
      ]
    };
  }, {
    code: e,
    lineOptions: []
  });
}
function O_e(n, e, t) {
  return n.reduce((o, r) => {
    var s;
    return ((s = r.postProcess) == null ? void 0 : s.call(r, {
      code: o,
      lang: t
    })) ?? o;
  }, e);
}
async function F_e(n = {}) {
  const e = await q_e(n), t = n.processors ?? [];
  return {
    ...e,
    codeToHtml: (o, r) => {
      const s = typeof r == "object" ? r.lang : r, a = typeof r == "object" ? r.lineOptions ?? [] : [], c = typeof r == "object" ? r.theme : void 0, { code: l, lineOptions: i } = I_e(t, o, s), p = e.codeToHtml(l, {
        lang: s,
        theme: c,
        lineOptions: [
          ...i,
          ...a
        ]
      });
      return O_e(t, p, s);
    }
  };
}
const M_e = $ge("abcdefghijklmnopqrstuvwxyz", 10), B_e = (n) => {
  n = n.replace(/^(?:\[.*?\])?.*?([\d,-]+).*/, "$1").trim();
  const e = [];
  return n ? (n.split(",").map((t) => t.split("-").map((o) => parseInt(o, 10))).forEach(([t, o]) => {
    t && o ? e.push(...Array.from({ length: o - t + 1 }, (r, s) => t + s)) : e.push(t);
  }), e.map((t) => ({
    line: t,
    classes: ["highlighted"]
  }))) : [];
}, z_e = {
  name: "error-level",
  handler: xn({
    error: ["highlighted", "error"],
    warning: ["highlighted", "warning"]
  })
};
async function $_e(n = "material-theme-palenight", e = [], t = "", o = console) {
  const r = typeof n == "string" || "name" in n, s = (S) => typeof S == "string" ? S : S.name, a = [
    N_e(),
    P_e({ hasHighlightClass: "highlighted" }),
    R_e(),
    z_e
  ], c = await F_e({
    themes: r ? [n] : [n.dark, n.light],
    // something wrong with shiki, cannot dynamic load css
    langs: ["css", ...e],
    processors: a
  }), l = async (S) => {
    S && !c.getLoadedLanguages().includes(S) && await c.loadLanguage(S);
  };
  await l(t);
  const i = /<pre[^>]*(style=".*?")/, p = /^<pre(.*?)>/, h = /-vue$/, d = /:(no-)?line-numbers$/, f = /\{\{.*?\}\}/g;
  return { plugin: (S, L, _) => {
    const k = h.test(L) ? "" : "v-pre";
    L = L.replace(d, "").replace(h, "").toLowerCase() || t, L && !c.getLoadedLanguages().includes(L) && L !== "ansi" && L !== "txt" && o.warn(
      // c.yellow(
      `
The language '${L}' is not loaded, falling back to '${t || "txt"}' for syntax highlighting.`
      // )
    );
    const w = B_e(_), E = (C) => C.replace(p, (D, T) => `<pre ${k}${T.replace(' tabindex="0"', "")}>`).replace(i, (D, T) => D.replace(T, "")), y = /* @__PURE__ */ new Map(), u = (C) => k ? C : C.replace(f, (D) => {
      let T = y.get(D);
      return T || (T = M_e(), y.set(D, T)), T;
    }), g = (C) => (y.forEach((D, T) => {
      C = C.replace(new RegExp(D, "gi"), T);
    }), C), x = (C) => C.replace(/(<span class="line highlighted">)(<\/span>)/g, "$1<wbr>$2");
    S = u(S);
    const b = (C) => {
      let D;
      try {
        D = L === "ansi" ? c.ansiToHtml(S, {
          lineOptions: w,
          theme: s(C)
        }) : c.codeToHtml(S, {
          lang: L,
          lineOptions: w,
          theme: s(C)
        });
      } catch {
        D = c.ansiToHtml(S, {
          lineOptions: w,
          theme: s(C)
        });
      }
      return x(E(g(D)));
    };
    if (r)
      return b(n);
    const v = Qe(b(n.dark), "vp-code-dark", "pre"), A = Qe(b(n.light), "vp-code-light", "pre");
    return v + A;
  }, highlighter: c, loadLang: l };
}
const zn = /{([\d,-]+)}/, G_e = (n) => {
  const e = n.renderer.rules.fence;
  n.renderer.rules.fence = (...t) => {
    const [o, r] = t, s = o[r], a = s.attrs && s.attrs[0];
    let c = null;
    if (!a) {
      const l = s.info;
      if (!l || !zn.test(l))
        return e(...t);
      const i = l.replace(zn, "").trim();
      s.info = i, c = zn.exec(l)[1];
    }
    return !c && (c = a[0], !c || !/[\d,-]+/.test(c)) ? e(...t) : (s.info += " " + c, e(...t));
  };
}, U_e = (n) => {
  const e = n.renderer.rules.image;
  n.renderer.rules.image = (t, o, r, s, a) => {
    const c = t[o];
    let l = c.attrGet("src");
    return l && !Jn.test(l) && (/^\.?\//.test(l) || (l = "./" + l), c.attrSet("src", decodeURIComponent(l))), e(t, o, r, s, a);
  };
}, H_e = (n, e = !1) => {
  const t = n.renderer.rules.fence;
  n.renderer.rules.fence = (...o) => {
    const r = t(...o), [s, a] = o, c = s[a].info;
    if (!e && !/:line-numbers($| )/.test(c) || e && /:no-line-numbers($| )/.test(c))
      return r;
    const i = r.slice(
      r.indexOf("<code>"),
      r.indexOf("</code>")
    ).split(`
`), h = `<div class="line-numbers-wrapper" aria-hidden="true">${[
      ...Array(
        i.length - (i[i.length - 1] === '<span class="line"></span>' ? 1 : 0)
      )
    ].map((f, m) => `<span class="line-number">${m + 1}</span><br>`).join("")}</div>`;
    return r.replace(/<\/div>$/, `${h}</div>`).replace(/"(language-[^"]*?)"/, '"$1 line-numbers-mode"');
  };
}, V_e = /(^|.*\/)index.md(#?.*)$/i, W_e = (n, e, t) => {
  n.renderer.rules.link_open = (s, a, c, l, i) => {
    const p = s[a], h = p.attrIndex("href");
    if (h >= 0) {
      const d = p.attrs[h], f = d[1];
      Jn.test(f) ? (Object.entries(e).forEach(([S, L]) => {
        p.attrSet(S, L);
      }), f.replace(Jn, "").startsWith("//localhost:") && r(f, l), d[1] = f.replace(Gge, "")) : (// internal anchor links
      !f.startsWith("#") && // mail links
      !f.startsWith("mailto:") && // links to files (other than html/md)
      !/\.(?!html|md)\w+($|\?)/i.test(f) ? o(d, l) : f.startsWith("#") && (d[1] = decodeURI(d[1])), d[1].startsWith("/") && (d[1] = `${t}${d[1]}`.replace(/\/+/g, "/"))), d[1] = d[1].replace(/\bimport\.meta/g, "import%2Emeta").replace(/\bprocess\.env/g, "process%2Eenv");
    }
    return i.renderToken(s, a, c);
  };
  function o(s, a) {
    let c = s[1];
    const l = c.match(V_e);
    if (l) {
      const [, i, p] = l;
      c = i + p;
    } else {
      let i = c.replace(/[?#].*$/, "");
      i.endsWith(".md") && (i = i.replace(/\.md$/, a.cleanUrls ? "" : ".html")), !a.cleanUrls && !i.endsWith(".html") && !i.endsWith("/") && (i += ".html");
      const p = new URL(c, "http://a.com");
      c = i + p.search + p.hash;
    }
    !c.startsWith("/") && !/^\.\//.test(c) && (c = "./" + c), r(c.replace(/\.html$/, ""), a), s[1] = decodeURI(c);
  }
  function r(s, a) {
    (a.links || (a.links = [])).push(s);
  }
}, Z_e = async (n = {}, e = "/", t = console) => {
  var c;
  const { plugin: o, highlighter: r, loadLang: s } = await $_e(n.theme, n.languages, n.defaultHighlightLang, t), a = x$({
    html: !0,
    linkify: !0,
    highlight: n.highlight || o,
    ...n
  });
  return a.linkify.set({ fuzzyLink: !1 }), a.use(G_e).use(Hge).use(Wge).use(U_e).use(W_e, { target: "_blank", rel: "noreferrer", ...n.externalLinks }, e).use(H_e, n.lineNumbers), (c = n.attrs) != null && c.disable || a.use(j$, n.attrs), a.use(Mge), a.use(Ee, {
    slugify: on,
    permalink: Ee.permalink.linkInsideHeader({
      symbol: "&ZeroWidthSpace;",
      renderAttrs: (l, i) => {
        const p = i.tokens.findIndex((d) => {
          const f = d.attrs, m = f == null ? void 0 : f.find((S) => S[0] === "id");
          return m && l === m[1];
        });
        return {
          "aria-label": `Permalink to "${i.tokens[p + 1].content}"`
        };
      }
    }),
    ...n.anchor
  }), n.headers && a.use(as, {
    level: [2, 3, 4, 5, 6],
    slugify: on,
    ...typeof n.headers == "boolean" ? void 0 : n.headers
  }), a.use(is).use(ps, {
    ...n.toc
  }), n.config && n.config(a), { md: a, highlighter: r, loadLang: s };
}, J_e = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Q_e = /* @__PURE__ */ ae("path", {
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5l5-5m-5-7v12"
}, null, -1), Y_e = [
  Q_e
];
function X_e(n, e) {
  return de(), Te("svg", J_e, Y_e);
}
const K_e = { name: "tabler-download", render: X_e }, ebe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, nbe = /* @__PURE__ */ ae("path", {
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  d: "m5 12l5 5L20 7"
}, null, -1), tbe = [
  nbe
];
function obe(n, e) {
  return de(), Te("svg", ebe, tbe);
}
const sbe = { name: "tabler-check", render: obe }, rbe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, cbe = /* @__PURE__ */ ae("g", {
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
}, [
  /* @__PURE__ */ ae("path", { d: "M8 10a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2z" }),
  /* @__PURE__ */ ae("path", { d: "M16 8V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2" })
], -1), abe = [
  cbe
];
function ibe(n, e) {
  return de(), Te("svg", rbe, abe);
}
const lbe = { name: "tabler-copy", render: ibe };
async function ube(n) {
  try {
    return navigator.clipboard.writeText(n);
  } catch {
    const e = document.createElement("textarea"), t = document.activeElement;
    e.value = n, e.setAttribute("readonly", ""), e.style.contain = "strict", e.style.position = "absolute", e.style.left = "-9999px", e.style.fontSize = "12pt";
    const o = document.getSelection(), r = o ? o.rangeCount > 0 && o.getRangeAt(0) : null;
    document.body.appendChild(e), e.select(), e.selectionStart = 0, e.selectionEnd = n.length, document.execCommand("copy"), document.body.removeChild(e), r && (o.removeAllRanges(), o.addRange(r)), t && t.focus();
  }
}
const pbe = (n, e = !1) => {
  const t = "ABCDEFGHJKLMNPQRSTUVWXY3456789";
  let o = "";
  for (let r = 0; r < n.valueOf(); r++)
    o += t.charAt(Math.floor(Math.random() * t.length));
  return e ? o.toLowerCase() : o;
}, hbe = {
  javascript: ".js",
  python: ".py",
  java: ".java",
  c: ".c",
  cpp: ".cpp",
  "c++": ".cpp",
  "c#": ".cs",
  ruby: ".rb",
  php: ".php",
  swift: ".swift",
  "objective-c": ".m",
  kotlin: ".kt",
  typescript: ".ts",
  go: ".go",
  perl: ".pl",
  rust: ".rs",
  scala: ".scala",
  haskell: ".hs",
  lua: ".lua",
  shell: ".sh",
  sql: ".sql",
  html: ".html",
  css: ".css"
  // add more file extensions here, make sure the key is same as language prop in CodeBlock.tsx component
}, dbe = (n, e, t = "Enter file name") => {
  const o = hbe[n] || ".file", r = `file-${pbe(3, !0)}${o}`, s = window.prompt(t || "", r);
  if (!s)
    return;
  const a = new Blob([e], { type: "text/plain" }), c = URL.createObjectURL(a), l = document.createElement("a");
  l.download = s, l.href = c, l.style.display = "none", document.body.appendChild(l), l.click(), document.body.removeChild(l), URL.revokeObjectURL(c);
}, fbe = { class: "vp-header" }, mbe = { class: "ctrl" }, gbe = /* @__PURE__ */ io({
  __name: "VueMarkDownHeader",
  props: {
    lang: {
      type: String,
      default: "txt"
    },
    copyTxt: {
      type: String,
      default: "Copy"
    },
    copiedTxt: {
      type: String,
      default: "Copied"
    },
    item: {
      type: String,
      default: ""
    },
    downloadTxt: {
      type: String,
      default: "Enter file name"
    }
  },
  setup(n) {
    const e = n, t = We(!1), o = We(null), r = $n(() => t.value ? e.copiedTxt : e.copyTxt);
    function s() {
      const c = /* @__PURE__ */ new Map();
      ube(e.item).then(() => {
        t.value = !0, clearTimeout(c.get(o.value));
        const l = setTimeout(() => {
          t.value = !1, c.delete(o.value);
        }, 2e3);
        c.set(o.value, l);
      });
    }
    function a() {
      dbe(e.lang, e.item, e.downloadTxt);
    }
    return (c, l) => {
      const i = lbe, p = sbe, h = K_e;
      return de(), Te("div", fbe, [
        ae("div", null, it(n.lang), 1),
        ae("div", mbe, [
          ae("div", {
            class: "copyRef ctrl",
            onClick: s,
            ref_key: "copyRef",
            ref: o
          }, [
            t.value ? (de(), lt(p, { key: 1 })) : (de(), lt(i, { key: 0 })),
            ae("span", null, it(lo(r)), 1)
          ], 512),
          uo(h, { onClick: a })
        ])
      ]);
    };
  }
});
function _be(n) {
  let e = n;
  const t = /以下是(.+)续写的代码：\n\n/, o = e.match(t);
  if (o) {
    const s = o[1];
    e = e.replace(t, `以下是${s}续写的代码：

\`\`\`${s.toLocaleLowerCase()}

`);
  }
  const r = /\n```\n/g;
  return e = e.replace(r, "\n``` \n"), e;
}
const bbe = ["innerHTML"], wbe = /* @__PURE__ */ io({
  __name: "VueMarkdownIt",
  props: {
    content: {
      type: String,
      required: !0
    },
    style: {
      type: Object,
      default: () => {
      }
    },
    class: {
      type: String,
      default: ""
    },
    stream: {
      type: Boolean,
      default: !1
    }
  },
  setup(n, { expose: e }) {
    const t = n, o = We(""), r = We(), s = We(), a = /<([a-zA-Z]+)(?:\s+[a-zA-Z]+=(?:"[^"]*"|'[^']*'))*\s*\/?>[\s\S]*?<\/\1\s*>/g, c = /class="language-.*/, l = /class="language-([\w+]+)"/, i = /```([\w+#]+)\n/g;
    function p(S) {
      var L;
      return ((L = l.exec(S)) == null ? void 0 : L[1]) || "";
    }
    function h(S) {
      let L = "";
      const k = new DOMParser().parseFromString(S, "text/html"), w = /shellscript|shell|bash|sh|zsh/.test(p(S));
      return k.querySelectorAll("span.line:not(.diff.remove)").forEach((E) => L += (E.textContent || "") + `
`), w && (L = L.replace(/^ *(\$|>) /gm, "").trim()), L.slice(0, -1);
    }
    const d = $n(() => _be(t.content || "")), f = $n(() => o.value.match(a) || []), m = async () => {
      var L;
      const S = Array.from(d.value.matchAll(i)).map((_) => _[1]);
      if (S && s.value)
        for (let _ = 0; _ < S.length; _++) {
          const k = S[_];
          try {
            const w = Mo[k.toLocaleUpperCase()] || k;
            await s.value(w);
          } catch {
            continue;
          }
        }
      o.value = ((L = r.value) == null ? void 0 : L.render(d.value)) || "";
    };
    return Zo(d, async () => await m()), Jo(async () => {
      const { md: S, loadLang: L } = await Qo(Fo);
      r.value = S, s.value = L, await m();
    }), e({
      md: r
    }), (S, L) => (de(), Te("div", {
      class: Yo(["vp-doc", t.class, { "result-streaming": n.stream }]),
      style: Xo(n.style)
    }, [
      (de(!0), Te(ut, null, Ko(lo(f), (_) => (de(), Te(ut, { key: _ }, [
        c.test(_) ? es(S.$slots, "code", {
          key: 0,
          item: h(_),
          html: _,
          lang: p(_)
        }, () => [
          uo(gbe, {
            lang: p(_),
            item: h(_)
          }, null, 8, ["lang", "item"])
        ]) : ns("", !0),
        ae("div", { innerHTML: _ }, null, 8, bbe)
      ], 64))), 128))
    ], 6));
  }
}), ybe = {
  install(n, e = {
    theme: "dracula-soft",
    defaultHighlightLang: "javascript"
  }) {
    const t = Z_e({
      ...e
    });
    n.provide(Fo, t);
  }
};
export {
  gbe as VueMarkDownHeader,
  wbe as VueMarkdownIt,
  ybe as default
};
